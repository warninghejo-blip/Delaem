<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="fennec-embed" content="0" />
        <meta name="fennec-manifest" content="https://fennecbtc.xyz/recursive_inscriptions/fennec_manifest_live.json" />
        <meta
            name="description"
            content="$FENNEC - The Desert Fox Protocol. Swap, deposit and withdraw on Fractal's fastest DEX with Fennec ID."
        />
        <title>$FENNEC | The Desert Fox Protocol</title>

        <!-- FAVICONS -->
        <link rel="icon" href="img/phav.png" type="image/png" />
        <link rel="apple-touch-icon" href="img/phav.png" />

        <!-- Цвет браузерной строки (чтобы на мобилках сливалось с шапкой) -->
        <meta name="theme-color" content="#000000" />

        <!-- Preconnect для ускорения загрузки -->
        <link rel="preconnect" href="https://cdn.tailwindcss.com" />
        <link rel="preconnect" href="https://cdnjs.cloudflare.com" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link rel="dns-prefetch" href="https://fennec-api.warninghejo.workers.dev" />
        <link rel="dns-prefetch" href="https://open-api-fractal.unisat.io" />

        <!-- Критичные стили -->
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet" />
        <link
            href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@300;400;500;600;700&family=Outfit:wght@300;500;700;900&display=swap"
            rel="stylesheet"
            media="print"
            onload="this.media = 'all'"
        />
        <noscript
            ><link
                href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@300;400;500;600;700&family=Outfit:wght@300;500;700;900&rel=stylesheet"
        /></noscript>

        <script>
            // ГЛОБАЛЬНЫЙ ШИМ STORAGE (предотвращает краш при заблокированных куках/sandbox)
            (function () {
                function makeShim() {
                    var mem = {};
                    return {
                        getItem: function (k) {
                            return mem.hasOwnProperty(k) ? mem[k] : null;
                        },
                        setItem: function (k, v) {
                            mem[k] = String(v);
                        },
                        removeItem: function (k) {
                            delete mem[k];
                        },
                        clear: function () {
                            mem = {};
                        },
                        key: function (i) {
                            return Object.keys(mem)[i] || null;
                        },
                        get length() {
                            return Object.keys(mem).length;
                        }
                    };
                }
                try {
                    var test = window.localStorage;
                    if (!test) throw 1;
                    test.setItem('__test', '1');
                    test.removeItem('__test');
                } catch (e) {
                    try {
                        Object.defineProperty(window, 'localStorage', { value: makeShim(), configurable: true });
                    } catch (e2) {
                        window.localStorage = makeShim();
                    }
                }
                try {
                    var test2 = window.sessionStorage;
                    if (!test2) throw 1;
                    test2.setItem('__test', '1');
                    test2.removeItem('__test');
                } catch (e) {
                    try {
                        Object.defineProperty(window, 'sessionStorage', { value: makeShim(), configurable: true });
                    } catch (e2) {
                        window.sessionStorage = makeShim();
                    }
                }
            })();

            // Wait for Tailwind to load before configuring
            if (typeof tailwind !== 'undefined') {
                tailwind.config = {
                    theme: {
                        extend: {
                            colors: { fennec: '#FF6B35', sand: '#E6CCB2', dark: '#0C0C0C' },
                            fontFamily: { sans: ['Outfit', 'sans-serif'], display: ['Space Grotesk', 'sans-serif'] },
                            animation: {
                                float: 'float 7s ease-in-out infinite',
                                ears: 'ears 4s ease-in-out infinite alternate'
                            },
                            keyframes: {
                                float: {
                                    '0%, 100%': { transform: 'translateY(0)' },
                                    '50%': { transform: 'translateY(-10px)' }
                                },
                                ears: { '0%': { transform: 'rotate(-3deg)' }, '100%': { transform: 'rotate(3deg)' } }
                            }
                        }
                    }
                };
            } else {
                // If Tailwind hasn't loaded yet, wait for it
                window.addEventListener('load', function () {
                    if (typeof tailwind !== 'undefined') {
                        tailwind.config = {
                            theme: {
                                extend: {
                                    colors: { fennec: '#FF6B35', sand: '#E6CCB2', dark: '#0C0C0C' },
                                    fontFamily: {
                                        sans: ['Outfit', 'sans-serif'],
                                        display: ['Space Grotesk', 'sans-serif']
                                    },
                                    animation: {
                                        float: 'float 7s ease-in-out infinite',
                                        ears: 'ears 4s ease-in-out infinite alternate'
                                    },
                                    keyframes: {
                                        float: {
                                            '0%, 100%': { transform: 'translateY(0)' },
                                            '50%': { transform: 'translateY(-10px)' }
                                        },
                                        ears: {
                                            '0%': { transform: 'rotate(-3deg)' },
                                            '100%': { transform: 'rotate(3deg)' }
                                        }
                                    }
                                }
                            }
                        };
                    }
                });
            }
        </script>

        <style>
            @keyframes marquee {
                0% {
                    transform: translateX(0);
                }
                100% {
                    transform: translateX(-100%);
                }
            }

            .ticker-content {
                display: inline-block;
                white-space: nowrap;
                animation: marquee 30s linear infinite;
            }

            :root {
                --bg-primary: #000;
                --bg-secondary: #0c0c0c;
                --bg-tertiary: #1e1f24;
                --text-primary: #fff;
                --text-secondary: rgba(255, 255, 255, 0.8);
                --text-muted: rgba(255, 255, 255, 0.5);
                --border-color: rgba(255, 255, 255, 0.1);
                --overlay-bg: rgba(0, 0, 0, 0.92);
            }

            [data-theme='light'] {
                --bg-primary: #f5f5f5;
                --bg-secondary: #fff;
                --bg-tertiary: #fafafa;
                --text-primary: #1a1a1a;
                --text-secondary: rgba(0, 0, 0, 0.8);
                --text-muted: rgba(0, 0, 0, 0.5);
                --border-color: rgba(0, 0, 0, 0.1);
                --overlay-bg: rgba(255, 255, 255, 0.95);
            }

            /* DESIGN: GOLDEN HOUR DESERT */
            body {
                background: radial-gradient(circle at 50% -20%, #5e3a2a 0%, #2c1a12 60%, #0d0604 100%);
                color: #f3f3f3;
                min-height: 100vh;
                overflow-x: hidden;
            }

            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.06'/%3E%3C/svg%3E");
                pointer-events: none;
                z-index: 0;
                mix-blend-mode: soft-light;
                filter: sepia(0.35) saturate(1.35) brightness(1.1);
            }

            .hero-fox-bg {
                display: none; /* Убран фоновый логотип */
                -webkit-mask-image: radial-gradient(circle, black 30%, transparent 70%);
                mask-image: radial-gradient(circle, black 30%, transparent 70%);
                pointer-events: none;
                z-index: 0;
                filter: sepia(0.5) contrast(1.2);
            }

            .glass-panel {
                background: rgba(50, 40, 35, 0.35);
                backdrop-filter: blur(16px);
                border: 1px solid rgba(255, 107, 53, 0.15);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            }

            .text-glow {
                text-shadow: 0 0 30px rgba(255, 107, 53, 0.4);
            }

            /* GLASS CARD */
            .glass {
                background: rgba(20, 20, 20, 0.85);
                backdrop-filter: blur(30px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 30px 80px -10px rgba(0, 0, 0, 0.9);
                border-radius: 24px;
            }
            /* Fallback CSS Ears if image missing */
            .fennec-art:empty::before,
            .fennec-art:empty::after {
                content: '';
                position: absolute;
                bottom: 0;
                background: linear-gradient(to top, #5d4037, #ff6b35);
                border-radius: 50% 100% 0 0;
                border: 3px solid #3e2723;
                box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
            }
            .fennec-art:empty::before {
                right: 80px;
                width: 80px;
                height: 220px;
                transform: rotate(-15deg);
            }
            .fennec-art:empty::after {
                right: 10px;
                width: 90px;
                height: 200px;
                transform: rotate(10deg);
            }

            /* UI */
            .glass-card {
                background: rgba(20, 20, 20, 0.85);
                backdrop-filter: blur(30px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 30px 80px -10px rgba(0, 0, 0, 0.9);
            }
            .input-box {
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(255, 255, 255, 0.15);
                transition: all 0.2s;
            }
            .input-box:focus-within {
                border-color: #ff6b35;
                background: rgba(0, 0, 0, 0.7);
            }

            /* Hide number input spinners */
            input[type='number']::-webkit-inner-spin-button,
            input[type='number']::-webkit-outer-spin-button {
                -webkit-appearance: none;
                appearance: none;
                margin: 0;
            }
            input[type='number'] {
                -moz-appearance: textfield;
                appearance: textfield;
            }

            .tab-btn {
                cursor: pointer;
                padding: 14px;
                font-weight: 800;
                color: #999;
                border-bottom: 2px solid transparent;
                transition: 0.3s;
                text-transform: uppercase;
                letter-spacing: 1px;
                font-size: 12px;
            }
            .tab-btn:hover {
                color: #fff;
            }
            .tab-btn.active {
                color: #ff6b35;
                border-color: #ff6b35;
                background: linear-gradient(to top, rgba(255, 107, 53, 0.1), transparent);
            }

            .tab-content {
                display: none;
                animation: fadeIn 0.3s ease-out;
            }
            .tab-content.active {
                display: block;
            }
            .tab-content.hidden {
                display: none !important;
            }

            .card-tab-btn {
                cursor: pointer;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            .card-tab-btn.active {
                color: #ff6b35;
                border-color: rgba(255, 107, 53, 0.45);
            }

            .card-tab-content {
                display: block;
                animation: fadeIn 0.3s ease-out;
            }
            .card-tab-content.hidden {
                display: none !important;
            }
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            /* Page Sections */
            .page-section {
                display: none;
            }
            .page-section.active {
                display: block !important;
            }
            .nav-link.active {
                color: #ff6b35;
                border-bottom: 2px solid #ff6b35;
            }
            .roadmap-line {
                position: absolute;
                left: 23px;
                top: 0;
                bottom: 0;
                width: 2px;
                background: linear-gradient(to bottom, #ff6b35, transparent);
            }

            /* Modals */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.92);
                backdrop-filter: blur(8px);
                z-index: 9999;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow-y: auto;
                padding: 24px 16px;
            }
            .modal-box {
                background: #111;
                border: 1px solid #333;
                padding: 32px;
                border-radius: 24px;
                width: 90%;
                max-width: 420px;
                max-height: calc(100vh - 48px);
                overflow: auto;
                -webkit-overflow-scrolling: touch;
                box-shadow: 0 0 60px rgba(255, 107, 53, 0.15);
            }

            /* ===== PERFORMANCE OPTIMIZATIONS ===== */

            /* Skeleton Loaders */
            .skeleton {
                background: linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.05) 25%,
                    rgba(255, 255, 255, 0.1) 50%,
                    rgba(255, 255, 255, 0.05) 75%
                );
                background-size: 200% 100%;
                animation: shimmer 1.5s infinite;
                border-radius: 8px;
                height: 20px;
            }
            @keyframes shimmer {
                0% {
                    background-position: 200% 0;
                }
                100% {
                    background-position: -200% 0;
                }
            }

            /* Progress Bar */
            .progress-bar {
                position: relative;
                height: 6px;
                background: linear-gradient(
                    90deg,
                    rgba(255, 107, 53, 0.1),
                    rgba(168, 85, 247, 0.1),
                    rgba(59, 130, 246, 0.1)
                );
                border-radius: 8px;
                overflow: hidden;
                margin: 12px 0;
                box-shadow:
                    0 0 20px rgba(255, 107, 53, 0.15),
                    inset 0 1px 3px rgba(0, 0, 0, 0.3);
            }
            .progress-bar::before {
                content: '';
                position: absolute;
                inset: 0;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
                animation: shimmer-bg 2s linear infinite;
            }
            @keyframes shimmer-bg {
                0% {
                    transform: translateX(-100%);
                }
                100% {
                    transform: translateX(100%);
                }
            }
            .progress-fill {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                background: linear-gradient(90deg, #ff6b35, #a855f7, #3b82f6, #ff6b35);
                background-size: 200% 100%;
                transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
                animation: gradient-flow 3s ease-in-out infinite;
            }
            @keyframes gradient-flow {
                0%,
                100% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
            }
            .progress-fill.indeterminate {
                width: 40%;
                animation:
                    progress-slide 1.2s cubic-bezier(0.4, 0, 0.6, 1) infinite,
                    gradient-flow 3s ease-in-out infinite;
            }
            @keyframes progress-slide {
                0% {
                    left: -40%;
                }
                100% {
                    left: 100%;
                }
            }

            /* Spinner */
            .spinner {
                display: inline-block;
                width: 16px;
                height: 16px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-top-color: #ff6b35;
                border-radius: 50%;
                animation: spin 0.6s linear infinite;
                vertical-align: middle;
            }
            @keyframes spin {
                100% {
                    transform: rotate(360deg);
                }
            }

            /* Smooth transitions */
            button,
            .tab-btn,
            .input-box {
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            }
            button:active {
                transform: scale(0.98);
            }

            /* STRONG NEON GLOW */
            .neon-text {
                text-shadow:
                    0 0 5px #fff,
                    0 0 10px #fff,
                    0 0 20px #ff6b35,
                    0 0 40px #ff6b35,
                    0 0 80px #ff6b35;
            }

            .neon-logo {
                filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8)) drop-shadow(0 0 20px rgba(255, 107, 53, 0.4));
                transition: all 0.3s ease;
            }
            .neon-logo:hover {
                filter: drop-shadow(0 0 15px rgba(255, 107, 53, 1)) drop-shadow(0 0 30px rgba(255, 107, 53, 0.6));
                transform: scale(1.05);
            }

            /* Custom Scrollbar */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            ::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 4px;
            }
            ::-webkit-scrollbar-thumb {
                background: rgba(255, 107, 53, 0.5);
                border-radius: 4px;
                transition: background 0.2s;
            }
            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 107, 53, 0.8);
            }

            /* ИСПРАВЛЕНИЕ: Ползунок на обратной стороне карточки справа */
            /* ИСПРАВЛЕНИЕ: Скроллбар справа, текст по центру */
            .achievement-scroll {
                overflow-y: auto;
                overflow-x: hidden;
                text-align: center;
            }
            .achievement-scroll > * {
                text-align: center !important; /* ИСПРАВЛЕНИЕ: Центрируем текст */
            }
            /* ИСПРАВЛЕНИЕ: Стилизация скроллбара справа */
            .achievement-scroll::-webkit-scrollbar {
                width: 6px;
            }
            .achievement-scroll::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 3px;
            }
            .achievement-scroll::-webkit-scrollbar-thumb {
                background: rgba(255, 107, 53, 0.5);
                border-radius: 3px;
            }
            .achievement-scroll::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 107, 53, 0.8);
            }

            /* Loading state */
            .loading {
                opacity: 0.6;
                pointer-events: none;
            }

            /* Notifications */
            .notification {
                position: fixed;
                top: 100px;
                right: 20px;
                background: var(--bg-tertiary);
                border: 1px solid var(--border-color);
                padding: 16px 20px;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                min-width: 280px;
                animation: slideIn 0.3s ease-out;
                backdrop-filter: blur(20px);
            }
            @keyframes slideIn {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            /* ===== THE DIG ANIMATION ===== */
            @keyframes digShake {
                0% {
                    transform: translate(0, 0) rotate(0deg);
                }
                25% {
                    transform: translate(-2px, 2px) rotate(-5deg);
                }
                50% {
                    transform: translate(2px, -1px) rotate(5deg);
                }
                75% {
                    transform: translate(-1px, 2px) rotate(-5deg);
                }
                100% {
                    transform: translate(0, 0) rotate(0deg);
                }
            }
            @keyframes dirtFly {
                0% {
                    opacity: 0;
                    transform: translateY(0) scale(0.5);
                }
                50% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                    transform: translateY(-40px) translateX(20px) scale(1.2);
                }
            }
            /* ===== FOX EVOLUTION EFFECTS (3D CARD DESIGN) ===== */

            /* === 3D CARD CONTAINER === */
            /* ИСПРАВЛЕНИЕ: Полностью переписан CSS для стабильности 3D карточки */
            /* === 3D CARD CONTAINER (ULTIMATE FIX) === */
            .card-scene {
                perspective: 1200px;
                width: 336px;
                height: 490px; /* Чуть выше для лучшей компоновки */
                margin: 0 auto;
                position: relative;
                z-index: 10;
            }

            .card-scene,
            .card-scene * {
                font-family:
                    system-ui,
                    -apple-system,
                    'Segoe UI',
                    Roboto,
                    Arial,
                    sans-serif;
            }

            .card-object {
                width: 100%;
                height: 100%;
                position: relative;
                transform-style: preserve-3d;
                transform-origin: center center;
                transition: transform 620ms cubic-bezier(0.4, 0, 0.2, 1);
                --tiltX: 0deg;
                --tiltY: 0deg;
                --flipY: 0deg;
                transform: rotateX(var(--tiltX)) rotateY(calc(var(--tiltY) + var(--flipY)));
                border-radius: 20px;
                overflow: visible;
                will-change: transform;
                box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.5);
            }

            .card-object::after {
                content: '';
                position: absolute;
                inset: 0;
                border-radius: 20px;
                pointer-events: none;
                z-index: 40;
                opacity: 0;
                mix-blend-mode: overlay;
                background:
                    linear-gradient(
                        115deg,
                        rgba(255, 255, 255, 0.16),
                        rgba(255, 255, 255, 0) 45%,
                        rgba(255, 255, 255, 0.1) 55%,
                        rgba(255, 255, 255, 0) 70%
                    ),
                    linear-gradient(
                        45deg,
                        rgba(255, 255, 255, 0.014),
                        rgba(255, 255, 255, 0) 55%,
                        rgba(255, 255, 255, 0.01)
                    );
            }

            .card-object:not([data-vfx='ENGINEER']) .face-front::before {
                content: '';
                position: absolute;
                top: -140%;
                left: -180%;
                width: 72px;
                height: 420%;
                border-radius: 20px;
                pointer-events: none;
                z-index: 14;
                opacity: 0;
                mix-blend-mode: screen;
                transform: rotate(22deg);
                will-change: left, opacity;
                filter: blur(3px);
                background: linear-gradient(
                    45deg,
                    transparent 28%,
                    rgba(var(--tier-shine-rgb, 255, 215, 0), 0.4) 50%,
                    transparent 72%
                );
                animation: tierShineSweep var(--tier-shine-dur, 9.5s) ease-in-out infinite;
            }

            .card-object[data-tier='0'] {
                --tier-shine-opacity: 0;
                --tier-shine-dur: 999s;
            }
            .card-object[data-tier='1'] {
                --tier-shine-opacity: 0.28;
                --tier-shine-dur: 12s;
            }
            .card-object[data-tier='2'] {
                --tier-shine-opacity: 0.4;
                --tier-shine-dur: 9s;
            }
            .card-object[data-tier='3'] {
                --tier-shine-opacity: 0.52;
                --tier-shine-dur: 7.5s;
            }

            .card-object[data-vfx='MERCHANT'] {
                --tier-shine-rgb: 255, 215, 0;
            }

            @keyframes tierShineSweep {
                0% {
                    left: -180%;
                    opacity: 0;
                }
                18% {
                    left: -180%;
                    opacity: 0;
                }
                22% {
                    left: -180%;
                    opacity: var(--tier-shine-opacity, 0.22);
                }
                82% {
                    left: 180%;
                    opacity: var(--tier-shine-opacity, 0.22);
                }
                86% {
                    left: 180%;
                    opacity: 0;
                }
                100% {
                    left: 180%;
                    opacity: 0;
                }
            }

            .card-object.is-flipped {
                --flipY: 180deg;
            }

            /* ОБЩИЕ СТИЛИ СТОРОН */
            .card-face {
                position: absolute;
                inset: 0; /* top:0, left:0, right:0, bottom:0 */
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                border-radius: 20px;
                overflow: hidden;
                background: transparent;
                transform: translateZ(0); /* Фикс для Safari */
            }

            /* ИСПРАВЛЕНИЕ: Обрезаем фон чтобы не выезжал за рамку - закругленные края как у рамки */
            .card-face img {
                border-radius: 20px;
                clip-path: inset(0 round 20px);
            }

            /* ИСПРАВЛЕНИЕ: Градиентные оверлеи тоже должны быть закруглены */
            .card-face > div[class*='bg-gradient'],
            .card-face > div[style*='background'] {
                border-radius: 20px;
                clip-path: inset(0 round 20px);
            }

            /* ИСПРАВЛЕНИЕ: КРИТИЧЕСКОЕ - Правильная структура для 3D flip без отзеркаливания */
            .face-back {
                transform: rotateY(180deg);
            }

            /* Переопределяем фон для rarity классов */
            .card-face.card-cub {
                background: radial-gradient(circle at center, rgba(82, 82, 91, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .card-face.card-scout {
                background: radial-gradient(circle at center, rgba(34, 197, 94, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .card-face.card-hunter {
                background: radial-gradient(circle at center, rgba(59, 130, 246, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .card-face.card-alpha {
                background: radial-gradient(circle at center, rgba(239, 68, 68, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .card-face.card-elder {
                background: radial-gradient(circle at center, rgba(234, 179, 8, 0.2) 0%, rgba(0, 0, 0, 0.8) 70%);
            }

            /* ЛИЦЕВАЯ СТОРОНА */
            .face-front {
                z-index: 2;
                transform: rotateY(0deg);
            }

            /* ЗАДНЯЯ СТОРОНА (TECH DATA DESIGN) */
            .face-back {
                transform: rotateY(180deg);
                z-index: 1;
                display: flex;
                flex-direction: column;
                /* Текстура заднего фона: темная сетка */
                background-color: transparent;
                background-image: none;
                background-size: auto;
            }

            /* Декоративный элемент сзади (чип) */
            .face-back::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 200px;
                height: 200px;
                transform: translate(-50%, -50%);
                display: none;
                background: none;
                pointer-events: none;
            }

            /* Стильный скроллбар для списка бейджей */
            .custom-scroll {
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: #ff6b35 rgba(255, 255, 255, 0.05);
            }
            .custom-scroll::-webkit-scrollbar {
                width: 4px;
            }
            .custom-scroll::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }
            .custom-scroll::-webkit-scrollbar-thumb {
                background-color: #ff6b35;
                border-radius: 10px;
            }

            /* Разделитель на задней стороне */
            .tech-divider {
                height: 1px;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
                margin: 10px 0;
            }

            /* === PROGRESSIVE VISUAL EVOLUTION (TIER 0 - TIER 3) === */

            /* База для плавности */
            .card-face img {
                transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
                will-change: transform, filter;
            }

            .card-face [class^='overlay-'],
            .card-face [class*=' overlay-'] {
                z-index: 12 !important;
            }

            .face [class^='overlay-'],
            .face [class*=' overlay-'] {
                z-index: 12 !important;
            }

            .vfx-3d {
                position: absolute;
                inset: 0;
                border-radius: inherit;
                pointer-events: none;
                z-index: 13;
                display: block;
                opacity: calc(var(--vfx3d-opacity, 0.24) * var(--vfx3d-mult, 1));
                mix-blend-mode: screen;
                overflow: hidden;
            }

            .vfx-webgl {
                position: absolute;
                inset: 0;
                border-radius: inherit;
                pointer-events: none;
                z-index: 13;
                overflow: hidden;
                display: block;
                opacity: calc(var(--vfxwebgl-opacity, 0.18) * var(--vfxwebgl-mult, 1));
                mix-blend-mode: screen;
            }
            .vfx-webgl canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            .card-object:not([data-vfx='ENGINEER']) .vfx-3d,
            .card-object:not([data-vfx='ENGINEER']) .vfx-webgl {
                display: none !important;
            }

            .card-object[data-vfx='ENGINEER'][data-tier='2'] .vfx-3d,
            .card-object[data-vfx='ENGINEER'][data-tier='3'] .vfx-3d {
                display: none !important;
            }

            .card-glare {
                position: absolute;
                inset: 0;
                border-radius: 20px;
                pointer-events: none;
                mix-blend-mode: overlay;
                display: none !important;
                opacity: 0;
                transition: opacity 120ms linear;
                background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.12) 0%, transparent 60%);
            }
            .vfx-3d::before {
                content: '';
                position: absolute;
                inset: -30%;
                background:
                    radial-gradient(
                        circle at var(--mxp, 50%) var(--myp, 50%),
                        rgba(var(--vfx-rgb, 255, 255, 255), 0.12),
                        rgba(var(--vfx-rgb, 255, 255, 255), 0.06) 30%,
                        transparent 65%
                    ),
                    linear-gradient(135deg, transparent, rgba(var(--vfx-rgb2, 255, 255, 255), 0.04), transparent);
                filter: blur(6px) saturate(1.05) brightness(1.02);
                transform: translate3d(calc(var(--npx, 0px) * 0.8), calc(var(--npy, 0px) * 0.8), 0);
                animation: vfx-pulse 4s ease-in-out infinite;
                opacity: 0.5;
            }
            .vfx-3d::after {
                content: '';
                position: absolute;
                inset: -15%;
                background:
                    radial-gradient(
                        circle at var(--mxp, 50%) var(--myp, 50%),
                        rgba(var(--vfx-rgb, 255, 255, 255), 0.18),
                        rgba(var(--vfx-rgb2, 255, 255, 255), 0.08) 35%,
                        transparent 55%
                    ),
                    linear-gradient(
                        90deg,
                        rgba(255, 255, 255, 0.08),
                        transparent 40%,
                        rgba(255, 255, 255, 0.05) 60%,
                        transparent
                    );
                background-size:
                    100% 100%,
                    280% 280%;
                background-position:
                    0 0,
                    calc(var(--mxp, 50%) * 1%) calc(var(--myp, 50%) * 1%);
                mix-blend-mode: screen;
                filter: blur(2px);
                opacity: 0.4;
                transform: translate3d(calc(var(--px, 0px) * 0.8), calc(var(--py, 0px) * 0.8), 0) scale(1.02);
                animation:
                    vfx-sheen 6s linear infinite,
                    vfx-shimmer 3s ease-in-out infinite;
            }

            @keyframes vfx-sheen {
                0% {
                    background-position:
                        0 0,
                        0% 0%,
                        0 0;
                }
                100% {
                    background-position:
                        0 0,
                        200% 200%,
                        0 0;
                }
            }
            @keyframes vfx-pulse {
                0%,
                100% {
                    opacity: 1;
                    filter: blur(14px) saturate(1.6) brightness(1.3);
                }
                50% {
                    opacity: 0.9;
                    filter: blur(16px) saturate(1.8) brightness(1.45);
                }
            }
            @keyframes vfx-shimmer {
                0%,
                100% {
                    opacity: 0.95;
                }
                50% {
                    opacity: 1;
                }
            }

            .overlay-MERCHANT ~ .vfx-3d {
                --vfx-rgb: 255, 200, 0;
                --vfx-rgb2: 255, 230, 150;
                --vfx3d-mult: 0.55;
            }
            .overlay-SHAMAN ~ .vfx-3d {
                --vfx-rgb: 168, 85, 247;
                --vfx-rgb2: 59, 130, 246;
            }
            .overlay-KEEPER ~ .vfx-3d {
                --vfx-rgb: 251, 146, 60;
                --vfx-rgb2: 255, 255, 255;
                --vfx3d-mult: 0.6;
            }
            .overlay-LORD ~ .vfx-3d {
                --vfx-rgb: 6, 182, 212;
                --vfx-rgb2: 255, 255, 255;
            }
            .overlay-PRIME ~ .vfx-3d {
                --vfx-rgb: 255, 255, 255;
                --vfx-rgb2: 255, 255, 255;
            }
            .overlay-DRIFTER ~ .vfx-3d {
                --vfx-rgb: 255, 160, 0;
                --vfx-rgb2: 255, 255, 255;
            }
            .overlay-WALKER ~ .vfx-3d {
                --vfx-rgb: 59, 130, 246;
                --vfx-rgb2: 255, 255, 255;
            }
            .overlay-ENGINEER ~ .vfx-3d {
                --vfx-rgb: 0, 255, 170;
                --vfx-rgb2: 255, 0, 80;
            }
            .overlay-SINGULARITY ~ .vfx-3d {
                --vfx-rgb: 255, 255, 255;
                --vfx-rgb2: 168, 85, 247;
            }

            .overlay-MERCHANT ~ .vfx-webgl {
                --vfxwebgl-mult: 0.8;
            }
            .overlay-KEEPER ~ .vfx-webgl {
                --vfxwebgl-mult: 0.7;
            }
            .card-object[data-tier='3'] .overlay-ENGINEER ~ .vfx-3d {
                --vfx3d-mult: 1.24;
            }
            .card-object[data-tier='3'] .overlay-ENGINEER ~ .vfx-webgl {
                --vfxwebgl-mult: 1.13;
            }

            /* --- TIER 0: DORMANT (Новичок) --- */
            /* Статичный, пыльный, старый вид */
            .img-tier-0 {
                filter: grayscale(0.2) sepia(0.16) contrast(1) brightness(1) saturate(1.05);
                transform: scale(1.01);
            }

            /* --- TIER 1: AWAKENING (Адепт) --- */
            /* Легкое "дыхание", возвращение цветов */
            .anim-tier-1 {
                animation: breathe 10s ease-in-out infinite alternate;
            }
            @keyframes breathe {
                0% {
                    filter: grayscale(0.08) contrast(1.02) brightness(1) saturate(1.04);
                }
                100% {
                    filter: grayscale(0) contrast(1.06) brightness(1.06) saturate(1.1);
                }
            }

            /* --- TIER 2: EMPOWERED (Эксперт) --- */
            /* Усиленные эффекты, специфичные для группы классов */

            /* Drifter/Walker: Тепловая волна */
            .anim-tier-2-heat {
                animation: heat-low 5s infinite alternate;
            }
            @keyframes heat-low {
                0% {
                    filter: sepia(0.08) contrast(1.06) brightness(1.02) saturate(1.04);
                }
                100% {
                    filter: sepia(0.16) contrast(1.1) brightness(1.05) saturate(1.06);
                }
            }

            /* Merchant/Lord: Мягкий блеск */
            .anim-tier-2-shine {
                animation: shine-low 4s infinite alternate;
            }
            @keyframes shine-low {
                0% {
                    filter: brightness(1.03) contrast(1.04) saturate(1.06);
                }
                100% {
                    filter: brightness(1.1) contrast(1.06) saturate(1.12);
                }
            }

            /* Engineer: Микро-глитчи */
            .anim-tier-2-glitch {
                animation: glitch-low 3s infinite;
            }
            @keyframes glitch-low {
                0%,
                92% {
                    filter: contrast(1.12) brightness(1.03) saturate(1.08);
                    transform: translate3d(0, 0, 0);
                }
                93% {
                    filter: contrast(1.22) brightness(1.05) saturate(1.12) hue-rotate(3deg);
                    transform: translate3d(1px, 0, 0);
                }
                94% {
                    filter: contrast(1.22) brightness(1.05) saturate(1.12) hue-rotate(-3deg);
                    transform: translate3d(-1px, 0, 0);
                }
                100% {
                    filter: contrast(1.12) brightness(1.03) saturate(1.08);
                    transform: translate3d(0, 0, 0);
                }
            }

            /* Shaman/Keeper/Prime: Пульсация ауры */
            .anim-tier-2-magic {
                animation: magic-low 4s infinite alternate;
            }
            @keyframes magic-low {
                0% {
                    filter: saturate(1.08) contrast(1.04) brightness(1.02);
                }
                100% {
                    filter: saturate(1.16) contrast(1.06) brightness(1.06);
                }
            }

            /* --- TIER 3: UNLEASHED (Легенда - GOD MODE) --- */
            /* Уникальная анимация для каждого архетипа + Оверлеи */

            /* 1. DRIFTER */
            .anim-DRIFTER {
                animation: drifter-dunes 10s ease-in-out infinite;
            }
            .overlay-DRIFTER {
                background: linear-gradient(to bottom, rgba(255, 160, 0, 0.1), transparent 70%);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-DRIFTER::before {
                content: '';
                position: absolute;
                inset: -12%;
                background:
                    radial-gradient(120% 60% at 10% 82%, rgba(255, 200, 120, 0.16) 0%, transparent 55%),
                    radial-gradient(120% 60% at 90% 70%, rgba(255, 160, 0, 0.12) 0%, transparent 60%),
                    linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
                background-size:
                    140% 140%,
                    140% 140%,
                    240% 240%;
                background-position:
                    0% 0%,
                    100% 0%,
                    0% 50%;
                opacity: 0.55;
                mix-blend-mode: overlay;
                animation: drifter-drift 9s linear infinite;
            }
            .overlay-DRIFTER::after {
                content: '';
                position: absolute;
                inset: -18%;
                background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
                opacity: 0.2;
                mix-blend-mode: screen;
                filter: blur(1px);
                animation: drifter-wind 6s ease-in-out infinite;
            }
            @keyframes drifter-dunes {
                0%,
                100% {
                    filter: sepia(0.1) contrast(1.05) brightness(1.02) saturate(1.04);
                }
                50% {
                    filter: sepia(0.16) contrast(1.08) brightness(1.05) saturate(1.07);
                }
            }
            @keyframes drifter-drift {
                0% {
                    background-position:
                        0% 0%,
                        100% 0%,
                        0% 50%;
                }
                100% {
                    background-position:
                        120% 10%,
                        -20% -10%,
                        200% 60%;
                }
            }
            @keyframes drifter-wind {
                0%,
                100% {
                    transform: translate3d(-3%, 0, 0);
                }
                50% {
                    transform: translate3d(3%, -1%, 0);
                }
            }

            /* 2. MERCHANT */
            .anim-MERCHANT {
                animation: merchant-shine 5s ease-in-out infinite;
            }
            .overlay-MERCHANT {
                background: transparent;
                mix-blend-mode: screen;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-MERCHANT::before {
                content: '';
                position: absolute;
                top: -100%;
                left: -100%;
                width: 80px;
                height: 400%;
                background: linear-gradient(45deg, transparent 30%, rgba(255, 215, 0, 0.4) 50%, transparent 70%);
                transform: rotate(45deg);
                animation: gold-sweep 6s ease-in-out infinite;
                filter: blur(3px);
            }
            .overlay-MERCHANT::after {
                content: '';
                position: absolute;
                inset: -15%;
                background:
                    radial-gradient(60% 60% at 35% 35%, rgba(255, 255, 255, 0.12), transparent 68%),
                    radial-gradient(70% 70% at 70% 65%, rgba(255, 215, 0, 0.1), transparent 72%),
                    linear-gradient(120deg, rgba(255, 255, 255, 0.04), transparent 60%, rgba(255, 215, 0, 0.03));
                opacity: 0.2;
                mix-blend-mode: screen;
                animation: sparkle-drift 5.2s ease-in-out infinite alternate;
                filter: blur(0.25px);
            }
            @keyframes merchant-shine {
                0%,
                100% {
                    filter: contrast(1.05) brightness(1.02) saturate(1.06);
                }
                50% {
                    filter: contrast(1.08) brightness(1.06) saturate(1.1) drop-shadow(0 0 8px rgba(255, 215, 0, 0.15));
                }
            }
            @keyframes gold-sweep {
                0%,
                100% {
                    left: -100%;
                    opacity: 0;
                }
                45% {
                    opacity: 0;
                }
                50% {
                    opacity: 1;
                }
                55% {
                    opacity: 0;
                }
            }
            @keyframes sparkle-drift {
                0% {
                    transform: translate3d(-1%, 1%, 0);
                    opacity: 0.15;
                }
                100% {
                    transform: translate3d(1%, -1%, 0);
                    opacity: 0.25;
                }
            }

            /* 3. ENGINEER */
            .anim-ENGINEER {
                animation: engineer-pulse 4s ease-in-out infinite;
            }
            .overlay-ENGINEER {
                background:
                    repeating-linear-gradient(
                        0deg,
                        rgba(0, 255, 170, 0),
                        rgba(0, 255, 170, 0) 10px,
                        rgba(0, 255, 170, 0.1) 11px
                    ),
                    repeating-linear-gradient(
                        90deg,
                        rgba(0, 255, 170, 0),
                        rgba(0, 255, 170, 0) 14px,
                        rgba(0, 200, 255, 0.08) 15px
                    );
                z-index: 5;
                pointer-events: none;
                mix-blend-mode: overlay;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
                opacity: 0.55;
            }
            .overlay-ENGINEER::before {
                content: '';
                position: absolute;
                inset: -10%;
                background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.12) 50%, transparent 100%);
                opacity: 0.22;
                mix-blend-mode: screen;
                animation: engineer-scan 2.6s linear infinite;
                filter: blur(0.8px);
            }
            .overlay-ENGINEER::after {
                content: '';
                position: absolute;
                inset: -15%;
                background:
                    radial-gradient(70% 60% at 35% 40%, rgba(0, 255, 170, 0.14), transparent 72%),
                    radial-gradient(80% 70% at 70% 65%, rgba(0, 200, 255, 0.1), transparent 76%),
                    linear-gradient(135deg, rgba(255, 255, 255, 0.05), transparent 60%, rgba(0, 255, 170, 0.04));
                opacity: 0.18;
                mix-blend-mode: screen;
                animation: engineer-nodes 5.6s ease-in-out infinite alternate;
            }
            @keyframes engineer-pulse {
                0%,
                100% {
                    filter: contrast(1.1) brightness(1.03) saturate(1.06);
                }
                50% {
                    filter: contrast(1.16) brightness(1.06) saturate(1.12);
                }
            }
            @keyframes engineer-scan {
                0% {
                    transform: translate3d(-120%, 0, 0);
                }
                100% {
                    transform: translate3d(120%, 0, 0);
                }
            }
            @keyframes engineer-nodes {
                0% {
                    transform: translate3d(-1%, 1%, 0);
                    opacity: 0.14;
                }
                100% {
                    transform: translate3d(1%, -1%, 0);
                    opacity: 0.22;
                }
            }
            @keyframes engineer-glitch {
                0%,
                92% {
                    filter: contrast(1.12) brightness(1.04) saturate(1.06);
                    transform: translate3d(0, 0, 0);
                }
                94% {
                    filter: contrast(1.3) brightness(1.07) saturate(1.15) hue-rotate(18deg);
                    transform: translate3d(2px, 0, 0);
                }
                96% {
                    filter: contrast(1.3) brightness(1.07) saturate(1.15) hue-rotate(-18deg);
                    transform: translate3d(-2px, 0, 0);
                }
                98%,
                100% {
                    filter: contrast(1.12) brightness(1.04) saturate(1.06);
                    transform: translate3d(0, 0, 0);
                }
            }

            @keyframes engineer-glitch-strong {
                0%,
                90% {
                    filter: contrast(1.14) brightness(1.05) saturate(1.08);
                    transform: translate3d(0, 0, 0);
                }
                92% {
                    filter: contrast(1.46) brightness(1.1) saturate(1.26) hue-rotate(36deg);
                    transform: translate3d(4px, -1px, 0);
                }
                94% {
                    filter: contrast(1.46) brightness(1.1) saturate(1.26) hue-rotate(-36deg);
                    transform: translate3d(-4px, 1px, 0);
                }
                96% {
                    filter: contrast(1.32) brightness(1.08) saturate(1.18) hue-rotate(18deg);
                    transform: translate3d(2px, 0, 0);
                }
                98%,
                100% {
                    filter: contrast(1.14) brightness(1.05) saturate(1.08);
                    transform: translate3d(0, 0, 0);
                }
            }

            .card-object[data-vfx='ENGINEER'][data-tier='2'] .overlay-ENGINEER {
                animation: engineer-glitch 3.2s ease-in-out infinite;
            }
            .card-object[data-vfx='ENGINEER'][data-tier='3'] .overlay-ENGINEER {
                animation: engineer-glitch-strong 3.2s ease-in-out infinite;
            }

            /* 4. SHAMAN */
            .anim-SHAMAN {
                animation: shaman-tide 6s ease-in-out infinite;
            }
            .overlay-SHAMAN {
                background: radial-gradient(circle at 50% 55%, rgba(147, 51, 234, 0.14), transparent 62%);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-SHAMAN::before {
                content: '';
                position: absolute;
                inset: -20%;
                background: radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.22) 0%, transparent 55%);
                opacity: 0.3;
                mix-blend-mode: screen;
                filter: blur(1.4px);
                animation: shaman-ripple 5s ease-in-out infinite;
            }
            .overlay-SHAMAN::after {
                content: '';
                position: absolute;
                inset: -25%;
                background: radial-gradient(circle at 50% 50%, rgba(59, 130, 246, 0.16) 0%, transparent 60%);
                opacity: 0.24;
                mix-blend-mode: screen;
                filter: blur(1.6px);
                animation: shaman-ripple 5s ease-in-out infinite 0.7s;
            }
            @keyframes shaman-tide {
                0%,
                100% {
                    filter: contrast(1.05) brightness(1.03) saturate(1.1);
                }
                50% {
                    filter: contrast(1.1) brightness(1.06) saturate(1.18);
                }
            }
            @keyframes shaman-ripple {
                0% {
                    transform: scale(0.85);
                    opacity: 0.1;
                }
                55% {
                    opacity: 0.36;
                }
                100% {
                    transform: scale(1.35);
                    opacity: 0.08;
                }
            }

            /* 5. KEEPER */
            .anim-KEEPER {
                animation: keeper-runes 7s ease-in-out infinite;
            }
            .overlay-KEEPER {
                background: radial-gradient(circle at 50% 45%, rgba(251, 146, 60, 0.1), transparent 62%);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-KEEPER::before {
                content: '';
                position: absolute;
                inset: -18%;
                background:
                    radial-gradient(circle at 30% 40%, rgba(186, 85, 211, 0.12) 0%, transparent 42%),
                    radial-gradient(circle at 70% 60%, rgba(251, 146, 60, 0.14) 0%, transparent 45%),
                    radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 60%);
                opacity: 0.3;
                mix-blend-mode: screen;
                filter: blur(1.2px);
                animation: keeper-sigil 5.8s ease-in-out infinite;
            }
            .overlay-KEEPER::after {
                content: '';
                position: absolute;
                inset: -20%;
                background:
                    radial-gradient(70% 60% at 35% 40%, rgba(251, 146, 60, 0.14), transparent 72%),
                    radial-gradient(80% 70% at 70% 65%, rgba(255, 255, 255, 0.1), transparent 76%),
                    linear-gradient(115deg, transparent, rgba(255, 255, 255, 0.08), transparent);
                opacity: 0.16;
                mix-blend-mode: screen;
                animation: keeper-dust 6s ease-in-out infinite alternate;
            }
            @keyframes keeper-runes {
                0%,
                100% {
                    filter: sepia(0.05) contrast(1.06) brightness(1.02) saturate(1.06);
                }
                50% {
                    filter: sepia(0.02) contrast(1.1) brightness(1.05) saturate(1.1);
                }
            }
            @keyframes keeper-sigil {
                0%,
                100% {
                    transform: scale(0.98);
                    opacity: 0.22;
                }

                /* 6. WALKER */
                .anim-WALKER {
                    animation: walker-flow 7s ease-in-out infinite;
                }
                .overlay-WALKER {
                    background: linear-gradient(45deg, rgba(59, 130, 246, 0.14), transparent);
                    mix-blend-mode: overlay;
                    pointer-events: none;
                    z-index: 5;
                    position: absolute;
                    inset: 0;
                    border-radius: inherit;
                    overflow: hidden;
                }
                .overlay-WALKER::before {
                    content: '';
                    position: absolute;
                    inset: -18%;
                    background:
                        radial-gradient(80% 60% at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),
                        radial-gradient(80% 60% at 80% 70%, rgba(59, 130, 246, 0.18) 0%, transparent 62%),
                        radial-gradient(90% 70% at 50% 50%, rgba(255, 255, 255, 0.06) 0%, transparent 66%);
                    opacity: 0.38;
                    mix-blend-mode: screen;
                    filter: blur(1.4px);
                    animation: walker-orbit 7.5s ease-in-out infinite;
                }
                .overlay-WALKER::after {
                    content: '';
                    position: absolute;
                    inset: -22%;
                    background: linear-gradient(
                        140deg,
                        transparent 0%,
                        rgba(255, 255, 255, 0.05) 50%,
                        transparent 100%
                    );
                    background-size: 220% 220%;
                    opacity: 0.18;
                    mix-blend-mode: screen;
                    filter: blur(1px);
                    animation: walker-sweep 9s linear infinite;
                }
                @keyframes walker-flow {
                    0%,
                    100% {
                        filter: contrast(1.08) brightness(1.03) saturate(1.06);
                    }
                    50% {
                        filter: contrast(1.12) brightness(1.06) saturate(1.1);
                    }
                }
                @keyframes walker-orbit {
                    0%,
                    100% {
                        transform: translate3d(-1%, 1%, 0) scale(1);
                    }
                    50% {
                        transform: translate3d(1%, -1%, 0) scale(1.05);
                    }
                }
                @keyframes walker-sweep {
                    0% {
                        background-position: 0% 40%;
                    }
                    100% {
                        background-position: 200% 60%;
                    }
                }
            }
            .overlay-WALKER {
                background: linear-gradient(45deg, rgba(59, 130, 246, 0.14), transparent);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-WALKER::before {
                content: '';
                position: absolute;
                inset: -18%;
                background:
                    radial-gradient(80% 60% at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),
                    radial-gradient(80% 60% at 80% 70%, rgba(59, 130, 246, 0.18) 0%, transparent 62%),
                    radial-gradient(90% 70% at 50% 50%, rgba(255, 255, 255, 0.06) 0%, transparent 66%);
                opacity: 0.38;
                mix-blend-mode: screen;
                filter: blur(1.4px);
                animation: walker-orbit 7.5s ease-in-out infinite;
            }
            .overlay-WALKER::after {
                content: '';
                position: absolute;
                inset: -22%;
                background: linear-gradient(140deg, transparent 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
                background-size: 220% 220%;
                opacity: 0.18;
                mix-blend-mode: screen;
                filter: blur(1px);
                animation: walker-sweep 9s linear infinite;
            }
            @keyframes walker-flow {
                0%,
                100% {
                    filter: contrast(1.08) brightness(1.03) saturate(1.06);
                }
                50% {
                    filter: contrast(1.12) brightness(1.06) saturate(1.1);
                }
            }
            @keyframes walker-orbit {
                0%,
                100% {
                    transform: translate3d(-1%, 1%, 0) scale(1);
                }
                50% {
                    transform: translate3d(1%, -1%, 0) scale(1.05);
                }
            }
            @keyframes walker-sweep {
                0% {
                    background-position: 0% 40%;
                }
                100% {
                    background-position: 200% 60%;
                }
            }

            /* 7. LORD */
            .anim-LORD {
                animation: lord-crown 9s ease-in-out infinite;
            }
            .overlay-LORD {
                background: radial-gradient(circle at 50% 75%, rgba(234, 179, 8, 0.1), transparent 60%);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-LORD::before {
                content: '';
                position: absolute;
                inset: -18%;
                background: conic-gradient(
                    from 0deg at 50% 50%,
                    transparent 0deg,
                    rgba(255, 215, 0, 0.12) 50deg,
                    transparent 100deg,
                    rgba(255, 215, 0, 0.1) 150deg,
                    transparent 200deg,
                    rgba(255, 215, 0, 0.12) 250deg,
                    transparent 300deg,
                    rgba(255, 215, 0, 0.1) 340deg,
                    transparent 360deg
                );
                opacity: 0.22;
                mix-blend-mode: overlay;
                filter: blur(1.2px);
                animation: lord-rays 14s linear infinite;
            }
            .overlay-LORD::after {
                content: '';
                position: absolute;
                inset: -22%;
                background:
                    radial-gradient(80% 70% at 30% 40%, rgba(255, 255, 255, 0.08) 0%, transparent 60%),
                    radial-gradient(80% 70% at 70% 60%, rgba(255, 215, 0, 0.12) 0%, transparent 62%);
                opacity: 0.26;
                mix-blend-mode: screen;
                filter: blur(1.6px);
                animation: lord-breathe 6.2s ease-in-out infinite;
            }
            @keyframes lord-crown {
                0%,
                100% {
                    filter: contrast(1.08) brightness(1.03) saturate(1.06);
                }
                50% {
                    filter: contrast(1.12) brightness(1.06) saturate(1.1);
                }
            }
            @keyframes lord-rays {
                0% {
                    transform: rotate(0deg) scale(1.02);
                }
                100% {
                    transform: rotate(360deg) scale(1.02);
                }
            }
            @keyframes lord-breathe {
                0%,
                100% {
                    transform: scale(0.98);
                    opacity: 0.18;
                }
                50% {
                    transform: scale(1.05);
                    opacity: 0.3;
                }
            }

            /* 8. PRIME */
            .anim-PRIME {
                animation: prime-calm 7s ease-in-out infinite;
            }
            .overlay-PRIME {
                background: radial-gradient(circle at 50% 35%, rgba(255, 255, 255, 0.1), transparent 70%);
                mix-blend-mode: overlay;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-PRIME::before {
                content: '';
                position: absolute;
                inset: -22%;
                background:
                    radial-gradient(40% 40% at 20% 22%, rgba(255, 255, 255, 0.16), transparent 70%),
                    radial-gradient(42% 42% at 78% 32%, rgba(168, 85, 247, 0.14), transparent 72%),
                    radial-gradient(44% 44% at 60% 78%, rgba(59, 130, 246, 0.14), transparent 72%),
                    radial-gradient(46% 46% at 34% 68%, rgba(255, 215, 0, 0.12), transparent 74%),
                    radial-gradient(110% 80% at 50% 50%, rgba(255, 255, 255, 0.06) 0%, transparent 62%);
                opacity: 0.26;
                mix-blend-mode: screen;
                filter: blur(0.6px);
                animation: prime-stars 3.8s ease-in-out infinite;
            }
            .overlay-PRIME::after {
                content: '';
                position: absolute;
                inset: -25%;
                background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.06) 50%, transparent 100%);
                background-size: 240% 240%;
                opacity: 0.14;
                mix-blend-mode: screen;
                filter: blur(1.1px);
                animation: prime-sweep 10s linear infinite;
            }
            @keyframes prime-calm {
                0%,
                100% {
                    filter: brightness(1.06) contrast(1.05) saturate(1.05);
                }
                50% {
                    filter: brightness(1.1) contrast(1.08) saturate(1.08);
                }
            }
            @keyframes prime-stars {
                0%,
                100% {
                    opacity: 0.2;
                }
                50% {
                    opacity: 0.36;
                }
            }
            @keyframes prime-sweep {
                0% {
                    background-position: 0% 40%;
                }
                100% {
                    background-position: 200% 60%;
                }
            }

            /* 9. SINGULARITY */
            .anim-SINGULARITY {
                animation: singularity-deep 10s ease-in-out infinite;
            }
            .overlay-SINGULARITY {
                background: radial-gradient(circle at 50% 55%, rgba(168, 85, 247, 0.1), transparent 60%);
                mix-blend-mode: overlay;
                opacity: 0.24;
                animation: singularity-spin 18s linear infinite;
                pointer-events: none;
                z-index: 5;
                position: absolute;
                inset: 0;
                border-radius: inherit;
                overflow: hidden;
            }
            .overlay-SINGULARITY::before {
                content: '';
                position: absolute;
                inset: -28%;
                background: conic-gradient(
                    from 0deg at 50% 50%,
                    rgba(59, 130, 246, 0),
                    rgba(59, 130, 246, 0.1),
                    rgba(168, 85, 247, 0),
                    rgba(255, 107, 53, 0.08),
                    rgba(59, 130, 246, 0)
                );
                opacity: 0.22;
                mix-blend-mode: overlay;
                filter: blur(2px);
                animation: singularity-spin 18s linear infinite reverse;
            }
            .overlay-SINGULARITY::after {
                content: '';
                position: absolute;
                inset: -18%;
                background:
                    radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.08) 0%, transparent 55%),
                    radial-gradient(circle at 50% 50%, transparent 38%, rgba(255, 255, 255, 0.06) 45%, transparent 55%);
                opacity: 0.26;
                mix-blend-mode: screen;
                filter: blur(1.4px);
                animation: singularity-breath 4.8s ease-in-out infinite;
            }
            @keyframes singularity-deep {
                0%,
                100% {
                    filter: contrast(1.08) brightness(1.02) saturate(1.04);
                }
                50% {
                    filter: contrast(1.14) brightness(1.06) saturate(1.1);
                }
            }
            @keyframes singularity-spin {
                0% {
                    transform: rotate(0deg) scale(1.03);
                }
                100% {
                    transform: rotate(360deg) scale(1.03);
                }
            }
            @keyframes singularity-breath {
                0%,
                100% {
                    transform: scale(0.96);
                    opacity: 0.18;
                }
                50% {
                    transform: scale(1.06);
                    opacity: 0.3;
                }
            }

            /* === TIER TEXT EFFECTS === */
            .text-tier-0 {
                color: #e5e7eb;
            } /* Обычный */

            .text-tier-1 {
                color: #fff;
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
            }

            .text-tier-2 {
                background: linear-gradient(to right, #fff, #fb923c); /* Белый в Оранжевый */
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                filter: drop-shadow(0 0 5px rgba(255, 107, 53, 0.5));
            }

            .text-tier-3 {
                background: linear-gradient(to right, #fb923c, #a855f7, #3b82f6); /* Fennec -> Purple -> Blue */
                background-size: 200% 200%;
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                animation: shimmerText 3s linear infinite;
                filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.5));
            }

            .rank-badge {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 6px 12px;
                border-radius: 9999px;
                font-size: 10px;
                font-weight: 900;
                letter-spacing: 0.35em;
                text-transform: uppercase;
                color: rgba(255, 255, 255, 0.92);
                background: rgba(0, 0, 0, 0.24);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.12);
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.65);
            }
            .rank-badge-0 {
                opacity: 0.85;
            }
            .rank-badge-1 {
                box-shadow: 0 0 16px rgba(255, 255, 255, 0.18);
            }
            .rank-badge-2 {
                background: linear-gradient(90deg, rgba(255, 255, 255, 0.18), rgba(255, 107, 53, 0.18));
                border-color: rgba(255, 107, 53, 0.22);
                box-shadow: 0 0 22px rgba(255, 107, 53, 0.25);
            }
            .rank-badge-3 {
                background: linear-gradient(
                    90deg,
                    rgba(255, 107, 53, 0.25),
                    rgba(168, 85, 247, 0.25),
                    rgba(59, 130, 246, 0.25)
                );
                background-size: 200% 200%;
                animation: rankShimmer 3s linear infinite;
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow:
                    0 0 30px rgba(255, 255, 255, 0.22),
                    0 0 50px rgba(255, 107, 53, 0.18);
            }
            @keyframes rankShimmer {
                0% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
                100% {
                    background-position: 0% 50%;
                }
            }

            @keyframes shimmerText {
                0% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
                100% {
                    background-position: 0% 50%;
                }
            }

            /* === ПРАВИЛЬНАЯ ЛОГИКА 3D FLIP === */
            /* Когда card-object вращается на 180deg:
            - face-front: 180 + 0 = 180deg → скрыта (backface-visibility: hidden)
            - face-back: 180 + 180 = 360deg = 0deg → видна нормально
            Никаких scaleX(-1) не нужно! */

            /* === RARITY STYLES (Цвета рамок) === */

            /* 0-49: CUB (Grey) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-cub,
            .card-face.card-cub {
                border: 3px solid #52525b !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина, применяется к card-object и card-face */
                box-shadow:
                    0 0 25px rgba(82, 82, 91, 0.5),
                    inset 0 0 10px rgba(82, 82, 91, 0.2) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-cub {
                background: radial-gradient(circle at center, rgba(82, 82, 91, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-cub {
                color: #a1a1aa;
            }

            /* 0-49: CUB (Grey) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-cub,
            .card-face.card-cub {
                border: 3px solid #52525b !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина, применяется к card-object и card-face */
                box-shadow:
                    0 0 25px rgba(82, 82, 91, 0.5),
                    inset 0 0 10px rgba(82, 82, 91, 0.2) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-cub {
                background: radial-gradient(circle at center, rgba(82, 82, 91, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-cub {
                color: #a1a1aa;
            }

            /* 50-59: SCOUT (Green) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-scout,
            .card-face.card-scout {
                border: 3px solid #22c55e !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина */
                box-shadow:
                    0 0 30px rgba(34, 197, 94, 0.6),
                    inset 0 0 15px rgba(34, 197, 94, 0.3) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-scout {
                background: radial-gradient(circle at center, rgba(34, 197, 94, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-scout {
                color: #4ade80;
            }

            /* 60-69: HUNTER (Blue) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-hunter,
            .card-face.card-hunter {
                border: 3px solid #3b82f6 !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина */
                box-shadow:
                    0 0 35px rgba(59, 130, 246, 0.7),
                    inset 0 0 15px rgba(59, 130, 246, 0.4) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-hunter {
                background: radial-gradient(circle at center, rgba(59, 130, 246, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-hunter {
                color: #60a5fa;
            }

            /* 70-79: ALPHA (Red) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-alpha,
            .card-face.card-alpha {
                border: 3px solid #ef4444 !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина */
                box-shadow:
                    0 0 40px rgba(239, 68, 68, 0.8),
                    inset 0 0 20px rgba(239, 68, 68, 0.5) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-alpha {
                background: radial-gradient(circle at center, rgba(239, 68, 68, 0.15) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-alpha {
                color: #f87171;
            }

            /* 80-89: ELDER (Gold) - ИСПРАВЛЕНИЕ: Улучшена видимость рамки */
            .card-object.card-elder,
            .card-face.card-elder {
                border: 3px solid #eab308 !important; /* ИСПРАВЛЕНИЕ: Увеличена толщина */
                box-shadow:
                    0 0 45px rgba(234, 179, 8, 0.9),
                    inset 0 0 20px rgba(234, 179, 8, 0.6) !important; /* ИСПРАВЛЕНИЕ: Увеличена яркость */
                box-sizing: border-box; /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не выходит за границы */
            }
            .card-face.card-elder {
                background: radial-gradient(circle at center, rgba(234, 179, 8, 0.2) 0%, rgba(0, 0, 0, 0.8) 70%);
            }
            .text-elder {
                color: #facc15;
            }

            /* 90-100: SPIRIT (TRUE RAINBOW / HOLOGRAPHIC) - ВСЕ ЦВЕТА ОДНОВРЕМЕННО */
            .card-spirit {
                position: relative;
                border-radius: 24px;
                /* Скругленная радужная рамка через псевдоэлемент */
            }

            .card-spirit {
                overflow: visible;
                position: relative;
            }

            .card-spirit::before {
                content: '';
                position: absolute;
                inset: 0; /* ИСПРАВЛЕНИЕ: Увеличена толщина рамки для лучшей видимости */
                border-radius: 24px; /* ИСПРАВЛЕНИЕ: Скругленные края рамки */
                padding: 4px; /* ИСПРАВЛЕНИЕ: Увеличена толщина */
                background: conic-gradient(
                    from 0deg,
                    #ff0000,
                    #ff7f00,
                    #ffff00,
                    #00ff00,
                    #00ffff,
                    #0000ff,
                    #4b0082,
                    #9400d3,
                    #ff0000
                );
                -webkit-mask:
                    linear-gradient(#fff 0 0) content-box,
                    linear-gradient(#fff 0 0);
                -webkit-mask-composite: xor;
                mask:
                    linear-gradient(#fff 0 0) content-box,
                    linear-gradient(#fff 0 0);
                mask-composite: exclude;
                z-index: 60;
                pointer-events: none;
                filter: brightness(1.55) saturate(1.25) drop-shadow(0 0 16px rgba(255, 255, 255, 0.35));
                transform-origin: center center;
                animation: spiritBorderPulse 4.2s linear infinite;
                /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка видна */
                overflow: visible;
            }

            .badge-medal {
                transition:
                    transform 160ms ease,
                    filter 160ms ease;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.22);
                border: 1px solid rgba(255, 255, 255, 0.14);
                box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.35);
                border-radius: 10px;
                overflow: hidden;
                outline: none;
                transform: translateZ(0);
                will-change: transform, filter;
            }
            .badge-medal:hover {
                transform: translateY(-2px) scale(1.06);
                filter: drop-shadow(0 0 12px rgba(255, 107, 53, 0.35)) drop-shadow(0 0 22px rgba(255, 255, 255, 0.12));
            }

            .badge-medal img {
                width: 100%;
                height: 100%;
                display: block;
                object-fit: contain;
            }

            @keyframes spiritBorderPulse {
                0% {
                    filter: brightness(1.65) saturate(1.25) hue-rotate(0deg)
                        drop-shadow(0 0 16px rgba(255, 255, 255, 0.35));
                }
                50% {
                    filter: brightness(2.05) saturate(1.45) hue-rotate(180deg)
                        drop-shadow(0 0 20px rgba(255, 255, 255, 0.45));
                }
                100% {
                    filter: brightness(1.65) saturate(1.25) hue-rotate(360deg)
                        drop-shadow(0 0 16px rgba(255, 255, 255, 0.35));
                }
            }

            .card-spirit .card-face {
                position: absolute;
                inset: 0;
                overflow: hidden;
                border-radius: 24px; /* ИСПРАВЛЕНИЕ: Закругленные края у фона */
                box-shadow:
                    0 0 20px rgba(255, 0, 0, 0.5),
                    0 0 30px rgba(255, 127, 0, 0.4),
                    0 0 40px rgba(255, 255, 0, 0.3),
                    0 0 50px rgba(0, 255, 0, 0.3),
                    0 0 40px rgba(0, 255, 255, 0.3),
                    0 0 30px rgba(0, 0, 255, 0.4),
                    0 0 20px rgba(75, 0, 130, 0.5),
                    0 0 10px rgba(148, 0, 211, 0.6);
                /* ИСПРАВЛЕНИЕ: Убеждаемся что рамка не обрезается */
                margin: 0;
            }

            /* Радужный текст для слова "SPIRIT" */
            .text-spirit {
                background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff);
                background-size: 200% auto;
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                font-weight: 900;
                animation: rainbowTextMove 3s linear infinite;
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            }

            @keyframes rainbowTextMove {
                to {
                    background-position: 200% center;
                }
            }

            /* Совместимость со старыми классами */
            .card-common {
                border-color: #52525b;
                box-shadow: 0 0 15px rgba(82, 82, 91, 0.1);
            }
            .card-uncommon {
                border-color: #22c55e;
                box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
            }
            .card-rare {
                border-color: #3b82f6;
                box-shadow: 0 0 25px rgba(59, 130, 246, 0.3);
            }
            .card-epic {
                border-color: #ef4444;
                box-shadow: 0 0 30px rgba(239, 68, 68, 0.4);
            }
            .card-legendary {
                border-color: #eab308;
                box-shadow: 0 0 35px rgba(234, 179, 8, 0.5);
            }
            .card-mythic {
                animation: rainbowGlow 4s linear infinite alternate;
                background: #000;
            }

            /* 3D эффект для карточки */
            .fennec-card-wrapper {
                perspective: 1000px;
                perspective-origin: center center;
            }

            #fennecCard {
                transform-style: preserve-3d;
                transition: transform 0.3s ease;
                will-change: transform;
            }

            #fennecCard:hover {
                transform: rotateY(8deg) rotateX(-3deg) scale(1.03) translateZ(20px);
            }

            @media (prefers-reduced-motion: no-preference) {
                #fennecCard {
                    animation: cardFloat 6s ease-in-out infinite;
                }
            }

            @keyframes cardFloat {
                0%,
                100% {
                    transform: translateY(0px) rotateY(0deg) rotateX(0deg);
                }
                50% {
                    transform: translateY(-8px) rotateY(2deg) rotateX(1deg);
                }
            }

            @keyframes mythicPulse {
                0% {
                    box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
                    border-color: #ef4444;
                }
                50% {
                    box-shadow:
                        0 0 60px rgba(239, 68, 68, 0.8),
                        0 0 10px rgba(255, 255, 255, 0.5);
                    border-color: #ff8888;
                }
                100% {
                    box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
                    border-color: #ef4444;
                }
            }

            .holo-overlay {
                background: linear-gradient(
                    125deg,
                    transparent 30%,
                    rgba(255, 255, 255, 0.1) 40%,
                    rgba(255, 255, 255, 0.1) 60%,
                    transparent 70%
                );
                background-size: 200% 200%;
                animation: holoShift 5s linear infinite;
            }
            @keyframes holoShift {
                0% {
                    background-position: 0% 50%;
                }
                100% {
                    background-position: 100% 50%;
                }
            }

            @keyframes cardHoloSheen {
                0% {
                    background-position: -80% 50%;
                }
                100% {
                    background-position: 180% 50%;
                }
            }

            .card-holo-sheen {
                position: absolute;
                inset: 0;
                pointer-events: none;
                z-index: 26;
                display: none;
                opacity: 0.35;
                mix-blend-mode: overlay;
                border-radius: 24px;
                clip-path: inset(0 round 24px);
                background-image:
                    linear-gradient(
                        115deg,
                        rgba(255, 255, 255, 0) 10%,
                        rgba(255, 255, 255, 0.22) 35%,
                        rgba(255, 255, 255, 0) 60%
                    ),
                    linear-gradient(90deg, rgba(255, 107, 53, 0.1), rgba(168, 85, 247, 0.1), rgba(59, 130, 246, 0.1));
                background-size:
                    240% 140%,
                    200% 100%;
                background-position:
                    -80% 50%,
                    0% 50%;
                animation: cardHoloSheen 4.5s linear infinite;
            }

            /* ===== FENNEC SPIRIT EFFECT ===== */
            @keyframes spiritGlow {
                0% {
                    box-shadow:
                        0 0 10px #ff6b35,
                        inset 0 0 10px #ff6b35;
                    border-color: #ff6b35;
                }
                50% {
                    box-shadow:
                        0 0 25px #ff6b35,
                        0 0 10px #ff9e75,
                        inset 0 0 20px #ff6b35;
                    border-color: #ff9e75;
                }
                100% {
                    box-shadow:
                        0 0 10px #ff6b35,
                        inset 0 0 10px #ff6b35;
                    border-color: #ff6b35;
                }
            }

            /* === FENNEC SOUL PULSE (Универсальный эффект) === */

            @keyframes soulBreath {
                0% {
                    /* Обычная тень - УМЕРЕННО */
                    box-shadow:
                        0 0 15px rgba(255, 107, 53, 0.4),
                        0 0 25px rgba(255, 107, 53, 0.3);
                }
                50% {
                    /* Яркая оранжевая аура - УМЕРЕННО */
                    box-shadow:
                        0 0 30px rgba(255, 107, 53, 0.7),
                        0 0 50px rgba(255, 107, 53, 0.5),
                        0 0 70px rgba(255, 107, 53, 0.3);
                }
                100% {
                    box-shadow:
                        0 0 15px rgba(255, 107, 53, 0.4),
                        0 0 25px rgba(255, 107, 53, 0.3);
                }
            }

            /* Класс, который мы добавим карточке холдера */
            .fennec-pulse {
                animation: soulBreath 2s infinite ease-in-out !important;
                position: relative;
                z-index: 10; /* Чтобы свечение было видно */
            }

            /* Чтобы рамка редкости оставалась видна, мы не трогаем border-color в анимации */

            /* Значок SOUL */
            .soul-badge {
                background: linear-gradient(90deg, #ff6b35, #ff4e00);
                color: white;
                font-weight: 800;
                box-shadow: 0 0 10px rgba(255, 107, 53, 0.4);
                border: 1px solid rgba(255, 255, 255, 0.2);
                padding: 4px 8px;
                border-radius: 6px;
                font-size: 8px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .digging-fox {
                animation: digShake 0.2s infinite;
                display: inline-block;
            }
            .dirt-particle {
                position: fixed;
                width: 6px;
                height: 6px;
                background: #d97706;
                border-radius: 50%;
                pointer-events: none;
                z-index: 9998;
            }

            /* ===== WHALE WATCHER ===== */
            .whale-alert {
                transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            }
            .notification.exit {
                animation: slideOut 0.3s ease-out forwards;
            }
            @keyframes slideOut {
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }

            /* ===== FENNEC CHAT STYLES ===== */
            /* Scrollbar for Chat */
            #chatMessages::-webkit-scrollbar {
                width: 4px;
            }
            #chatMessages::-webkit-scrollbar-track {
                background: transparent;
            }
            #chatMessages::-webkit-scrollbar-thumb {
                background: #333;
                border-radius: 2px;
            }

            /* Markdown-like styling for AI response */
            .oracle-md a {
                color: #ff6b35;
                text-decoration: underline;
            }
            .oracle-md strong {
                color: #fff;
                font-weight: 700;
            }
            .oracle-md ul {
                list-style-type: disc;
                padding-left: 15px;
                margin-top: 5px;
            }

            @keyframes pulse-glow {
                0%,
                100% {
                    filter: drop-shadow(0 0 5px #ff6b35);
                }
                50% {
                    filter: drop-shadow(0 0 15px #ff6b35) brightness(1.2);
                }
            }

            .ai-avatar {
                animation: pulse-glow 3s infinite ease-in-out;
            }

            /* Animation for messages */
            @keyframes msgSlide {
                from {
                    opacity: 0;
                    transform: translateY(10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            .msg-anim {
                animation: msgSlide 0.3s ease-out forwards;
            }

            /* AI HIGHLIGHT EFFECT */
            @keyframes pulse-guide {
                0% {
                    box-shadow: 0 0 0 0 rgba(255, 107, 53, 0.7);
                    border-color: #ff6b35;
                }
                70% {
                    box-shadow: 0 0 0 15px rgba(255, 107, 53, 0);
                    border-color: #ff6b35;
                }
                100% {
                    box-shadow: 0 0 0 0 rgba(255, 107, 53, 0);
                    border-color: rgba(255, 255, 255, 0.1);
                }
            }
            .ai-highlight {
                animation: pulse-guide 1.5s infinite;
                z-index: 100;
                position: relative;
            }

            @keyframes swap-success-pulse {
                0% {
                    transform: translateZ(0) scale(1);
                    box-shadow: 0 0 0 rgba(255, 107, 53, 0);
                }
                35% {
                    transform: translateZ(0) scale(1.01);
                    box-shadow: 0 0 38px rgba(255, 107, 53, 0.38);
                }
                100% {
                    transform: translateZ(0) scale(1);
                    box-shadow: 0 0 0 rgba(255, 107, 53, 0);
                }
            }
            .swap-success-pulse {
                animation: swap-success-pulse 700ms ease-out;
            }

            @keyframes swap-success-overlay {
                0% {
                    opacity: 0;
                    transform: scale(0.98);
                }
                22% {
                    opacity: 1;
                    transform: scale(1);
                }
                78% {
                    opacity: 1;
                    transform: scale(1);
                }
                100% {
                    opacity: 0;
                    transform: scale(1.01);
                }
            }
            .swap-success-overlay {
                animation: swap-success-overlay 950ms ease-out forwards;
            }
        </style>
        <style>
            .card-glare {
                display: none !important;
                opacity: 0 !important;
            }
        </style>
    </head>
    <body>
        <div id="animatedBackground" class="fixed top-0 left-0 w-full h-full -z-10 pointer-events-none">
            <canvas id="animatedBackgroundCanvas" class="w-full h-full"></canvas>
        </div>
        <!-- Notifications Container -->
        <div id="notificationsContainer" style="position: fixed; top: 80px; right: 20px; z-index: 10000"></div>

        <!-- HEADER -->
        <header class="fixed w-full z-50 border-b border-white/5 bg-[#2c1a12]/90 backdrop-blur-md">
            <div class="max-w-6xl mx-auto px-4 h-16 grid grid-cols-[1fr_auto_1fr] items-center">
                <div class="flex items-center gap-3 cursor-pointer group" onclick="window.showSection('home')">
                    <img
                        src="img/phav.png"
                        class="neon-logo w-9 h-9 rounded-full border border-fennec/50 group-hover:scale-110 transition shadow-lg shadow-fennec/20 object-contain"
                    />
                    <div>
                        <h1
                            class="font-display font-bold text-xl leading-none tracking-tight text-fennec"
                            style="text-shadow: 0 0 18px rgba(255, 107, 53, 0.35)"
                        >
                            FENNEC
                        </h1>
                    </div>
                </div>

                <nav
                    class="hidden md:flex gap-8 text-xs font-bold text-gray-400 uppercase tracking-widest justify-self-center"
                >
                    <button
                        onclick="window.showSection('home')"
                        class="nav-link hover:text-white transition py-5 active"
                        id="nav-home"
                        data-t="nav_home"
                    >
                        VISION
                    </button>
                    <button
                        onclick="window.showSection('terminal')"
                        class="nav-link hover:text-white transition py-5"
                        id="nav-terminal"
                        data-t="nav_terminal"
                    >
                        TERMINAL
                    </button>
                    <button
                        onclick="window.showSection('audit')"
                        class="nav-link hover:text-white transition py-5"
                        id="nav-audit"
                        data-t="nav_audit"
                    >
                        FENNEC ID
                    </button>
                </nav>

                <div class="flex items-center gap-3 justify-self-end">
                    <a
                        href="https://x.com/FennecBTC"
                        target="_blank"
                        class="text-gray-400 hover:text-white transition flex items-center justify-center text-2xl w-10 h-10"
                        aria-label="Twitter"
                    >
                        <i class="fab fa-twitter"></i>
                    </a>
                    <a
                        href="https://t.me/FennecBTC"
                        target="_blank"
                        class="text-gray-400 hover:text-white transition flex items-center justify-center text-2xl w-10 h-10"
                        aria-label="Telegram"
                    >
                        <i class="fab fa-telegram"></i>
                    </a>
                    <button
                        onclick="window.connectWallet()"
                        id="connectBtn"
                        class="bg-gradient-to-r from-fennec to-orange-600 text-black px-4 py-2 rounded-lg font-bold hover:brightness-110 transition text-xs shadow-[0_0_20px_rgba(255,107,53,0.4)] flex items-center gap-2"
                        data-t="connect"
                    >
                        <i class="fas fa-wallet"></i> <span>CONNECT</span>
                    </button>
                    <button
                        onclick="disconnectWallet()"
                        id="disconnectBtn"
                        class="hidden bg-red-600/20 text-red-400 px-4 py-2 rounded-lg font-bold hover:bg-red-600/30 transition text-xs border border-red-500/50 flex items-center gap-2"
                        data-t="disconnect"
                    >
                        <i class="fas fa-sign-out-alt"></i> <span>DISCONNECT</span>
                    </button>
                </div>
            </div>
        </header>

        <!-- LIVE TICKER -->
        <div
            class="fixed bottom-0 left-0 right-0 w-full bg-[#0d0604] border-t border-white/10 z-[100] py-2 overflow-hidden pointer-events-none"
        >
            <div class="ticker-container" style="overflow: hidden; position: relative; width: 100%">
                <div
                    class="ticker-content"
                    id="liveTicker"
                    style="
                        display: inline-block;
                        white-space: nowrap;
                        animation: marquee 30s linear infinite;
                        padding-left: 100%;
                    "
                >
                    <span class="text-fennec inline-flex items-center gap-2"
                        ><img src="img/phav.png" class="w-5 h-5 inline-block object-contain" /> FENNEC SYSTEM
                        ONLINE</span
                    >
                </div>
            </div>
        </div>

        <!-- === SECTION 1: HOME (MISSION) === -->
        <section id="sec-home" class="page-section active flex flex-col justify-start pt-32 pb-24 relative z-10">
            <div class="hero-fox-bg"></div>
            <div class="max-w-5xl mx-auto px-6 relative">
                <!-- Hero -->
                <div class="text-center mb-24">
                    <div
                        class="inline-flex items-center gap-2 mb-6 px-4 py-1.5 rounded-full border border-fennec/30 bg-fennec/5 text-fennec text-[10px] uppercase tracking-widest font-bold"
                    >
                        <span class="w-2 h-2 rounded-full bg-fennec animate-pulse"></span>
                        <span>Fractal Bitcoin</span>
                    </div>
                    <h1 class="text-5xl md:text-7xl font-black font-display mb-6 leading-tight">
                        <span class="text-fennec" style="text-shadow: 0 0 24px rgba(255, 107, 53, 0.35)">FENNEC</span
                        ><br /><span
                            class="text-transparent bg-clip-text bg-gradient-to-r from-fennec via-orange-400 to-yellow-200"
                            >FRONTIER</span
                        >
                    </h1>
                    <p
                        class="text-gray-300 text-lg max-w-2xl mx-auto mb-10 leading-relaxed font-light"
                        data-t="hero_desc"
                    >
                        The tactical layer for Fractal Bitcoin. Execute swaps with precision, visualize your on-chain
                        legacy, and navigate the ecosystem with AI.
                    </p>

                    <div class="flex flex-col md:flex-row justify-center gap-4">
                        <button
                            onclick="window.showSection('terminal')"
                            class="bg-fennec text-black px-8 py-4 rounded-xl font-bold text-lg hover:scale-105 transition shadow-[0_0_30px_rgba(255,107,53,0.5)] flex items-center justify-center gap-2"
                            data-t="enter_app"
                        >
                            <span>ENTER TERMINAL</span> <i class="fas fa-terminal"></i>
                        </button>
                        <button
                            onclick="window.onVisionFennecIdClick()"
                            id="visionFennecIdBtn"
                            class="border border-fennec/30 bg-fennec/5 text-white px-8 py-4 rounded-xl font-bold text-lg hover:bg-fennec/10 transition flex items-center justify-center gap-2"
                        >
                            <span id="visionFennecIdBtnText">FENNEC ID</span> <i class="fas fa-id-card"></i>
                        </button>
                    </div>
                </div>

                <!-- Features Grid -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-12">
                    <div
                        class="glass-panel p-6 rounded-2xl hover:border-fennec/50 transition duration-300 group text-center"
                    >
                        <div
                            class="w-12 h-12 rounded-full bg-fennec/10 flex items-center justify-center text-fennec text-2xl mb-4 group-hover:scale-110 transition mx-auto"
                        >
                            <i class="fas fa-laptop-code"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2" data-t="feat_ui_title">Tactical Terminal</h3>
                        <p class="text-gray-400 text-sm leading-relaxed" data-t="feat_ui_desc">
                            An optimized aggregation interface. We cut through the noise to give you the most efficient
                            execution on the network.
                        </p>
                    </div>
                    <div
                        class="glass-panel p-6 rounded-2xl hover:border-fennec/50 transition duration-300 group text-center"
                    >
                        <div
                            class="w-12 h-12 rounded-full bg-fennec/10 flex items-center justify-center text-fennec text-2xl mb-4 group-hover:scale-110 transition mx-auto"
                        >
                            <i class="fas fa-robot"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2" data-t="feat_ai_title">AI Navigator</h3>
                        <p class="text-gray-400 text-sm leading-relaxed" data-t="feat_ai_desc">
                            Your co-pilot in the dunes. Analyze chain data and get real-time guidance without leaving
                            the terminal.
                        </p>
                    </div>
                    <div
                        class="glass-panel p-6 rounded-2xl hover:border-fennec/50 transition duration-300 group text-center"
                    >
                        <div
                            class="w-12 h-12 rounded-full bg-fennec/10 flex items-center justify-center text-fennec text-2xl mb-4 group-hover:scale-110 transition mx-auto"
                        >
                            <i class="fas fa-paw"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2" data-t="feat_comm_title">Access &amp; Status</h3>
                        <p class="text-gray-400 text-sm leading-relaxed" data-t="feat_comm_desc">
                            $FENNEC is the key to the ecosystem. Hold to unlock premium ID features, visual upgrades,
                            and future protocol tiers.
                        </p>
                    </div>
                    <div
                        class="glass-panel p-6 rounded-2xl hover:border-fennec/50 transition duration-300 group text-center"
                    >
                        <div
                            class="w-12 h-12 rounded-full bg-fennec/10 flex items-center justify-center text-fennec text-2xl mb-4 group-hover:scale-110 transition mx-auto"
                        >
                            <i class="fas fa-id-card"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2">Identity Protocol</h3>
                        <p class="text-gray-400 text-sm leading-relaxed">
                            A proprietary standard for on-chain reputation. Dynamic, evolving 3D cards that immortalize
                            your journey forever.
                        </p>
                    </div>
                </div>

                <!-- Evolution Story (Island Journey) -->
                <div class="mb-12 relative overflow-hidden text-center">
                    <h3 class="text-xl font-bold text-white mb-4 flex items-center gap-2 justify-center">
                        <i class="fas fa-map-marked-alt text-fennec"></i>
                        <span data-t="evo_title">Fennec Evolution</span>
                    </h3>
                    <p class="text-gray-300 text-sm leading-relaxed mb-6 max-w-2xl mx-auto" data-t="evo_text1">
                        Journey across the islands of evolution. Each island marks a milestone in our voyage through the
                        Fractal seas.
                    </p>

                    <!-- Ocean & Journey Path -->
                    <div
                        class="hidden md:block relative h-32 mb-8"
                        style="
                            background: linear-gradient(
                                180deg,
                                transparent 0%,
                                rgba(59, 130, 246, 0.03) 40%,
                                rgba(59, 130, 246, 0.08) 100%
                            );
                            border-radius: 24px;
                            overflow: hidden;
                        "
                    >
                        <!-- Waves -->
                        <div
                            class="absolute inset-0 opacity-20"
                            style="
                                background: repeating-linear-gradient(
                                    90deg,
                                    transparent 0px,
                                    rgba(255, 255, 255, 0.05) 40px,
                                    transparent 80px
                                );
                                animation: wave 8s linear infinite;
                            "
                        ></div>
                        <div
                            class="absolute inset-0 opacity-10"
                            style="
                                background: repeating-linear-gradient(
                                    90deg,
                                    transparent 0px,
                                    rgba(255, 255, 255, 0.03) 60px,
                                    transparent 120px
                                );
                                animation: wave 12s linear infinite reverse;
                            "
                        ></div>

                        <svg viewBox="0 0 1200 160" preserveAspectRatio="none" class="absolute inset-0 w-full h-full">
                            <defs>
                                <linearGradient id="seaPath" x1="0" y1="0" x2="1" y2="0">
                                    <stop offset="0%" stop-color="rgba(34,197,94,0.4)" />
                                    <stop offset="33%" stop-color="rgba(255,107,53,0.6)" />
                                    <stop offset="66%" stop-color="rgba(168,85,247,0.5)" />
                                    <stop offset="100%" stop-color="rgba(59,130,246,0.4)" />
                                </linearGradient>
                                <filter id="islandGlow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur stdDeviation="8" result="blur" />
                                    <feMerge>
                                        <feMergeNode in="blur" />
                                        <feMergeNode in="SourceGraphic" />
                                    </feMerge>
                                </filter>
                            </defs>

                            <!-- Journey path (dotted line connecting islands) -->
                            <path
                                d="M 100 90 Q 250 60, 400 85 T 700 75 T 1000 90"
                                fill="none"
                                stroke="url(#seaPath)"
                                stroke-width="3"
                                stroke-dasharray="8,12"
                                opacity="0.6"
                                style="animation: pathGlow 3s ease-in-out infinite"
                            />

                            <!-- Islands (larger circles with glow) -->
                            <g style="animation: float 3s ease-in-out infinite">
                                <circle cx="100" cy="90" r="24" fill="rgba(34,197,94,0.2)" filter="url(#islandGlow)" />
                                <circle
                                    cx="100"
                                    cy="90"
                                    r="18"
                                    fill="rgba(34,197,94,0.6)"
                                    stroke="rgba(34,197,94,1)"
                                    stroke-width="3"
                                />
                                <text
                                    x="100"
                                    y="96"
                                    text-anchor="middle"
                                    fill="white"
                                    font-size="14"
                                    font-weight="bold"
                                >
                                    1
                                </text>
                            </g>

                            <g style="animation: float 3s ease-in-out infinite 0.3s">
                                <circle
                                    cx="400"
                                    cy="85"
                                    r="28"
                                    fill="rgba(255,107,53,0.25)"
                                    filter="url(#islandGlow)"
                                />
                                <circle
                                    cx="400"
                                    cy="85"
                                    r="22"
                                    fill="rgba(255,107,53,0.7)"
                                    stroke="rgba(255,107,53,1)"
                                    stroke-width="3"
                                />
                                <text
                                    x="400"
                                    y="92"
                                    text-anchor="middle"
                                    fill="white"
                                    font-size="16"
                                    font-weight="bold"
                                >
                                    2
                                </text>
                            </g>

                            <g style="animation: float 3s ease-in-out infinite 0.6s">
                                <circle cx="700" cy="75" r="22" fill="rgba(168,85,247,0.2)" filter="url(#islandGlow)" />
                                <circle
                                    cx="700"
                                    cy="75"
                                    r="16"
                                    fill="rgba(168,85,247,0.65)"
                                    stroke="rgba(168,85,247,1)"
                                    stroke-width="2.5"
                                />
                                <text
                                    x="700"
                                    y="81"
                                    text-anchor="middle"
                                    fill="white"
                                    font-size="13"
                                    font-weight="bold"
                                >
                                    3
                                </text>
                            </g>

                            <g style="animation: float 3s ease-in-out infinite 0.9s">
                                <circle
                                    cx="1000"
                                    cy="90"
                                    r="20"
                                    fill="rgba(59,130,246,0.2)"
                                    filter="url(#islandGlow)"
                                />
                                <circle
                                    cx="1000"
                                    cy="90"
                                    r="14"
                                    fill="rgba(59,130,246,0.5)"
                                    stroke="rgba(59,130,246,0.9)"
                                    stroke-width="2"
                                />
                                <text
                                    x="1000"
                                    y="96"
                                    text-anchor="middle"
                                    fill="white"
                                    font-size="12"
                                    font-weight="bold"
                                >
                                    4
                                </text>
                            </g>
                        </svg>
                    </div>

                    <!-- Island Cards -->
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 relative">
                        <!-- Island 1: Genesis -->
                        <div class="relative group" style="animation: islandBob 4s ease-in-out infinite">
                            <div
                                class="relative glass-panel p-5 rounded-2xl border-green-500/40 hover:border-green-400/60 transition-all text-center"
                                style="border-width: 2px"
                            >
                                <div
                                    class="w-16 h-16 mx-auto mb-3 rounded-full bg-gradient-to-br from-green-400/20 to-green-600/20 flex items-center justify-center border-2 border-green-400/50"
                                    style="box-shadow: 0 0 20px rgba(34, 197, 94, 0.3)"
                                >
                                    <img
                                        src="img/phase1.png"
                                        class="w-10 h-10 object-contain"
                                        onerror="
                                            this.src =
                                                'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2740%27 height=%2740%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%2322c55e%27 stroke-width=%272%27%3E%3Ccircle cx=%2712%27 cy=%2712%27 r=%2710%27/%3E%3Cpath d=%27M12 6v6l4 2%27/%3E%3C/svg%3E'
                                        "
                                    />
                                </div>
                                <div class="text-sm font-black text-green-400 mb-1 tracking-wider">🏝️ GENESIS ISLE</div>
                                <div class="text-[11px] text-gray-300 leading-relaxed">
                                    Fair Launch<br />Community Foundation
                                </div>
                            </div>
                        </div>

                        <!-- Island 2: Current -->
                        <div class="relative group" style="animation: islandBob 4s ease-in-out infinite 0.3s">
                            <div
                                class="relative glass-panel p-5 rounded-2xl border-fennec/60 bg-fennec/8 hover:border-fennec/80 transition-all text-center"
                                style="border-width: 2px; box-shadow: 0 0 30px rgba(255, 107, 53, 0.2)"
                            >
                                <div
                                    class="w-16 h-16 mx-auto mb-3 rounded-full bg-gradient-to-br from-fennec/30 to-orange-600/30 flex items-center justify-center border-2 border-fennec/70"
                                    style="box-shadow: 0 0 24px rgba(255, 107, 53, 0.5)"
                                >
                                    <img
                                        src="img/phase2.png"
                                        class="w-10 h-10 object-contain"
                                        onerror="
                                            this.src =
                                                'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2740%27 height=%2740%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23ff6b35%27 stroke-width=%272%27%3E%3Crect x=%273%27 y=%273%27 width=%2718%27 height=%2718%27 rx=%272%27/%3E%3Cpath d=%27M9 9h6M9 15h6%27/%3E%3C/svg%3E'
                                        "
                                    />
                                </div>
                                <div class="text-sm font-black text-fennec mb-1 tracking-wider">🔥 FENNEC HARBOR</div>
                                <div class="text-[11px] text-gray-200 leading-relaxed font-semibold">
                                    Terminal Trading<br />Fennec ID System
                                </div>
                                <div
                                    class="mt-2 inline-block px-2 py-0.5 bg-fennec/20 border border-fennec/40 rounded text-[9px] font-bold text-fennec"
                                >
                                    CURRENT
                                </div>
                            </div>
                        </div>

                        <!-- Island 3: Upcoming -->
                        <div class="relative group" style="animation: islandBob 4s ease-in-out infinite 0.6s">
                            <div
                                class="relative glass-panel p-5 rounded-2xl border-purple-500/40 hover:border-purple-400/60 transition-all text-center"
                                style="border-width: 2px"
                            >
                                <div
                                    class="w-16 h-16 mx-auto mb-3 rounded-full bg-gradient-to-br from-purple-500/20 to-purple-700/20 flex items-center justify-center border-2 border-purple-400/50"
                                    style="box-shadow: 0 0 20px rgba(168, 85, 247, 0.3)"
                                >
                                    <img
                                        src="img/phase3.png"
                                        class="w-10 h-10 object-contain"
                                        onerror="
                                            this.src =
                                                'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2740%27 height=%2740%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23a855f7%27 stroke-width=%272%27%3E%3Cpath d=%27M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5%27/%3E%3C/svg%3E'
                                        "
                                    />
                                </div>
                                <div class="text-sm font-black text-purple-400 mb-1 tracking-wider">
                                    🌉 BRIDGE ATOLL
                                </div>
                                <div class="text-[11px] text-gray-300 leading-relaxed">
                                    Cross-chain Bridges<br />ID Evolution V2
                                </div>
                            </div>
                        </div>

                        <!-- Island 4: Future -->
                        <div
                            class="relative group opacity-75"
                            style="animation: islandBob 4s ease-in-out infinite 0.9s"
                        >
                            <div
                                class="relative glass-panel p-5 rounded-2xl border-blue-500/30 hover:border-blue-400/50 transition-all text-center"
                                style="border-width: 2px"
                            >
                                <div
                                    class="w-16 h-16 mx-auto mb-3 rounded-full bg-gradient-to-br from-blue-500/15 to-blue-700/15 flex items-center justify-center border-2 border-blue-400/40"
                                    style="box-shadow: 0 0 16px rgba(59, 130, 246, 0.25)"
                                >
                                    <img
                                        src="img/phase4.png"
                                        class="w-10 h-10 object-contain"
                                        onerror="
                                            this.src =
                                                'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2740%27 height=%2740%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%233b82f6%27 stroke-width=%272%27%3E%3Ccircle cx=%2712%27 cy=%2712%27 r=%273%27/%3E%3Cpath d=%27M12 1v6m0 6v6M1 12h6m6 0h6%27/%3E%3C/svg%3E'
                                        "
                                    />
                                </div>
                                <div class="text-sm font-black text-blue-400 mb-1 tracking-wider">🌊 LEGEND SHORES</div>
                                <div class="text-[11px] text-gray-400 leading-relaxed">
                                    Uncharted Waters<br />New Legends Born
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- === SECTION 2: TERMINAL (SWAP) === -->
        <section
            id="sec-terminal"
            class="page-section flex flex-col justify-start pt-32 pb-20 px-4 max-w-4xl mx-auto relative z-10"
        >
            <!-- CHART -->
            <div class="glass-panel p-6 rounded-2xl mb-6">
                <div class="flex justify-between items-end mb-4">
                    <div>
                        <div class="text-[10px] text-gray-500 uppercase tracking-widest font-bold">
                            Market Price (FB)
                        </div>
                        <div class="text-3xl font-bold font-mono text-white tracking-tighter" id="chartPrice">--</div>
                    </div>
                    <div class="flex gap-2">
                        <button
                            onclick="setChartTimeframe('1h')"
                            class="text-xs px-2 py-1 rounded bg-white/5 hover:bg-fennec/20 transition"
                        >
                            1H
                        </button>
                        <button
                            onclick="setChartTimeframe('24h')"
                            class="text-xs px-2 py-1 rounded bg-white/5 hover:bg-fennec/20 transition"
                        >
                            24H
                        </button>
                        <button
                            onclick="setChartTimeframe('7d')"
                            class="text-xs px-2 py-1 rounded bg-white/5 hover:bg-fennec/20 transition"
                        >
                            7D
                        </button>
                        <button
                            onclick="setChartTimeframe('30d')"
                            class="text-xs px-2 py-1 rounded bg-white/5 hover:bg-fennec/20 transition"
                        >
                            30D
                        </button>
                        <button
                            onclick="setChartTimeframe('all')"
                            class="text-xs px-2 py-1 rounded bg-white/5 hover:bg-fennec/20 transition"
                        >
                            ALL
                        </button>
                    </div>
                </div>
                <div class="chart-container" style="height: 250px; width: 100%; position: relative">
                    <canvas id="priceChart"></canvas>
                </div>
                <div class="text-xs" id="chartPriceChange">--</div>
            </div>

            <!-- MAIN INTERFACE -->
            <div class="glass-panel p-6 rounded-2xl relative shadow-[0_0_50px_rgba(0,0,0,0.3)] border border-fennec/20">
                <div
                    id="swapSuccessOverlay"
                    class="absolute inset-0 z-40 items-center justify-center"
                    style="display: none"
                >
                    <div
                        class="px-6 py-4 rounded-2xl bg-black/70 border border-fennec/30 backdrop-blur-md flex items-center gap-3"
                    >
                        <div
                            class="w-10 h-10 rounded-full bg-fennec/15 border border-fennec/40 flex items-center justify-center text-fennec text-xl"
                        >
                            <i class="fas fa-check"></i>
                        </div>
                        <div>
                            <div class="text-xs tracking-[0.25em] text-gray-300 uppercase font-bold">
                                Swap confirmed
                            </div>
                            <div class="text-[11px] text-gray-400">Balances are updating…</div>
                        </div>
                    </div>
                </div>
                <!-- TABS -->
                <div class="flex border-b border-white/10 mb-6">
                    <button class="tab-btn active w-1/4" onclick="switchTab('swap')" id="tab-swap" data-t="swap">
                        SWAP
                    </button>
                    <button class="tab-btn w-1/4" onclick="switchTab('deposit')" id="tab-deposit" data-t="deposit">
                        DEPOSIT
                    </button>
                    <button class="tab-btn w-1/4" onclick="switchTab('withdraw')" id="tab-withdraw" data-t="withdraw">
                        WITHDRAW
                    </button>
                    <button class="tab-btn w-1/4" onclick="switchTab('pending')" id="tab-pending" data-t="activity">
                        PENDING
                    </button>
                </div>

                <!-- SWAP TAB -->
                <div id="view-swap" class="tab-content active">
                    <div class="flex gap-2 mb-4">
                        <button
                            onclick="setSwapPair('FB_FENNEC')"
                            id="pair-fb-fennec"
                            class="flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg transition"
                        >
                            FB ↔ FENNEC
                        </button>
                        <button
                            onclick="setSwapPair('BTC_FB')"
                            id="pair-btc-fb"
                            class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition"
                        >
                            BTC ↔ FB
                        </button>
                    </div>

                    <div
                        class="bg-black/40 rounded-xl p-4 mb-2 border border-white/5 focus-within:border-fennec/50 transition"
                    >
                        <div class="flex justify-between text-xs mb-2 text-gray-400">
                            <span data-t="you_pay" class="font-bold">YOU PAY</span>
                            <div class="flex gap-2 items-center">
                                <span id="balIn" class="font-mono text-[10px] text-gray-500">Bal: --</span>
                                <button
                                    onclick="refreshBalancesInline()"
                                    class="text-[10px] text-fennec hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                    title="Refresh balances"
                                    type="button"
                                >
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button
                                    onclick="setMaxAmount()"
                                    class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                >
                                    MAX
                                </button>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <input
                                type="number"
                                id="swapIn"
                                placeholder="0.0"
                                class="bg-transparent text-3xl font-bold w-full outline-none text-white placeholder-gray-700"
                                oninput="debounceQuote()"
                            />
                            <div class="flex items-center gap-2 px-3 py-1.5 cursor-pointer min-w-[80px] justify-center">
                                <img id="iconIn" src="img/FB.png" class="w-6 h-6 rounded-full flex-shrink-0" />
                                <span id="tickerIn" class="font-bold text-sm whitespace-nowrap">FB</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-center -my-5 relative z-10">
                        <button
                            onclick="switchDir()"
                            class="bg-[#2b1d1a] border border-fennec/30 p-3 rounded-full text-fennec shadow-xl hover:scale-110 transition hover:border-fennec rotate-90"
                            title="Switch direction"
                        >
                            <i class="fas fa-exchange-alt"></i>
                        </button>
                    </div>

                    <div class="bg-black/40 rounded-xl p-4 mt-2 border border-white/5">
                        <div class="flex justify-between text-xs mb-2 text-gray-400">
                            <span data-t="you_receive" class="font-bold">YOU RECEIVE</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <input
                                type="number"
                                id="swapOut"
                                placeholder="0.0"
                                class="bg-transparent text-3xl font-bold w-full outline-none text-white placeholder-gray-700"
                                oninput="debounceReverse()"
                            />
                            <div class="flex items-center gap-2 px-3 py-1.5 min-w-[80px] justify-center">
                                <img id="iconOut" src="img/fennec.jpg" class="w-6 h-6 rounded-full flex-shrink-0" />
                                <span id="tickerOut" class="font-bold text-sm whitespace-nowrap">FENNEC</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-between text-[10px] text-gray-500 mt-4 px-2 font-mono">
                        <span id="rateVal">Rate: --</span>
                        <button
                            onclick="openAddLiquidityFromSwap()"
                            class="bg-fennec text-black font-black text-sm px-5 py-2.5 rounded-xl hover:bg-white transition shadow-[0_0_26px_rgba(255,107,53,0.28)] flex items-center gap-2"
                            type="button"
                        >
                            <i class="fas fa-plus"></i> Add Liquidity
                        </button>
                    </div>

                    <button
                        onclick="doSwap()"
                        id="swapBtn"
                        class="w-full bg-fennec text-black font-black text-xl py-4 rounded-xl mt-6 hover:bg-white hover:scale-[1.01] transition shadow-[0_0_20px_rgba(255,107,53,0.3)] tracking-wide flex items-center justify-center gap-2"
                        data-t="swap_action"
                    >
                        <img src="img/phav.png" class="w-6 h-6 inline-block object-contain" /> GET FENNEC
                    </button>

                    <!-- Recent Swaps -->
                    <div class="mt-6 pt-4 border-t border-white/10">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-[10px] font-bold text-gray-500 uppercase tracking-widest"
                                >Recent Swaps</span
                            >
                            <button
                                onclick="refreshTransactionHistory()"
                                class="text-[10px] text-fennec hover:text-white"
                            >
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                        <div id="swapHistory" class="space-y-2 max-h-40 overflow-y-auto scrollbar-thin">
                            <div class="text-center py-4 text-gray-600 text-xs">No swaps yet</div>
                        </div>
                    </div>
                </div>

                <!-- DEPOSIT TAB -->
                <div id="view-deposit" class="tab-content hidden">
                    <div class="flex gap-2 mb-6">
                        <button
                            onclick="setDepositToken('BTC')"
                            id="dep-btc"
                            class="flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg"
                        >
                            BTC
                        </button>
                        <button
                            onclick="setDepositToken('sFB')"
                            id="dep-sfb"
                            class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg"
                        >
                            FB
                        </button>
                        <button
                            onclick="setDepositToken('FENNEC')"
                            id="dep-fennec"
                            class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg"
                        >
                            FENNEC
                        </button>
                    </div>

                    <div id="dep-native-ui">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-xs text-gray-400" id="depBalance">Balance: --</span>
                            <div class="flex items-center gap-2">
                                <button
                                    onclick="refreshBalancesInline()"
                                    class="text-[10px] text-fennec hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                    title="Refresh balances"
                                    type="button"
                                >
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button
                                    onclick="setMaxDepositAmount()"
                                    class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                >
                                    MAX
                                </button>
                            </div>
                        </div>
                        <div
                            class="bg-black/40 rounded-xl p-4 mb-4 border border-white/5 flex justify-between items-center"
                        >
                            <input
                                type="number"
                                id="depAmount"
                                placeholder="0.001"
                                class="bg-transparent text-2xl font-bold w-full outline-none text-white"
                            />
                            <span class="font-bold text-gray-400" id="depTickerLabel">BTC</span>
                        </div>

                        <!-- Fee Selection -->
                        <div class="mb-4">
                            <div class="text-[10px] font-bold text-gray-400 tracking-wider mb-2">NETWORK FEE</div>
                            <div class="flex gap-2" id="depFeeSelector">
                                <button
                                    onclick="setDepositFee('medium')"
                                    id="dep-fee-medium"
                                    class="flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg transition"
                                >
                                    <div>MEDIUM</div>
                                    <div class="text-[10px] text-fennec/70" id="dep-fee-medium-value">--</div>
                                </button>
                                <button
                                    onclick="setDepositFee('fast')"
                                    id="dep-fee-fast"
                                    class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition"
                                >
                                    <div>FAST</div>
                                    <div class="text-[10px] text-gray-600" id="dep-fee-fast-value">--</div>
                                </button>
                                <button
                                    onclick="setDepositFee('custom')"
                                    id="dep-fee-custom"
                                    class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition"
                                >
                                    <div>CUSTOM</div>
                                    <input
                                        type="number"
                                        id="dep-fee-custom-input"
                                        placeholder="sat/vB"
                                        min="1"
                                        step="1"
                                        class="text-[10px] bg-black/40 border border-white/20 rounded w-full text-center mt-1 text-white px-1"
                                        style="display: none"
                                        onchange="setDepositFeeCustom(this.value)"
                                    />
                                </button>
                            </div>
                        </div>

                        <button
                            onclick="doDeposit()"
                            id="btnDeposit"
                            class="w-full bg-white text-black font-bold py-4 rounded-xl hover:bg-gray-200 transition"
                            data-t="deposit_btc_btn"
                        >
                            DEPOSIT BTC
                        </button>
                    </div>
                    <div id="dep-brc20-ui" style="display: none">
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs text-gray-400"
                                    >Available: <span id="fennecAvailable">--</span></span
                                >
                                <span class="text-xs text-gray-400"
                                    >Transferable: <span id="fennecTransferable">--</span></span
                                >
                            </div>
                            <button
                                onclick="loadFennecInscriptions()"
                                class="text-xs text-fennec hover:text-white mb-3"
                            >
                                Refresh
                            </button>
                        </div>
                        <div id="inscriptionCards" class="grid grid-cols-3 gap-3 mb-4 max-h-64 overflow-y-auto">
                            <div class="text-center py-8 text-gray-500 text-xs">Loading inscriptions...</div>
                        </div>
                        <div class="border-t border-white/10 pt-3 mb-4">
                            <div class="flex items-center justify-between text-sm">
                                <span class="text-gray-400">Selected:</span>
                                <span class="text-white font-bold" id="selectedAmount">0</span>
                                <span class="text-fennec font-bold">FENNEC</span>
                            </div>
                        </div>
                        <button
                            onclick="depositSelectedInscriptions()"
                            id="btnDepositSelected"
                            class="w-full bg-fennec text-black font-black text-base py-4 rounded-xl hover:bg-white transition duration-200 shadow-lg mb-3"
                            disabled
                        >
                            DEPOSIT
                        </button>
                        <div class="text-center py-2 border-t border-white/10">
                            <div class="mb-3">
                                <div class="flex items-center justify-center gap-2 mb-2">
                                    <input
                                        type="number"
                                        id="depFennecAmount"
                                        placeholder="Enter amount"
                                        min="0.00000001"
                                        step="0.00000001"
                                        class="bg-black/40 border border-white/10 rounded-lg px-3 py-2 text-white text-sm w-32 text-center focus:border-fennec transition"
                                        style="outline: none"
                                    />
                                    <span class="text-xs text-gray-400">FENNEC</span>
                                </div>
                                <button
                                    onclick="setMaxFennecAmount()"
                                    class="text-[10px] text-fennec hover:text-white bg-fennec/10 px-3 py-1 rounded border border-fennec/30 mb-2"
                                >
                                    Use Max
                                </button>
                            </div>
                            <button
                                onclick="createFennecInscription()"
                                id="btnCreateInscription"
                                class="text-xs text-fennec hover:text-white bg-fennec/10 px-4 py-2 rounded-lg border border-fennec/30 transition hover:bg-fennec/20"
                            >
                                Create Transfer Inscription
                            </button>
                        </div>
                    </div>

                    <!-- Recent Deposits -->
                    <div class="mt-6 pt-4 border-t border-white/10">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-[10px] font-bold text-gray-500 uppercase tracking-widest"
                                >Recent Deposits</span
                            >
                            <button
                                onclick="refreshTransactionHistory()"
                                class="text-[10px] text-fennec hover:text-white"
                            >
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                        <div id="depositHistory" class="space-y-2 max-h-40 overflow-y-auto scrollbar-thin">
                            <div class="text-center py-4 text-gray-600 text-xs">No deposits yet</div>
                        </div>
                    </div>
                </div>

                <!-- WITHDRAW TAB -->
                <div id="view-withdraw" class="tab-content hidden">
                    <div class="flex gap-2 mb-6">
                        <button
                            onclick="setWithdrawToken('sFB')"
                            id="wd-sfb"
                            class="flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg"
                        >
                            FB
                        </button>
                        <button
                            onclick="setWithdrawToken('FENNEC')"
                            id="wd-fennec"
                            class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg"
                        >
                            FENNEC
                        </button>
                    </div>
                    <div class="flex justify-between text-xs mb-2 text-gray-400">
                        <span id="wd-bal">Available: --</span>
                        <div class="flex items-center gap-2">
                            <button
                                onclick="refreshBalancesInline()"
                                class="text-[10px] text-fennec hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                title="Refresh balances"
                                type="button"
                            >
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button
                                onclick="setMaxWithdrawAmount()"
                                class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                            >
                                MAX
                            </button>
                        </div>
                    </div>
                    <div
                        class="bg-black/40 rounded-xl p-4 mb-4 border border-white/5 flex justify-between items-center"
                    >
                        <input
                            type="number"
                            id="wdAmount"
                            placeholder="0.0"
                            class="bg-transparent text-2xl font-bold w-full outline-none text-white"
                        />
                        <span class="font-bold text-gray-400" id="wdTickerLabel">FB</span>
                    </div>

                    <!-- Fee Selection -->
                    <div class="mb-4">
                        <div class="text-[10px] font-bold text-gray-400 tracking-wider mb-2">NETWORK FEE</div>
                        <div class="flex gap-2" id="wdFeeSelector">
                            <button
                                onclick="setWithdrawFee('medium')"
                                id="wd-fee-medium"
                                class="flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg transition"
                            >
                                <div>MEDIUM</div>
                                <div class="text-[10px] text-fennec/70" id="wd-fee-medium-value">--</div>
                            </button>
                            <button
                                onclick="setWithdrawFee('fast')"
                                id="wd-fee-fast"
                                class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition"
                            >
                                <div>FAST</div>
                                <div class="text-[10px] text-gray-600" id="wd-fee-fast-value">--</div>
                            </button>
                            <button
                                onclick="setWithdrawFee('custom')"
                                id="wd-fee-custom"
                                class="flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition"
                            >
                                <div>CUSTOM</div>
                                <input
                                    type="number"
                                    id="wd-fee-custom-input"
                                    placeholder="sat/vB"
                                    min="1"
                                    step="1"
                                    class="text-[10px] bg-black/40 border border-white/20 rounded w-full text-center mt-1 text-white px-1"
                                    style="display: none"
                                    onchange="setWithdrawFeeCustom(this.value)"
                                />
                            </button>
                        </div>
                    </div>

                    <button
                        onclick="doWithdraw()"
                        id="btnWithdraw"
                        class="w-full bg-white text-black font-bold py-4 rounded-xl hover:bg-gray-200 transition"
                        data-t="withdraw_btn"
                    >
                        WITHDRAW
                    </button>

                    <!-- Recent Withdrawals -->
                    <div class="mt-6 pt-4 border-t border-white/10">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-[10px] font-bold text-gray-500 uppercase tracking-widest"
                                >Recent Withdrawals</span
                            >
                            <button
                                onclick="refreshTransactionHistory()"
                                class="text-[10px] text-fennec hover:text-white"
                            >
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                        <div id="withdrawHistory" class="space-y-2 max-h-40 overflow-y-auto scrollbar-thin">
                            <div class="text-center py-4 text-gray-600 text-xs">No withdrawals yet</div>
                        </div>
                    </div>
                </div>

                <!-- PENDING TAB -->
                <div id="view-pending" class="tab-content hidden">
                    <div class="text-xs text-gray-500 font-bold uppercase mb-3 tracking-widest flex justify-between">
                        <span>Pending Operations</span>
                        <button onclick="refreshPendingOperations()" class="text-fennec hover:text-white">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                    <div id="pendingOperations" class="space-y-2 max-h-80 overflow-y-auto scrollbar-thin">
                        <div class="text-center py-8 text-gray-600 text-xs">No pending operations</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- === SECTION 3: FENNEC GRAND AUDIT === -->
        <section id="sec-audit" class="page-section flex flex-col justify-start pt-32 pb-20 relative z-10">
            <div class="max-w-4xl mx-auto px-6">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-black font-display text-white text-glow neon-text">FENNEC ID</h2>
                    <p class="text-center text-gray-300/80 text-sm mt-3">
                        Your digital footprint in the Fractal desert
                    </p>
                </div>

                <div class="glass-panel rounded-3xl p-6 md:p-8 border border-fennec/15 relative overflow-visible">
                    <div id="auditContainer" class="relative flex justify-center">
                        <!-- Content will be generated by JavaScript -->
                    </div>
                </div>
            </div>
        </section>

        <!-- === SECTION 4: THE BURROW (VISUALIZER) === -->
        <section id="sec-burrow" class="page-section pt-32 pb-20 relative z-10 text-center">
            <div class="max-w-4xl mx-auto px-6">
                <h2 class="text-4xl font-black font-display mb-4 text-white text-glow neon-text" data-t="burrow_title">
                    THE BURROW
                </h2>
                <p class="text-gray-400 text-sm mb-8" data-t="burrow_desc">
                    Live Mempool Visualization (Particles = Transactions)
                </p>
                <div
                    class="glass-panel p-1 rounded-2xl relative overflow-hidden h-[400px] border border-fennec/30 shadow-[0_0_50px_rgba(255,107,53,0.15)]"
                >
                    <canvas id="burrowCanvas"></canvas>
                    <div class="absolute bottom-4 left-4 text-xs text-fennec font-mono animate-pulse">LIVE FEED</div>
                </div>
            </div>
        </section>

        <!-- FOOTER SPACER -->
        <div class="h-10"></div>

        <div
            id="errorModal"
            class="modal-overlay hidden"
            onclick="document.getElementById('errorModal').classList.add('hidden')"
        >
            <div class="modal-box border-red-500/30" onclick="event.stopPropagation()">
                <h3 class="text-lg font-bold text-red-500 mb-2">Error</h3>
                <p id="errorMsg" class="text-gray-400 text-xs font-mono mb-4 break-all"></p>
                <button
                    onclick="document.getElementById('errorModal').classList.add('hidden')"
                    class="w-full bg-white/10 py-2 rounded-lg hover:bg-white/20 text-white text-sm font-bold"
                >
                    CLOSE
                </button>
            </div>
        </div>
        <div
            id="successModal"
            class="modal-overlay hidden"
            onclick="document.getElementById('successModal').classList.add('hidden')"
        >
            <div class="modal-box border-green-500/30 text-center" onclick="event.stopPropagation()">
                <div class="text-4xl mb-3">🎉</div>
                <h3 class="text-lg font-bold text-green-500 mb-2">Success!</h3>
                <p class="text-gray-400 text-xs mb-4 font-mono break-all bg-black/30 p-2 rounded" id="successTxId"></p>
                <button
                    onclick="document.getElementById('successModal').classList.add('hidden')"
                    class="w-full bg-green-600 text-black font-bold py-2 rounded-lg hover:bg-green-500 transition"
                >
                    OK
                </button>
            </div>
        </div>
        <div
            id="depositLinkModal"
            class="modal-overlay hidden"
            onclick="document.getElementById('depositLinkModal').classList.add('hidden')"
        >
            <div class="modal-box border-fennec/30 text-center" onclick="event.stopPropagation()">
                <i class="fas fa-wallet text-3xl text-fennec mb-4"></i>
                <h3 class="text-xl font-bold text-white mb-2">Insufficient Funds</h3>
                <button
                    onclick="
                        switchTab('deposit');
                        document.getElementById('depositLinkModal').classList.add('hidden');
                    "
                    class="w-full bg-fennec text-black py-3 rounded-xl font-bold hover:bg-white transition"
                >
                    GO TO DEPOSIT
                </button>
            </div>
        </div>

        <div id="addLiquidityModal" class="modal-overlay hidden" onclick="closeAddLiquidityModal()">
            <div
                class="modal-box border-fennec/30"
                style="max-width: 560px; width: 92%; padding: 22px"
                onclick="event.stopPropagation()"
            >
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <div class="text-[10px] text-gray-400 uppercase tracking-widest font-bold">
                            Liquidity (InSwap)
                        </div>
                        <div class="text-lg font-black text-white">Manage Liquidity</div>
                    </div>
                    <div class="flex items-center gap-3">
                        <a
                            href="https://inswap.cc/swap/pools?tab=mine"
                            target="_blank"
                            class="text-[10px] text-fennec hover:text-white underline decoration-dotted"
                            >My Liquidity</a
                        >
                        <button type="button" onclick="closeAddLiquidityModal()" class="text-gray-500 hover:text-white">
                            ✕
                        </button>
                    </div>
                </div>

                <!-- Tabs -->
                <div class="flex gap-2 mb-3">
                    <button
                        id="liqTabAdd"
                        onclick="switchLiquidityTab('add')"
                        class="flex-1 px-4 py-2 rounded-xl bg-fennec/15 border border-fennec/30 text-white font-black transition"
                    >
                        ADD
                    </button>
                    <button
                        id="liqTabRemove"
                        onclick="switchLiquidityTab('remove')"
                        class="flex-1 px-4 py-2 rounded-xl bg-white/5 border border-white/10 text-gray-400 font-black transition"
                    >
                        REMOVE
                    </button>
                </div>

                <!-- Pair selector hidden - pair is fixed when modal opens -->
                <div class="hidden grid grid-cols-2 gap-2" id="liqPairSwitcher">
                    <button
                        id="liqPairFBF"
                        onclick="selectLiquidityPair('FB_FENNEC')"
                        class="px-4 py-3 rounded-xl bg-fennec/10 border border-fennec/25 text-white font-black hover:bg-fennec/15 hover:border-fennec/45 transition"
                    >
                        FB / FENNEC
                    </button>
                    <button
                        id="liqPairBFB"
                        onclick="selectLiquidityPair('BTC_FB')"
                        class="px-4 py-3 rounded-xl bg-white/5 border border-white/10 text-white font-black hover:bg-white/10 hover:border-white/20 transition"
                    >
                        BTC / FB
                    </button>
                </div>

                <!-- Add Liquidity Tab Content -->
                <div id="liqAddContent">
                    <!-- Display fixed pair -->
                    <div class="text-center py-3 px-4 bg-fennec/10 border border-fennec/30 rounded-xl">
                        <div class="text-xs text-gray-400 uppercase tracking-widest mb-1">Selected Pair</div>
                        <div id="liqFixedPairDisplay" class="text-xl font-black text-white">FB / FENNEC</div>
                    </div>

                    <div id="liqSideRow" class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                        <div
                            id="liqMyPos"
                            class="hidden bg-black/40 border border-white/10 rounded-xl p-3 md:col-span-2"
                        >
                            <div class="flex items-center justify-between gap-3">
                                <div class="text-[10px] text-gray-400 uppercase tracking-widest font-bold">
                                    Your Position
                                </div>
                                <button
                                    type="button"
                                    onclick="refreshMyLiquidityForSelectedPair(true)"
                                    class="text-[10px] text-fennec hover:text-white underline decoration-dotted"
                                >
                                    Refresh
                                </button>
                            </div>
                            <div id="liqMyPosBody" class="mt-3 text-gray-200">--</div>
                        </div>

                        <div
                            id="liqWithdrawPanel"
                            class="hidden bg-black/40 border border-white/10 rounded-xl p-3 md:col-span-1"
                        >
                            <div class="flex items-center justify-between gap-3">
                                <div class="text-[10px] text-gray-400 uppercase tracking-widest font-bold">
                                    Liquidity
                                </div>
                                <button
                                    id="liqWithdrawBtn"
                                    type="button"
                                    onclick="openRemoveLiquidityModal()"
                                    class="text-[10px] font-black bg-fennec/15 text-fennec border border-fennec/30 px-2 py-1 rounded-lg hover:bg-fennec/25 transition"
                                >
                                    Withdraw
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                        <div class="bg-black/40 border border-white/10 rounded-xl p-3">
                            <div class="flex items-center justify-between text-[10px] text-gray-400 font-bold">
                                <span id="liqTick0Label">FENNEC</span>
                                <button
                                    onclick="setMaxLiqAmount(0)"
                                    class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                    type="button"
                                >
                                    MAX
                                </button>
                            </div>
                            <input
                                id="liqAmount0"
                                type="number"
                                inputmode="decimal"
                                placeholder="0.0"
                                class="mt-2 w-full bg-transparent text-2xl font-black outline-none text-white placeholder-gray-700"
                                oninput="syncLiquidityAmounts(0)"
                            />
                            <div class="text-[10px] text-gray-500 mt-1">Bal: <span id="liqBal0">--</span></div>
                        </div>
                        <div class="bg-black/40 border border-white/10 rounded-xl p-3">
                            <div class="flex items-center justify-between text-[10px] text-gray-400 font-bold">
                                <span id="liqTick1Label">FB</span>
                                <button
                                    onclick="setMaxLiqAmount(1)"
                                    class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                                    type="button"
                                >
                                    MAX
                                </button>
                            </div>
                            <input
                                id="liqAmount1"
                                type="number"
                                inputmode="decimal"
                                placeholder="0.0"
                                class="mt-2 w-full bg-transparent text-2xl font-black outline-none text-white placeholder-gray-700"
                                oninput="syncLiquidityAmounts(1)"
                            />
                            <div class="text-[10px] text-gray-500 mt-1">Bal: <span id="liqBal1">--</span></div>
                        </div>
                    </div>

                    <div class="mt-3 flex items-center justify-between text-[10px] text-gray-500 font-mono px-1">
                        <span>Expected LP: <span id="liqExpectedLP" class="text-white font-bold">--</span></span>
                        <a
                            href="https://inswap.cc/swap/pools"
                            target="_blank"
                            class="text-[10px] text-fennec hover:text-white underline decoration-dotted"
                            onclick="copyLiquidityPairForSearch()"
                            >Open Pools ↗</a
                        >
                    </div>

                    <button
                        onclick="doAddLiquidity()"
                        id="liqSupplyBtn"
                        class="mt-3 w-full bg-gradient-to-r from-fennec to-orange-400 text-black font-black text-base py-3 rounded-xl hover:brightness-110 transition opacity-50 cursor-not-allowed"
                        disabled
                    >
                        SUPPLY
                    </button>
                </div>

                <!-- Remove Liquidity Tab Content -->
                <div id="liqRemoveContent" class="hidden">
                    <div class="bg-black/40 border border-white/10 rounded-xl p-3">
                        <div class="flex items-center justify-between text-[10px] text-gray-400 font-bold">
                            <span>LP Amount</span>
                            <button
                                type="button"
                                onclick="setMaxRemoveLp()"
                                class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                            >
                                MAX
                            </button>
                        </div>
                        <input
                            id="removeLpAmount"
                            type="number"
                            inputmode="decimal"
                            placeholder="0.0"
                            class="mt-2 w-full bg-transparent text-2xl font-black outline-none text-white placeholder-gray-700"
                        />
                        <div class="text-[10px] text-gray-500 mt-1">Your LP: <span id="removeLpBalance">--</span></div>
                    </div>

                    <div class="mt-3 flex items-center justify-between text-[10px] text-gray-500 font-mono px-1">
                        <span>Est. Receive: <span id="removeReceive" class="text-white font-bold">--</span></span>
                        <span class="text-gray-600">Fees in FB</span>
                    </div>

                    <button
                        onclick="doRemoveLiquidity()"
                        id="removeLiqBtn"
                        class="mt-3 w-full bg-gradient-to-r from-fennec to-orange-400 text-black font-black text-base py-3 rounded-xl hover:brightness-110 transition opacity-50 cursor-not-allowed"
                        disabled
                    >
                        WITHDRAW
                    </button>
                </div>
            </div>
        </div>

        <div id="removeLiquidityModal" class="modal-overlay hidden" onclick="closeRemoveLiquidityModal()">
            <div
                class="modal-box border-fennec/30"
                style="max-width: 520px; width: 92%; padding: 22px"
                onclick="event.stopPropagation()"
            >
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <div class="text-[10px] text-gray-400 uppercase tracking-widest font-bold">
                            Withdraw Liquidity
                        </div>
                        <div class="text-lg font-black text-white">Remove Liquidity</div>
                    </div>
                    <button type="button" onclick="closeRemoveLiquidityModal()" class="text-gray-500 hover:text-white">
                        ✕
                    </button>
                </div>

                <div class="bg-black/40 border border-white/10 rounded-xl p-3">
                    <div class="flex items-center justify-between text-[10px] text-gray-400 font-bold">
                        <span>LP Amount</span>
                        <button
                            type="button"
                            onclick="setMaxRemoveLp()"
                            class="text-[10px] text-fennec font-bold hover:text-white px-2 py-0.5 bg-fennec/10 rounded"
                        >
                            MAX
                        </button>
                    </div>
                    <input
                        id="removeLpAmount"
                        type="number"
                        inputmode="decimal"
                        placeholder="0.0"
                        class="mt-2 w-full bg-transparent text-2xl font-black outline-none text-white placeholder-gray-700"
                    />
                    <div class="text-[10px] text-gray-500 mt-1">Your LP: <span id="removeLpBalance">--</span></div>
                </div>

                <div class="mt-3 flex items-center justify-between text-[10px] text-gray-500 font-mono px-1">
                    <span>Est. Receive: <span id="removeReceive" class="text-white font-bold">--</span></span>
                    <span class="text-gray-600">Fees in FB</span>
                </div>

                <button
                    onclick="doRemoveLiquidity()"
                    id="removeLiqBtn"
                    class="mt-3 w-full bg-white/10 border border-white/10 text-white font-black text-base py-3 rounded-xl hover:bg-white/15 transition"
                >
                    WITHDRAW
                </button>
            </div>
        </div>

        <div
            id="inscriptionModal"
            class="modal-overlay hidden"
            onclick="document.getElementById('inscriptionModal').classList.add('hidden')"
        >
            <div class="modal-box" onclick="event.stopPropagation()">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-white">Select Inscription</h3>
                    <button
                        onclick="document.getElementById('inscriptionModal').classList.add('hidden')"
                        class="text-gray-500 hover:text-white"
                    >
                        ✕
                    </button>
                </div>
                <div id="inscList" class="max-h-60 overflow-y-auto space-y-2">
                    <div class="text-center py-4 text-gray-500 text-xs">Loading...</div>
                </div>
            </div>
        </div>
        <div
            id="switchWalletModal"
            class="modal-overlay hidden"
            onclick="document.getElementById('switchWalletModal').classList.add('hidden')"
        >
            <div class="modal-box border-fennec/30 text-center" onclick="event.stopPropagation()">
                <i class="fas fa-exchange-alt text-3xl text-fennec mb-4"></i>
                <h3 class="text-xl font-bold text-white mb-2">Switch Wallet?</h3>
                <p class="text-gray-400 text-sm mb-4">
                    You are about to switch from:<br /><span
                        class="text-fennec font-mono text-xs"
                        id="currentWalletAddress"
                    ></span
                    ><br /><br />Please confirm to continue.
                </p>
                <div class="flex gap-3">
                    <button
                        onclick="
                            document.getElementById('switchWalletModal').classList.add('hidden');
                            switchWalletConfirmed = true;
                            window.connectWallet();
                        "
                        class="flex-1 bg-fennec text-black py-3 rounded-xl font-bold hover:bg-white transition"
                    >
                        CONFIRM</button
                    ><button
                        onclick="
                            document.getElementById('switchWalletModal').classList.add('hidden');
                            switchWalletConfirmed = false;
                        "
                        class="flex-1 bg-white/10 text-white py-3 rounded-xl font-bold hover:bg-white/20 transition"
                    >
                        CANCEL
                    </button>
                </div>
            </div>
        </div>

        <!-- WHALE WATCHER NOTIFICATION -->
        <div
            id="whaleWatcher"
            class="whale-alert fixed bottom-4 right-4 bg-black/90 border border-fennec/50 p-4 rounded-xl shadow-[0_0_30px_rgba(255,107,53,0.3)] transform translate-y-[200%] transition-transform duration-500 z-50 flex items-center gap-4 max-w-sm hidden"
        >
            <div class="text-4xl">🔭</div>
            <div>
                <div class="text-xs text-fennec font-bold uppercase tracking-widest mb-1">Whale Alert</div>
                <div id="whaleMsg" class="text-sm text-white font-mono leading-tight">Someone just swapped 500 FB!</div>
            </div>
            <button
                onclick="document.getElementById('whaleWatcher').classList.add('translate-y-[200%]')"
                class="absolute top-2 right-2 text-gray-500 hover:text-white"
            >
                ×
            </button>
        </div>

        <!-- Progress Tracking Modal -->
        <div id="progressModal" class="modal-overlay hidden">
            <div class="modal-box border-fennec/30 text-center" onclick="event.stopPropagation()">
                <div class="text-4xl mb-4"><i class="fas fa-spinner fa-spin text-fennec"></i></div>
                <h3 class="text-lg font-bold text-white mb-3" id="progressTitle">Processing...</h3>
                <div class="bg-black/40 rounded-lg p-4 mb-4">
                    <div class="flex justify-between text-xs mb-2">
                        <span class="text-gray-400" id="progressStep">Waiting...</span
                        ><span class="text-fennec font-bold" id="progressPercent">0%</span>
                    </div>
                    <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                        <div
                            id="progressBar"
                            class="bg-gradient-to-r from-fennec to-sand h-full transition-all duration-300"
                            style="width: 0%"
                        ></div>
                    </div>
                </div>
                <p class="text-gray-400 text-xs font-mono break-all bg-black/30 p-2 rounded mb-4" id="progressTxId"></p>
                <button
                    onclick="closeProgress()"
                    class="w-full bg-white/10 py-2 rounded-lg hover:bg-white/20 text-white text-sm font-bold"
                >
                    CLOSE
                </button>
            </div>
        </div>

        <script src="recursive_inscriptions/fennec_lib_v1.js?v=2025-12-29-1"></script>
        <script>
            // ИСПРАВЛЕНИЕ: Предварительно объявляем функции на window, чтобы они были доступны для inline onclick
            // Это предотвращает ошибки "function is not defined" при парсинге HTML
            // DO NOT REMOVE.
            window.showSection = window.showSection || function () {};
            window.showSection = function (id) {
                const sections = document.querySelectorAll('.page-section');
                if (sections.length === 0) {
                    console.warn('Sections not loaded yet');
                    return;
                }
                sections.forEach(sec => {
                    sec.classList.remove('active');
                    sec.style.display = 'none'; // Скрываем полностью
                });

                // ИСПРАВЛЕНИЕ: Если переключились на аудит, восстанавливаем из кэша или показываем кнопку
                if (id === 'audit') {
                    const currentAddr = window.userAddress || userAddress || null;
                    if (currentAddr && !auditLoading) {
                        const cacheKey = `audit_v2_${currentAddr}`;
                        const cached = localStorage.getItem(cacheKey);
                        if (cached && !auditIdentity) {
                            try {
                                const cachedData = JSON.parse(cached);
                                if (Date.now() - cachedData.timestamp < 5 * 60 * 1000) {
                                    console.log('✅ Restoring audit from cache');
                                    auditIdentity = cachedData.identity;
                                    renderAudit(cachedData.identity);
                                    return;
                                }
                            } catch (e) {
                                console.warn('Failed to restore from cache:', e);
                            }
                        }
                    }
                    if (typeof initAudit === 'function' && !auditLoading) {
                        setTimeout(() => initAudit(), 50);
                    }
                }

                const target = document.getElementById(`sec-${id}`);
                if (target) {
                    target.style.display = 'flex';
                    setTimeout(() => target.classList.add('active'), 10);
                    window.scrollTo({ top: 0, behavior: 'instant' });
                }

                document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
                const navLink = document.getElementById(`nav-${id}`);
                if (navLink) navLink.classList.add('active');

                // ИСПРАВЛЕНИЕ: Скрываем кнопку REFRESH в header когда открыт Fennec ID
                const refreshBtn = document.getElementById('refreshBtn');
                if (refreshBtn) {
                    if (id === 'audit') {
                        refreshBtn.classList.add('hidden');
                    } else {
                        // Показываем только если кошелек подключен
                        if (userAddress) {
                            refreshBtn.classList.remove('hidden');
                        }
                    }
                }

                // ИСПРАВЛЕНИЕ: Если переключились на аудит, восстанавливаем из кэша
                // Блок удален так как логика перенесена выше и консолидирована.
            };

            // ИСПРАВЛЕНИЕ: Определяем connectWallet сразу после showSection
            window.connectWallet = async function () {
                if (typeof window.unisat === 'undefined') {
                    window.open('https://unisat.io/download', '_blank');
                    return;
                }
                try {
                    console.log('=== CONNECTING WALLET ===');
                    try {
                        await window.unisat.switchChain('FRACTAL_BITCOIN_MAINNET');
                        console.log('✅ Switched to Fractal Bitcoin Mainnet');
                    } catch (e) {
                        console.warn('Switch chain warning:', e);
                    }
                    console.log('Requesting accounts...');
                    const acc =
                        typeof window.unisat.requestAccounts === 'function'
                            ? await window.unisat.requestAccounts()
                            : typeof window.unisat.getAccounts === 'function'
                              ? await window.unisat.getAccounts()
                              : null;
                    if (!acc || acc.length === 0) {
                        throw new Error('No accounts returned from wallet');
                    }

                    // ИСПРАВЛЕНИЕ: Проверяем, не переключается ли кошелек
                    const newAddr = acc[0];
                    if (userAddress && userAddress !== newAddr && !switchWalletConfirmed) {
                        // Показываем модалку подтверждения
                        const currentAddrEl = document.getElementById('currentWalletAddress');
                        if (currentAddrEl) {
                            currentAddrEl.textContent = userAddress;
                        }
                        document.getElementById('switchWalletModal').classList.remove('hidden');
                        return; // Ждем подтверждения
                    }

                    // Set userAddress - use window for global access
                    const addr = newAddr;
                    window.userAddress = addr;
                    // Also try to set in local scope if variable exists
                    try {
                        if (typeof userAddress !== 'undefined') {
                            userAddress = addr;
                        }
                    } catch (e) {}
                    console.log('Got address:', addr);
                    try {
                        const pubkey =
                            typeof window.unisat.getPublicKey === 'function'
                                ? await window.unisat.getPublicKey()
                                : null;
                        window.userPubkey = pubkey;
                        try {
                            if (typeof userPubkey !== 'undefined') {
                                userPubkey = pubkey;
                            }
                        } catch (e) {}
                    } catch (e) {}
                    // ИСПРАВЛЕНИЕ: Обновляем UI кнопок
                    const connectBtn = document.getElementById('connectBtn');
                    const disconnectBtn = document.getElementById('disconnectBtn');
                    if (connectBtn) {
                        connectBtn.classList.add('hidden');
                    }
                    if (disconnectBtn) {
                        disconnectBtn.classList.remove('hidden');
                        disconnectBtn.innerHTML = `<i class="fas fa-sign-out-alt"></i> <span>...${addr.slice(-4)}</span>`;
                    }
                    // ВСЕГДА скрываем кнопку REFRESH в секции Fennec ID
                    const refreshBtn = document.getElementById('refreshBtn');
                    if (refreshBtn) {
                        refreshBtn.classList.add('hidden'); // Всегда скрываем в Fennec ID секции
                    }

                    console.log('✅ Wallet connected');

                    // ИСПРАВЛЕНИЕ: Всегда обновляем UI FENNEC ID после подключения кошелька.
                    // Раньше проверялся tab-audit, которого может не быть/не быть active.
                    if (typeof initAudit === 'function') {
                        setTimeout(() => initAudit(), 100);
                    }
                    try {
                        if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();
                    } catch (e) {}

                    // ИСПРАВЛЕНИЕ: Сбрасываем флаг подтверждения
                    switchWalletConfirmed = false;

                    // ИСПРАВЛЕНИЕ: Запускаем автообновление данных каждую минуту
                    // ИСПРАВЛЕНИЕ: Автообновление отключено - пользователь обновляет вручную
                    // startAutoUpdate();

                    // ИСПРАВЛЕНИЕ: Начинаем предзагрузку данных для Fennec ID сразу после подключения кошелька
                    // Это ускорит загрузку при открытии Fennec ID
                    if (false && typeof window.preloadAuditData === 'function') {
                        console.log('🔄 Preloading audit data...');
                        window.preloadAuditData(addr);
                    }

                    if (typeof checkBalance === 'function') checkBalance();
                    if (typeof refreshTransactionHistory === 'function') {
                        setTimeout(refreshTransactionHistory, 2000);
                    }

                    // Подгрузить LP позицию если модалка Add Liquidity открыта
                    try {
                        const modal = document.getElementById('addLiquidityModal');
                        if (modal && !modal.classList.contains('hidden')) {
                            console.log('🔄 Reloading LP position after wallet connection...');
                            setTimeout(() => refreshMyLiquidityForSelectedPair(false), 500);
                        }
                    } catch (e) {
                        console.error('Failed to reload LP position:', e);
                    }

                    // Setup account change listener
                    if (!window.__unisatAccountListenerSetup && window.unisat) {
                        window.__unisatAccountListenerSetup = true;
                        try {
                            window.unisat.on('accountsChanged', accounts => {
                                console.log('🔄 Unisat account changed:', accounts);
                                if (accounts && accounts.length > 0 && accounts[0] !== userAddress) {
                                    console.log('⚠️ Account switch detected, resetting data...');
                                    window.disconnectWallet();
                                }
                            });
                        } catch (e) {
                            console.warn('Could not setup account listener:', e);
                        }
                    }
                } catch (e) {
                    console.error('Wallet connection error:', e);
                    alert(e.message || 'Failed to connect wallet');
                }
            };

            // ИСПРАВЛЕНИЕ: Функция отключения кошелька
            window.disconnectWallet = function () {
                const currentAddr = userAddress || window.userAddress;
                if (!currentAddr) {
                    console.log('No wallet to disconnect');
                    return;
                }

                console.log('Disconnecting wallet:', currentAddr);

                // Останавливаем автообновление
                stopAutoUpdate();

                // Очищаем данные
                userAddress = null;
                window.userAddress = null;
                userPubkey = null;
                window.userPubkey = null;

                // Очищаем UI данные
                userBalances = { sFB: 0, FENNEC: 0, BTC: 0 };
                walletBalances = { sFB: 0, FENNEC: 0, BTC: 0 };
                poolReserves = { sFB: 0, FENNEC: 0, BTC: 0, user_sBTC: 0 };
                auditIdentity = null;
                auditLoading = false;
                prefetchedFennecAudit = null;
                prefetchedFennecAuditAddr = null;
                prefetchedFennecAuditTs = 0;

                // ИСПРАВЛЕНИЕ: Очищаем кэш аудита при отключении кошелька
                if (currentAddr) {
                    const cacheKey = `audit_${currentAddr}`;
                    localStorage.removeItem(cacheKey);
                    const cacheKey2 = `audit_v2_${currentAddr}`;
                    localStorage.removeItem(cacheKey2);
                }

                // Обновляем кнопки
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const refreshBtn = document.getElementById('refreshBtn');
                if (connectBtn) {
                    connectBtn.classList.remove('hidden');
                    connectBtn.innerHTML = `<i class="fas fa-wallet"></i> <span>CONNECT</span>`;
                }
                if (disconnectBtn) {
                    disconnectBtn.classList.add('hidden');
                }
                if (refreshBtn) {
                    refreshBtn.classList.add('hidden');
                }
                // Останавливаем таймер обновления
                if (refreshTimerInterval) {
                    clearInterval(refreshTimerInterval);
                    refreshTimerInterval = null;
                }

                // Обновляем UI балансов напрямую
                const balInEl = document.getElementById('balIn');
                if (balInEl) balInEl.innerText = 'Bal: 0.0000';

                // Очищаем контейнер аудита
                const auditContainer = document.getElementById('auditContainer');
                if (auditContainer) {
                    auditContainer.innerHTML = '';
                }

                // ИСПРАВЛЕНИЕ: Восстанавливаем кнопку "CONNECT & SCAN ID" в секции аудита
                if (typeof initAudit === 'function') {
                    initAudit();
                }

                // Очищаем историю транзакций
                const historyList = document.getElementById('historyList');
                if (historyList) {
                    historyList.innerHTML = '';
                }

                // Обновляем вкладки, если нужно
                if (typeof checkBalance === 'function') {
                    checkBalance();
                }

                console.log('✅ Wallet disconnected');
                if (typeof showNotification === 'function') {
                    showNotification('Wallet disconnected', 'info');
                } else {
                    alert('Wallet disconnected');
                }

                try {
                    if (window.__fennecIdStatus && typeof window.__fennecIdStatus === 'object') {
                        window.__fennecIdStatus.loading = false;
                        window.__fennecIdStatus.hasId = false;
                        window.__fennecIdStatus.inscriptionId = '';
                        window.__fennecIdStatus.source = '';
                    }
                } catch (_) {}
                try {
                    if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();
                } catch (_) {}
            };

            window.__fennecIdStatus = window.__fennecIdStatus || {
                loading: false,
                hasId: false,
                inscriptionId: '',
                source: ''
            };

            window.getLastMintedCardForAddress = function (addr) {
                try {
                    const a = String(addr || '').trim();
                    if (!a) return null;
                    const all = JSON.parse(localStorage.getItem(fennecMintedCardsKey()) || '[]');
                    if (!Array.isArray(all) || all.length === 0) return null;
                    const filtered = all
                        .filter(x => x && typeof x === 'object' && String(x.address || '').trim() === a)
                        .sort((x, y) => (Number(y.timestamp || 0) || 0) - (Number(x.timestamp || 0) || 0));
                    return filtered[0] || null;
                } catch (_) {
                    return null;
                }
            };

            window.updateVisionFennecIdCta = function () {
                const btn = document.getElementById('visionFennecIdBtn');
                const textEl = document.getElementById('visionFennecIdBtnText');
                if (!btn || !textEl) return;

                const addr = (userAddress || window.userAddress || '').trim();
                const st =
                    window.__fennecIdStatus && typeof window.__fennecIdStatus === 'object'
                        ? window.__fennecIdStatus
                        : null;

                if (!addr) {
                    textEl.textContent = 'FENNEC ID';
                    btn.disabled = false;
                    return;
                }

                if (st && st.loading) {
                    textEl.textContent = 'SYNCING…';
                    btn.disabled = true;
                    return;
                }

                if (st && st.hasId) {
                    textEl.textContent = 'FENNEC ID';
                    btn.disabled = false;
                    return;
                }

                textEl.textContent = 'GET ID';
                btn.disabled = false;
            };

            window.refreshFennecIdStatus = async function (force = false) {
                const addr = (userAddress || window.userAddress || '').trim();
                if (!addr) {
                    if (window.__fennecIdStatus) {
                        window.__fennecIdStatus.loading = false;
                        window.__fennecIdStatus.hasId = false;
                        window.__fennecIdStatus.inscriptionId = '';
                        window.__fennecIdStatus.source = '';
                    }
                    if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();
                    return;
                }

                const st = window.__fennecIdStatus;
                if (!st || typeof st !== 'object') return;
                if (st.loading) return;

                st.loading = true;
                if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();

                try {
                    const lsKey = fennecIdKeyV2(addr);

                    const sleep = ms => new Promise(r => setTimeout(r, ms));
                    const tryKvLookup = async cacheOpt => {
                        try {
                            const kvRes = await fetch(
                                `${BACKEND_URL}?action=fennec_id_lookup&address=${encodeURIComponent(addr)}`,
                                cacheOpt
                            )
                                .then(r => (r.ok ? r.json().catch(() => null) : null))
                                .catch(() => null);
                            const kvId = String(kvRes?.data?.inscriptionId || '').trim();
                            const kvUpdatedAt = Number(kvRes?.data?.updatedAt || 0) || 0;
                            const epochMs = Date.parse(`${FENNEC_ID_EPOCH}T00:00:00Z`) || 0;
                            const kvOk = kvUpdatedAt > 0 && epochMs > 0 ? kvUpdatedAt >= epochMs : true;
                            return { kvId, kvOk };
                        } catch (_) {
                            return { kvId: '', kvOk: false };
                        }
                    };

                    let kvId = '';
                    let kvOk = false;
                    for (let attempt = 0; attempt < 3; attempt++) {
                        const cacheOpt = force || attempt > 0 ? { cache: 'no-store' } : { cache: 'force-cache' };
                        const r = await tryKvLookup(cacheOpt);
                        kvId = String(r?.kvId || '').trim();
                        kvOk = !!r?.kvOk;
                        if (kvId) break;
                        if (attempt < 2) await sleep(650);
                    }

                    if (kvId) {
                        st.hasId = true;
                        st.inscriptionId = kvId;
                        st.source = 'kv';
                        try {
                            localStorage.setItem(lsKey, kvId);
                        } catch (_) {}
                        return;
                    }

                    if (!force) {
                        const localKnown = String(localStorage.getItem(lsKey) || '').trim();
                        if (localKnown) {
                            st.hasId = true;
                            st.inscriptionId = localKnown;
                            st.source = 'localStorage_cache';
                            return;
                        }
                    }
                    const lastMint =
                        typeof window.getLastMintedCardForAddress === 'function'
                            ? window.getLastMintedCardForAddress(addr)
                            : null;
                    const lastMintId = String(lastMint?.inscriptionId || lastMint?.inscription_id || '').trim();

                    if (lastMintId) {
                        st.hasId = true;
                        st.inscriptionId = lastMintId;
                        st.source = 'minted_v2';
                        try {
                            localStorage.setItem(lsKey, lastMintId);
                        } catch (_) {}
                        return;
                    }

                    if (window.unisat && typeof window.unisat.getInscriptions === 'function') {
                        try {
                            const inscriptions = await window.unisat.getInscriptions(0, 100);
                            const list = Array.isArray(inscriptions?.list) ? inscriptions.list : [];
                            const htmlCards = list.filter(
                                i =>
                                    i &&
                                    String(i.contentType || '')
                                        .toLowerCase()
                                        .includes('text/html')
                            );
                            const isFennecChildHtml = html => {
                                const s = String(html || '');
                                if (!s) return false;
                                const hasLib = /<meta\s+name=["']fennec-lib["']\s+content=/i.test(s);
                                const hasCfg = /<meta\s+name=["']fennec-config["']\s+content=/i.test(s);
                                if (hasLib && hasCfg) return true;
                                if (/<title>\s*Fennec\s*ID\s*<\/title>/i.test(s) && /id=["']fennec-root["']/i.test(s))
                                    return true;
                                return false;
                            };
                            const fetchInscriptionHtml = async inscriptionId => {
                                const id = String(inscriptionId || '').trim();
                                if (!id) return '';
                                const url = `${BACKEND_URL}?action=inscription_content&inscriptionId=${encodeURIComponent(id)}`;
                                const res = await fetch(url, { cache: 'force-cache' });
                                if (!res.ok) return '';
                                const j = await res.json().catch(() => null);
                                const data = j && typeof j === 'object' ? j.data || null : null;
                                const html = String(data?.body || data?.contentBody || data?.content_body || '');
                                return html;
                            };
                            for (const it of htmlCards.slice(0, 50)) {
                                const id = String(it.inscriptionId || '').trim();
                                if (!id) continue;
                                const html = await fetchInscriptionHtml(id);
                                if (isFennecChildHtml(html)) {
                                    st.hasId = true;
                                    st.inscriptionId = id;
                                    st.source = 'wallet_scan';
                                    try {
                                        localStorage.setItem(lsKey, id);
                                    } catch (_) {}
                                    return;
                                }
                            }
                        } catch (_) {}
                    }

                    st.hasId = false;
                    st.inscriptionId = '';
                    st.source = '';
                } catch (e) {
                    st.hasId = false;
                    st.inscriptionId = '';
                    st.source = '';
                } finally {
                    st.loading = false;
                    if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();
                }
            };

            window.onVisionFennecIdClick = async function () {
                try {
                    window.showSection('audit');
                } catch (_) {}
                try {
                    const st =
                        window.__fennecIdStatus && typeof window.__fennecIdStatus === 'object'
                            ? window.__fennecIdStatus
                            : null;
                    // ИСПРАВЛЕНИЕ: НЕ автосинхронизируем - только по кнопке пользователя
                    // if (st && st.hasId && typeof runAudit === 'function') {
                    //     setTimeout(() => {
                    //         try {
                    //             runAudit(false);
                    //         } catch (_) {}
                    //     }, 0);
                    // }
                } catch (_) {}
                try {
                    const addr = (userAddress || window.userAddress || '').trim();
                    if (addr && typeof window.refreshFennecIdStatus === 'function') {
                        window.refreshFennecIdStatus(false);
                    }
                } catch (_) {}
            };

            try {
                if (typeof window.updateVisionFennecIdCta === 'function') window.updateVisionFennecIdCta();
            } catch (_) {}

            // ИСПРАВЛЕНИЕ: Функция запуска автообновления данных каждую минуту
            function startAutoUpdate() {
                // Останавливаем предыдущий интервал, если есть
                stopAutoUpdate();

                window.__autoUpdateWanted = true;
                console.log('🔄 Starting auto-update (120s interval)');

                autoUpdateInterval = setInterval(async () => {
                    if (!userAddress) {
                        stopAutoUpdate();
                        return;
                    }

                    console.log('🔄 Auto-updating data...');
                    try {
                        // ИСПРАВЛЕНИЕ: При ручном обновлении сбрасываем кэш swap_history
                        swapHistoryCache.data = null;
                        swapHistoryCache.timestamp = 0;

                        // ИСПРАВЛЕНИЕ: Блокируем загрузку терминала пока загружается аудит
                        if (auditLoading) {
                            console.log('⏳ Skipping terminal data load: audit is loading');
                            return;
                        }

                        // Обновляем все данные параллельно
                        await Promise.all([
                            typeof checkBalance === 'function' ? checkBalance() : Promise.resolve(),
                            typeof fetchReserves === 'function' ? fetchReserves() : Promise.resolve(),
                            typeof updatePriceData === 'function' ? updatePriceData() : Promise.resolve(),
                            typeof refreshTransactionHistory === 'function'
                                ? refreshTransactionHistory()
                                : Promise.resolve()
                        ]);

                        // ИСПРАВЛЕНИЕ: Если открыта вкладка аудита, НЕ обновляем аудит - только по кнопке пользователя
                        const auditTab = document.getElementById('tab-audit');
                        if (auditTab && auditTab.classList.contains('active')) {
                            console.log('ℹ️ Audit tab active but auto-update disabled');
                        }

                        console.log('✅ Auto-update completed');
                    } catch (e) {
                        console.warn('Auto-update error:', e);
                    }
                }, 120000); // 60 секунд = 1 минута
            }

            // ИСПРАВЛЕНИЕ: Функция остановки автообновления
            function stopAutoUpdate() {
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                    console.log('⏹️ Auto-update stopped');
                }
            }

            // ИСПРАВЛЕНИЕ: Функция обновления аудита (принудительное)
            window.refreshAudit = function () {
                if (!userAddress) {
                    if (typeof showNotification === 'function') {
                        showNotification('Connect wallet first', 'warning', 2000);
                    }
                    return;
                }
                if (auditLoading) {
                    if (typeof showNotification === 'function') {
                        showNotification('Audit is already loading', 'warning', 2000);
                    }
                    return;
                }
                // Очищаем кэш и запускаем загрузку
                const cacheKey = `audit_${userAddress}`;
                localStorage.removeItem(cacheKey);
                runAudit(true); // forceRefresh = true
            };

            // ИСПРАВЛЕНИЕ: Ручное обновление данных (с защитой от слишком частых обновлений)
            let lastRefreshTime = 0;
            const MIN_REFRESH_INTERVAL = 60000; // 60 секунд между обновлениями
            let refreshTimerInterval = null;

            window.manualRefresh = async function () {
                const now = Date.now();
                const timeSinceLastRefresh = now - lastRefreshTime;

                // Проверяем, прошло ли достаточно времени
                if (timeSinceLastRefresh < MIN_REFRESH_INTERVAL) {
                    const remainingSeconds = Math.ceil((MIN_REFRESH_INTERVAL - timeSinceLastRefresh) / 1000);
                    showNotification(`Please wait ${remainingSeconds}s before refreshing again`, 'warning', 2000);
                    return;
                }

                if (!userAddress && !window.userAddress) {
                    showNotification('Connect wallet first', 'warning', 2000);
                    return;
                }

                // Обновляем время последнего обновления
                lastRefreshTime = now;

                // Обновляем UI кнопки (header)
                const refreshBtn = document.getElementById('refreshBtn');
                const refreshIcon = document.getElementById('refreshIcon');
                const refreshText = document.getElementById('refreshText');
                const refreshTimer = document.getElementById('refreshTimer');

                if (refreshBtn) {
                    refreshBtn.disabled = true;
                    refreshBtn.classList.add('opacity-50', 'cursor-not-allowed');
                }
                if (refreshIcon) {
                    refreshIcon.classList.add('fa-spin');
                }
                if (refreshText) {
                    refreshText.textContent = 'UPDATING...';
                }

                try {
                    console.log('🔄 Manual refresh started...');

                    // ИСПРАВЛЕНИЕ: При ручном обновлении сбрасываем кэш swap_history
                    swapHistoryCache.data = null;
                    swapHistoryCache.timestamp = 0;

                    // Обновляем все данные (БЕЗ аудита - аудит обновляется отдельно)
                    await Promise.all([
                        typeof checkBalance === 'function' ? checkBalance() : Promise.resolve(),
                        typeof fetchReserves === 'function' ? fetchReserves() : Promise.resolve(),
                        typeof updatePriceData === 'function' ? updatePriceData() : Promise.resolve(),
                        typeof refreshTransactionHistory === 'function'
                            ? refreshTransactionHistory()
                            : Promise.resolve()
                    ]);

                    // ИСПРАВЛЕНИЕ: Аудит НЕ обновляется автоматически - пользователь обновляет его отдельной кнопкой

                    showNotification('Data refreshed successfully', 'success', 2000);
                    console.log('✅ Manual refresh completed');

                    // Запускаем таймер обратного отсчета
                    startRefreshTimer();
                } catch (e) {
                    console.error('❌ Manual refresh error:', e);
                    showNotification('Refresh failed: ' + (e.message || 'Unknown error'), 'error', 3000);
                } finally {
                    // Восстанавливаем UI кнопки (но оставляем disabled до окончания таймера)
                    if (refreshIcon) {
                        refreshIcon.classList.remove('fa-spin');
                    }
                    if (refreshText) {
                        refreshText.textContent = 'REFRESH';
                    }
                }
            };

            // Таймер обратного отсчета для кнопки обновления
            function startRefreshTimer() {
                if (refreshTimerInterval) {
                    clearInterval(refreshTimerInterval);
                }

                const refreshTimer = document.getElementById('refreshTimer');
                const refreshBtn = document.getElementById('refreshBtn');

                if (!refreshTimer || !refreshBtn) return;

                let remainingSeconds = MIN_REFRESH_INTERVAL / 1000;
                refreshTimer.classList.remove('hidden');
                refreshTimer.textContent = `(${remainingSeconds}s)`;
                refreshBtn.disabled = true;
                refreshBtn.classList.add('opacity-50', 'cursor-not-allowed');

                refreshTimerInterval = setInterval(() => {
                    remainingSeconds--;
                    if (remainingSeconds <= 0) {
                        clearInterval(refreshTimerInterval);
                        refreshTimerInterval = null;
                        refreshTimer.classList.add('hidden');
                        refreshBtn.disabled = false;
                        refreshBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    } else {
                        refreshTimer.textContent = `(${remainingSeconds}s)`;
                    }
                }, 1000);
            }

            window.toggleChat = function () {
                const win = document.getElementById('chatWindow');
                if (!win) return;
                win.classList.toggle('hidden');
                if (!win.classList.contains('hidden')) {
                    win.classList.remove('scale-90', 'opacity-0');
                    if (typeof renderChatHistory === 'function') {
                        renderChatHistory();
                    }
                    const input = document.getElementById('chatInput');
                    if (input) input.focus();
                } else {
                    win.classList.add('scale-90', 'opacity-0');
                }
            };

            // Now define constants and variables
            const BACKEND_URL = window.location.hostname.includes('vercel.app')
                ? '/api/proxy' // Vercel serverless function
                : window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost'
                  ? 'http://127.0.0.1:8787' // Local wrangler dev
                  : 'https://fennec-api.warninghejo.workers.dev'; // Cloudflare Worker fallback
            const FENNEC_ID_VERSION = '6.0';
            const MINT_CHILD_FENNEC_LIB = String(localStorage.getItem('fennec_mint_child_lib') || '').trim();
            const MINT_CHILD_FENNEC_CONFIG = String(localStorage.getItem('fennec_mint_child_config') || '').trim();
            const MINT_CHILD_FENNEC_MANIFEST = String(localStorage.getItem('fennec_mint_child_manifest') || '').trim();
            const FALLBACK_CHILD_LIB = 'ec53f51e93f5d510cc8ba134b25ee016a8cae85294f18d8844b2469ef15e189di0';
            const FALLBACK_CHILD_CONFIG = 'e40e1bba154f3f5421ab727d6a92e92b10eda1670a122e293d6f8ce8867b54afi0';
            const FALLBACK_MANIFEST_REF = 'https://fennecbtc.xyz/recursive_inscriptions/fennec_manifest_live.json';
            const DEFAULT_MANIFEST_URL = 'https://fennecbtc.xyz/recursive_inscriptions/fennec_manifest_live.json';
            const T_SFB = 'sFB___000';
            const T_FENNEC = 'FENNEC';
            const T_BTC = 'BTC';
            const T_SBTC = 'sBTC___000'; // ВАЖНО: Правильный тикер для пула sBTC/FB

            async function safeFetchJson(url, options = {}) {
                const method = options.method || 'GET';
                const headers = options.headers;
                const body = options.body;
                const timeoutMs = typeof options.timeoutMs === 'number' ? options.timeoutMs : 12000;
                const retries = typeof options.retries === 'number' ? options.retries : 2;
                const retryDelayMs = typeof options.retryDelayMs === 'number' ? options.retryDelayMs : 700;

                let lastErr;
                for (let attempt = 0; attempt <= retries; attempt++) {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                    try {
                        const res = await fetch(url, { method, headers, body, signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (!res.ok) {
                            lastErr = new Error(`HTTP ${res.status} ${res.statusText}`);
                            if (attempt < retries) {
                                await new Promise(r => setTimeout(r, retryDelayMs * Math.pow(2, attempt)));
                                continue;
                            }
                            return null;
                        }

                        return await res.json();
                    } catch (e) {
                        clearTimeout(timeoutId);
                        lastErr = e;
                        if (attempt < retries) {
                            await new Promise(r => setTimeout(r, retryDelayMs * Math.pow(2, attempt)));
                            continue;
                        }
                        console.warn('safeFetchJson failed:', url, lastErr);
                        return null;
                    }
                }
                return null;
            }

            const REQUIRED_NETWORK = 'FRACTAL_BITCOIN_MAINNET';
            let userAddress = null,
                userPubkey = null,
                isBuying = true;
            let switchWalletConfirmed = false; // Флаг подтверждения переключения кошелька
            let autoUpdateInterval = null; // Интервал автообновления данных
            let depositToken = 'BTC',
                withdrawToken = 'sFB';
            let poolReserves = { sFB: 0, FENNEC: 0, BTC: 0, user_sBTC: 0 };
            let currentSwapPair = 'FB_FENNEC'; // 'FB_FENNEC' or 'BTC_FB'
            let userBalances = { sFB: 0, FENNEC: 0, BTC: 0 };
            let walletBalances = { sFB: 0, FENNEC: 0, BTC: 0 };
            let selectedInscriptions = [];
            let chartTimeframe = '7d';
            let priceChart = null;
            let priceHistory = [];
            let burrowLoop = null;
            let auditIdentity = null;
            let auditLoading = false; // ИСПРАВЛЕНИЕ: Флаг активного аудита, чтобы не запускать повторно во время выполнения
            let currentAuditRequestId = 0; // ИСПРАВЛЕНИЕ: Отслеживание текущего запроса для предотвращения race condition
            let currentAuditAbortController = null; // ИСПРАВЛЕНИЕ: AbortController для отмены предыдущих запросов
            let prefetchedFennecAudit = null;
            let prefetchedFennecAuditAddr = null;
            let prefetchedFennecAuditTs = 0;

            const FENNEC_ID_EPOCH = '2025-12-27';
            const fennecIdKeyV2 = addr => `fennec_id_child_v2_${String(addr || '').trim()}`;
            const fennecMintedCardsKey = () => `fennec_minted_cards_v2_${FENNEC_ID_EPOCH}`;

            function ensureMetaTag(name, value) {
                if (!name) return;
                const v = String(value || '').trim();
                let el = document.querySelector(`meta[name="${name}"]`);
                if (!el) {
                    el = document.createElement('meta');
                    el.setAttribute('name', name);
                    document.head.appendChild(el);
                }
                el.setAttribute('content', v);
            }

            window.setDebugAuditIdentity = function (identity) {
                try {
                    auditIdentity = identity;
                    if (identity && identity.metrics) {
                        identity.metrics.address = identity.metrics.address || userAddress || window.userAddress || '';
                    }
                    if (typeof renderAudit === 'function') {
                        renderAudit(identity);
                    }
                    if (typeof switchTab === 'function') {
                        switchTab('audit');
                    }
                } catch (e) {
                    console.error('setDebugAuditIdentity error:', e);
                }
            };
            let currentLang = 'en';
            let depositFeeRate = 2; // Default medium fee
            let withdrawFeeRate = 2; // Default medium fee
            let fractalFees = { fastestFee: 1, halfHourFee: 1, hourFee: 1 }; // Cached fees

            // Language translations
            const LANG = {
                en: {
                    swap_action: 'GET FENNEC',
                    swap_sell: 'SELL FENNEC',
                    swap_bridge: 'BRIDGE BTC 🌉'
                },
                cn: {
                    swap_action: '获取 FENNEC',
                    swap_sell: '卖出 FENNEC',
                    swap_bridge: '桥接 BTC 🌉'
                }
            };

            // ===== NETWORK CHECK FUNCTION (NO AUTO-SWITCH) =====
            async function checkFractalNetwork() {
                try {
                    const currentChain = await window.unisat.getChain();
                    console.log('🌐 Current network:', currentChain);

                    // UniSat returns string or object with enum property
                    const chainName =
                        typeof currentChain === 'string' ? currentChain : currentChain?.enum || currentChain;

                    if (chainName !== REQUIRED_NETWORK) {
                        throw new Error(
                            `⚠️ Please switch to Fractal Bitcoin Mainnet in your UniSat wallet.\nCurrent: ${chainName}`
                        );
                    }

                    console.log('✅ Network OK:', REQUIRED_NETWORK);
                    return true;
                } catch (e) {
                    console.error('❌ Network check failed:', e);
                    throw e;
                }
            }

            // ===== FORCE SWITCH NETWORK =====
            async function switchToFractal() {
                try {
                    console.log('🔄 Switching to Fractal mainnet...');
                    await window.unisat.switchChain(REQUIRED_NETWORK);
                    await new Promise(r => setTimeout(r, 2000)); // Wait 2 sec

                    const verify = await window.unisat.getChain();
                    console.log('✅ Network after switch:', verify);
                    return verify.enum === REQUIRED_NETWORK;
                } catch (e) {
                    console.error('❌ Switch failed:', e);
                    return false;
                }
            }
            let activeTickers = { tick0: '', tick1: '' };

            // Кэширование для оптимизации
            let poolCache = { data: null, timestamp: 0, ttl: 30000 }; // 30 сек
            let balanceCache = { data: {}, timestamp: {}, ttl: 15000 }; // 15 сек
            let currentTheme = localStorage.getItem('fennec_theme') || 'dark';

            // Переводы
            const translations = {
                en: {
                    connect: 'Connect',
                    swap: 'Swap',
                    deposit: 'Deposit',
                    withdraw: 'Withdraw',
                    youPay: 'YOU PAY',
                    youReceive: 'YOU RECEIVE',
                    balance: 'Balance',
                    rate: 'Rate',
                    pool: 'Pool',
                    active: 'Active',
                    swapTokens: 'SWAP TOKENS',
                    depositBtn: 'DEPOSIT',
                    withdrawBtn: 'WITHDRAW',
                    recentActivity: 'Recent Activity',
                    roadmap: 'Roadmap',
                    priceChart: 'Price Chart'
                },
                cn: {
                    connect: '连接',
                    swap: '兑换',
                    deposit: '存入',
                    withdraw: '提取',
                    youPay: '支付',
                    youReceive: '接收',
                    balance: '余额',
                    rate: '汇率',
                    pool: '池',
                    active: '活跃',
                    swapTokens: '兑换代币',
                    depositBtn: '存入',
                    withdrawBtn: '提取',
                    recentActivity: '最近活动',
                    roadmap: '路线图',
                    priceChart: '价格图表'
                }
            };

            function toggleTheme() {
                currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', currentTheme);
                localStorage.setItem('fennec_theme', currentTheme);

                const icon = document.getElementById('themeIcon');
                icon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';

                // Уведомление
                showNotification(currentTheme === 'dark' ? '🌙 Dark Mode' : '☀️ Light Mode');
            }

            function toggleLanguage() {
                currentLang = 'en';
                localStorage.setItem('fennec_lang', 'en');
                updateLanguage();
                // Обновляем элементы с data-t
                document.querySelectorAll('[data-t]').forEach(el => {
                    const key = el.getAttribute('data-t');
                    if (LANG && LANG.en && LANG.en[key]) el.innerText = LANG.en[key];
                });
                showNotification('English only');
            }

            function updateLanguage() {
                document.querySelectorAll('[data-lang-key]').forEach(el => {
                    const key = el.getAttribute('data-lang-key');
                    if (translations[currentLang][key]) {
                        el.innerText = translations[currentLang][key];
                    }
                });
            }

            // Инициализация темы
            document.documentElement.setAttribute('data-theme', currentTheme);
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) {
                themeIcon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }
            const langBtn = document.getElementById('langBtn');
            if (langBtn) {
                langBtn.innerText = currentLang.toUpperCase();
            }

            // UI language is EN-only
            currentLang = 'en';
            localStorage.setItem('fennec_lang', 'en');
            updateLanguage();
            document.querySelectorAll('[data-t]').forEach(el => {
                const key = el.getAttribute('data-t');
                if (LANG && LANG.en && LANG.en[key]) el.innerText = LANG.en[key];
            });

            // История транзакций
            function addToHistory(type, amount, token, txid) {
                const history = JSON.parse(localStorage.getItem('fennec_history') || '[]');
                history.unshift({
                    type,
                    amount,
                    token,
                    txid: txid || 'pending',
                    timestamp: Date.now()
                });
                // Храним только последние 5
                if (history.length > 5) history.pop();
                localStorage.setItem('fennec_history', JSON.stringify(history));
            }

            function showHistory() {
                const history = JSON.parse(localStorage.getItem('fennec_history') || '[]');
                if (history.length === 0) return '';
                return history
                    .map(tx => {
                        const time = new Date(tx.timestamp).toLocaleTimeString('ru-RU', {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        const emoji = tx.type === 'swap' ? '🔄' : tx.type === 'deposit' ? '⬇️' : '⬆️';
                        return `<div class="flex justify-between items-center py-2 border-b border-white/5 text-xs">
                                                                <span>${emoji} ${tx.type.toUpperCase()}</span>
                                                                <span class="text-fennec">${tx.amount} ${tx.token}</span>
                                                                <span class="text-gray-500">${time}</span>
                                                            </div>`;
                    })
                    .join('');
            }

            function updateHistoryUI() {
                const html = showHistory();
                const section = document.getElementById('historySection');
                const list = document.getElementById('historyList');
                if (html) {
                    list.innerHTML = html;
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }
            }

            // Улучшенная валидация
            function validateAmount(amount, type, token) {
                if (!amount || isNaN(amount) || amount <= 0) {
                    return { valid: false, error: '❌ Please enter a valid amount' };
                }

                // Минимальные суммы
                const minAmounts = { swap: 0.00001, deposit: 1, withdraw: 1 };
                if (amount < minAmounts[type]) {
                    return { valid: false, error: `⚠️ Minimum ${type} amount: ${minAmounts[type]} ${token}` };
                }

                // Проверка баланса
                if (type === 'swap') {
                    const bal = isBuying ? userBalances.sFB : userBalances.FENNEC;
                    if (amount > bal) {
                        return { valid: false, error: '💰 Insufficient balance. Go to Deposit tab.' };
                    }
                } else if (type === 'withdraw') {
                    const bal = token === 'FB' ? userBalances.sFB : userBalances.FENNEC;
                    if (amount > bal) {
                        return { valid: false, error: '💰 Insufficient balance on InSwap' };
                    }
                }

                return { valid: true };
            }

            function showError(message) {
                document.getElementById('errorMsg').innerText = message;
                document.getElementById('errorModal').classList.remove('hidden');
            }

            function showSuccess(message) {
                document.getElementById('successTxId').innerText = message;
                document.getElementById('successModal').classList.remove('hidden');
            }

            async function refreshBalancesInline() {
                try {
                    await Promise.all([
                        typeof fetchReserves === 'function' ? fetchReserves() : Promise.resolve(),
                        userAddress && typeof checkBalance === 'function' ? checkBalance() : Promise.resolve()
                    ]);
                } catch (_) {}
            }

            // Система уведомлений
            function showNotification(message, type = 'info', duration = 3000) {
                const container = document.getElementById('notificationsContainer');
                const notification = document.createElement('div');
                notification.className = 'notification';

                const icons = {
                    success: '✅',
                    error: '❌',
                    info: 'ℹ️',
                    warning: '⚠️',
                    swap: '🔄',
                    deposit: '⬇️',
                    withdraw: '⬆️'
                };

                const colors = {
                    success: '#10b981',
                    error: '#ef4444',
                    info: '#3b82f6',
                    warning: '#f59e0b',
                    swap: '#FF6B35',
                    deposit: '#10b981',
                    withdraw: '#f59e0b'
                };

                notification.innerHTML = `
                                                            <div class="flex items-center gap-3">
                                                                <div class="text-2xl">${icons[type] || icons.info}</div>
                                                                <div class="flex-1">
                                                                    <div class="font-bold text-sm" style="color: ${colors[type] || colors.info}">${message}</div>
                                                                    <div class="text-xs" style="color: var(--text-muted)">${new Date().toLocaleTimeString()}</div>
                                                                </div>
                                                            </div>
                                                        `;

                container.appendChild(notification);

                // Auto-remove
                setTimeout(() => {
                    notification.classList.add('exit');
                    setTimeout(() => notification.remove(), 300);
                }, duration);
            }

            function switchTab(tab) {
                document.querySelectorAll('.tab-content').forEach(el => {
                    el.classList.remove('active');
                    el.classList.add('hidden');
                });
                document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
                const targetView = document.getElementById(`view-${tab}`);
                const targetTab = document.getElementById(`tab-${tab}`);
                if (targetView) {
                    targetView.classList.remove('hidden');
                    targetView.classList.add('active');
                }
                if (targetTab) targetTab.classList.add('active');
                // ИСПРАВЛЕНИЕ: Обновляем данные только при переключении табов (действие пользователя)
                if (tab === 'deposit') {
                    setDepositToken(depositToken);
                    loadFees('deposit');
                    checkBalance(); // Обновляем баланс при переключении на deposit
                    refreshTransactionHistory();
                }
                if (tab === 'withdraw') {
                    updateWithdrawUI();
                    loadFees('withdraw');
                    checkBalance(); // Обновляем баланс при переключении на withdraw
                    refreshTransactionHistory();
                }
                if (tab === 'swap') {
                    fetchReserves(); // Обновляем резервы при переключении на swap
                    checkBalance(); // Обновляем баланс
                    refreshTransactionHistory();
                    checkWhales(); // Проверяем whale транзакции
                }
                if (tab === 'pending') {
                    refreshPendingOperations();
                }
            }

            // ИСПРАВЛЕНИЕ: Функция для добавления pending операции (минт, инскрипции и т.д.)
            function addPendingOperation(operation) {
                try {
                    const pendingOps = JSON.parse(localStorage.getItem('pending_operations') || '[]');
                    // Проверяем, нет ли уже такой операции
                    const opOrderId = String(operation?.orderId || '').trim();
                    const exists = pendingOps.find(op => {
                        if (!op || typeof op !== 'object') return false;
                        if (String(op.type || '') !== String(operation?.type || '')) return false;
                        const existingOrderId = String(op.orderId || '').trim();
                        if (!existingOrderId || !opOrderId) return false;
                        return existingOrderId === opOrderId;
                    });
                    if (!exists) {
                        pendingOps.push(operation);
                        localStorage.setItem('pending_operations', JSON.stringify(pendingOps));
                        // Обновляем UI
                        if (typeof refreshPendingOperations === 'function') {
                            refreshPendingOperations();
                        }
                        try {
                            if (typeof checkPendingMints === 'function') {
                                setTimeout(() => {
                                    try {
                                        checkPendingMints();
                                    } catch (_) {}
                                }, 2500);
                            }
                        } catch (_) {}
                    }
                } catch (e) {
                    console.error('Failed to add pending operation:', e);
                }
            }

            function queueFennecIdRegister(entry) {
                try {
                    const address = String(entry?.address || '').trim();
                    const inscriptionId = String(entry?.inscriptionId || entry?.inscription_id || '').trim();
                    if (!address || !inscriptionId) return;
                    const key = 'fennec_id_register_queue_v2';
                    const q = JSON.parse(localStorage.getItem(key) || '[]');
                    const arr = Array.isArray(q) ? q : [];
                    const exists = arr.some(
                        x =>
                            x &&
                            String(x.address || '').trim() === address &&
                            String(x.inscriptionId || '').trim() === inscriptionId
                    );
                    if (exists) return;
                    arr.push({ address, inscriptionId, ts: Date.now(), attempts: 0 });
                    localStorage.setItem(key, JSON.stringify(arr));

                    try {
                        if (typeof processFennecIdRegisterQueue === 'function') {
                            setTimeout(() => {
                                try {
                                    processFennecIdRegisterQueue();
                                } catch (_) {}
                            }, 1200);
                        }
                    } catch (_) {}
                } catch (_) {}
            }

            async function processFennecIdRegisterQueue() {
                try {
                    const key = 'fennec_id_register_queue_v2';
                    const raw = localStorage.getItem(key) || '[]';
                    const q = JSON.parse(raw);
                    const arr = Array.isArray(q) ? q : [];
                    if (!arr.length) return;

                    const now = Date.now();
                    const keep = [];
                    for (const it of arr) {
                        const address = String(it?.address || '').trim();
                        const inscriptionId = String(it?.inscriptionId || '').trim();
                        const attempts = Number(it?.attempts || 0) || 0;
                        const ts = Number(it?.ts || 0) || now;
                        const ageMs = now - ts;
                        if (!address || !inscriptionId) continue;
                        if (attempts >= 10 || ageMs > 24 * 60 * 60 * 1000) continue;

                        try {
                            const res = await fetch(`${BACKEND_URL}?action=fennec_id_register`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ address, inscriptionId })
                            }).catch(() => null);
                            const j = res ? await res.json().catch(() => null) : null;
                            if (j && j.code === 0) {
                                try {
                                    const lsKey = fennecIdKeyV2(address);
                                    localStorage.setItem(lsKey, inscriptionId);
                                } catch (_) {}
                                continue;
                            }

                            try {
                                const msg = String(j?.msg || j?.error || '').trim();
                                if (msg) {
                                    console.warn('[fennec_id_register] failed:', {
                                        address,
                                        inscriptionId,
                                        attempts,
                                        msg,
                                        status: res?.status
                                    });
                                    if (
                                        !window.__fennecWarnedKvMissing &&
                                        /FENNEC_DB\s+is\s+not\s+configured/i.test(msg)
                                    ) {
                                        window.__fennecWarnedKvMissing = 1;
                                        if (typeof showNotification === 'function') {
                                            showNotification(
                                                'Server KV (FENNEC_DB) is not configured — ID sync disabled.',
                                                'error',
                                                6500
                                            );
                                        }
                                    }

                                    if (
                                        !window.__fennecWarnedUniSatKeyMissing &&
                                        /UNISAT_API_KEY\s+is\s+not\s+configured/i.test(msg)
                                    ) {
                                        window.__fennecWarnedUniSatKeyMissing = 1;
                                        if (typeof showNotification === 'function') {
                                            showNotification(
                                                'Server UNISAT_API_KEY is missing — ID sync disabled.',
                                                'error',
                                                6500
                                            );
                                        }
                                    }
                                }
                            } catch (_) {}

                            keep.push({ address, inscriptionId, ts, attempts: attempts + 1 });
                        } catch (_) {}
                    }
                    localStorage.setItem(key, JSON.stringify(keep));
                } catch (_) {}
            }

            // Проверка статуса минт-ордеров
            async function checkPendingMints() {
                try {
                    try {
                        await processFennecIdRegisterQueue();
                    } catch (_) {}
                    const pendingOps = JSON.parse(localStorage.getItem('pending_operations') || '[]');
                    const mints = pendingOps.filter(
                        op => op.type === 'mint' && (op.status === 'pending' || op.status === 'inscribing')
                    );

                    if (mints.length === 0) return;

                    for (const mint of mints) {
                        try {
                            const res = await fetch(`${BACKEND_URL}?action=inscription_status&orderId=${mint.orderId}`);

                            // Проверяем статус ответа
                            if (!res.ok) {
                                // 400/404 бывает временно сразу после создания ордера.
                                // Не удаляем мгновенно, а ждём несколько попыток/таймаут.
                                if (res.status === 400 || res.status === 404) {
                                    const idx = pendingOps.findIndex(
                                        op =>
                                            op &&
                                            op.type === 'mint' &&
                                            String(op.orderId || '') === String(mint.orderId || '')
                                    );
                                    if (idx >= 0) {
                                        const now = Date.now();
                                        const ts = Number(pendingOps[idx].timestamp || 0) || now;
                                        const ageMs = now - ts;
                                        const prev = Number(pendingOps[idx].notFoundCount || 0) || 0;
                                        pendingOps[idx].notFoundCount = prev + 1;
                                        pendingOps[idx].lastNotFoundAt = now;
                                        localStorage.setItem('pending_operations', JSON.stringify(pendingOps));

                                        const MAX_NOT_FOUND = 6;
                                        const MIN_AGE_TO_DROP_MS = 10 * 60 * 1000;
                                        if (
                                            pendingOps[idx].notFoundCount >= MAX_NOT_FOUND &&
                                            ageMs > MIN_AGE_TO_DROP_MS
                                        ) {
                                            const updated = pendingOps.filter(
                                                op => !(op.orderId === mint.orderId && op.type === 'mint')
                                            );
                                            localStorage.setItem('pending_operations', JSON.stringify(updated));
                                            console.log(
                                                `⚠️ Order ${mint.orderId} not found after ${pendingOps[idx].notFoundCount} attempts, removed from pending`
                                            );
                                        }
                                        if (typeof refreshPendingOperations === 'function') {
                                            refreshPendingOperations();
                                        }
                                    }
                                }
                                continue;
                            }

                            const data = await res.json();

                            if (data.code === 0 && data.data) {
                                const status = data.data.status;
                                const files = data.data.files || [];
                                let inscriptionId = null;
                                if (files.length > 0 && files[0].inscriptionId) {
                                    inscriptionId = files[0].inscriptionId;
                                } else {
                                    inscriptionId =
                                        data.data.inscriptionId ||
                                        data.data.inscription?.inscriptionId ||
                                        data.data.inscriptionIdList?.[0];
                                }

                                if (status === 'minted' || (inscriptionId && inscriptionId.length > 10)) {
                                    // Минт завершен - удаляем из pending
                                    const updated = pendingOps.filter(
                                        op => !(op.orderId === mint.orderId && op.type === 'mint')
                                    );
                                    localStorage.setItem('pending_operations', JSON.stringify(updated));
                                    console.log(
                                        `✅ Mint order ${mint.orderId} completed with inscription ${inscriptionId}`
                                    );

                                    try {
                                        const mintAddr = String(mint.address || '').trim();
                                        if (mintAddr && inscriptionId) {
                                            localStorage.setItem(fennecIdKeyV2(mintAddr), String(inscriptionId));
                                        }
                                    } catch (_) {}

                                    try {
                                        const mintAddr = String(mint.address || '').trim();
                                        if (mintAddr && inscriptionId)
                                            queueFennecIdRegister({ address: mintAddr, inscriptionId });
                                    } catch (_) {}

                                    try {
                                        if (typeof window.refreshFennecIdStatus === 'function') {
                                            window.refreshFennecIdStatus(true);
                                        }
                                    } catch (_) {}

                                    try {
                                        const allMints = JSON.parse(
                                            localStorage.getItem(fennecMintedCardsKey()) || '[]'
                                        );
                                        if (Array.isArray(allMints) && allMints.length) {
                                            let changed = false;
                                            for (const m of allMints) {
                                                if (!m || typeof m !== 'object') continue;
                                                if (String(m.orderId || '') !== String(mint.orderId || '')) continue;
                                                if (inscriptionId && inscriptionId.length > 10) {
                                                    m.inscriptionId = inscriptionId;
                                                }
                                                m.status = 'minted';
                                                changed = true;
                                            }
                                            if (changed) {
                                                localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(allMints));
                                            }
                                        }
                                    } catch (e) {}

                                    // Обновляем UI
                                    if (typeof refreshPendingOperations === 'function') {
                                        refreshPendingOperations();
                                    }
                                    if (typeof initAudit === 'function') {
                                        initAudit();
                                    }
                                } else if (status === 'inscribing') {
                                    // Обновляем статус
                                    const idx = pendingOps.findIndex(
                                        op => op.orderId === mint.orderId && op.type === 'mint'
                                    );
                                    if (idx >= 0) {
                                        pendingOps[idx].status = 'inscribing';
                                        if (inscriptionId && inscriptionId.length > 10) {
                                            pendingOps[idx].inscriptionId = inscriptionId;
                                        }
                                        localStorage.setItem('pending_operations', JSON.stringify(pendingOps));
                                    }

                                    try {
                                        const allMints = JSON.parse(
                                            localStorage.getItem(fennecMintedCardsKey()) || '[]'
                                        );
                                        if (Array.isArray(allMints) && allMints.length) {
                                            let changed = false;
                                            for (const m of allMints) {
                                                if (!m || typeof m !== 'object') continue;
                                                if (String(m.orderId || '') !== String(mint.orderId || '')) continue;
                                                m.status = 'inscribing';
                                                if (inscriptionId && inscriptionId.length > 10) {
                                                    m.inscriptionId = inscriptionId;
                                                }
                                                changed = true;
                                            }
                                            if (changed) {
                                                localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(allMints));
                                            }
                                        }
                                    } catch (e) {}
                                } else if (status === 'closed' || status === 'refunded') {
                                    const updated = pendingOps.filter(
                                        op => !(op.orderId === mint.orderId && op.type === 'mint')
                                    );
                                    localStorage.setItem('pending_operations', JSON.stringify(updated));
                                    if (typeof refreshPendingOperations === 'function') {
                                        refreshPendingOperations();
                                    }

                                    try {
                                        const allMints = JSON.parse(
                                            localStorage.getItem(fennecMintedCardsKey()) || '[]'
                                        );
                                        if (Array.isArray(allMints) && allMints.length) {
                                            let changed = false;
                                            for (const m of allMints) {
                                                if (!m || typeof m !== 'object') continue;
                                                if (String(m.orderId || '') !== String(mint.orderId || '')) continue;
                                                m.status = status;
                                                changed = true;
                                            }
                                            if (changed) {
                                                localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(allMints));
                                            }
                                        }
                                    } catch (e) {}
                                }
                            }
                        } catch (err) {
                            // Тихо пропускаем ошибки сети
                        }
                    }
                } catch (e) {
                    // Игнорируем ошибки парсинга localStorage
                }
            }

            // Запускаем проверку каждые 2 минуты (экономим воркер)
            setInterval(checkPendingMints, 120000);
            // Проверяем сразу при загрузке
            setTimeout(checkPendingMints, 3000);

            // REFRESH PENDING OPERATIONS
            async function refreshPendingOperations() {
                const pendingEl = document.getElementById('pendingOperations');
                if (!pendingEl) return;

                try {
                    // Get pending inscriptions from localStorage
                    const pendingInscriptions = JSON.parse(localStorage.getItem('pending_inscriptions') || '[]');
                    const activeInscriptions = pendingInscriptions.filter(
                        p => p.status !== 'ready' && p.status !== 'failed'
                    );

                    // ИСПРАВЛЕНИЕ: Get pending operations (минты) from localStorage
                    const pendingOperations = JSON.parse(localStorage.getItem('pending_operations') || '[]');
                    const activeMints = pendingOperations.filter(
                        p => p.status === 'pending' || p.status === 'inscribing'
                    );

                    // Get pending deposits/withdrawals from API (if user is connected)
                    let pendingDeposits = [];
                    let pendingWithdrawals = [];

                    if (userAddress) {
                        try {
                            const depositRes = await fetch(
                                `${BACKEND_URL}?action=deposit_list&address=${userAddress}&start=0&limit=10`
                            ).then(r => r.json());
                            if (depositRes.code === 0 && depositRes.data?.list) {
                                pendingDeposits = depositRes.data.list.filter(d => {
                                    const cur = d.cur || 0;
                                    const sum = d.sum || 0;
                                    return cur < sum; // Not fully confirmed
                                });
                            }
                        } catch (e) {
                            console.warn('Failed to fetch pending deposits:', e);
                        }

                        try {
                            const withdrawRes = await fetch(
                                `${BACKEND_URL}?action=withdraw_history&address=${userAddress}&start=0&limit=10`
                            ).then(r => r.json());
                            if (withdrawRes.code === 0 && withdrawRes.data?.list) {
                                pendingWithdrawals = withdrawRes.data.list.filter(w => {
                                    const cur = w.cur || 0;
                                    const sum = w.sum || 0;
                                    return cur < sum; // Not fully confirmed
                                });
                            }
                        } catch (e) {
                            console.warn('Failed to fetch pending withdrawals:', e);
                        }
                    }

                    const allPending = [
                        ...activeInscriptions.map(p => ({ ...p, type: 'inscription', sortTime: p.createdAt || 0 })),
                        ...activeMints.map(m => ({ ...m, type: 'mint', sortTime: m.timestamp || 0 })),
                        ...pendingDeposits.map(d => ({ ...d, type: 'deposit', sortTime: (d.ts || 0) * 1000 })),
                        ...pendingWithdrawals.map(w => ({ ...w, type: 'withdraw', sortTime: (w.ts || 0) * 1000 }))
                    ].sort((a, b) => b.sortTime - a.sortTime); // Sort by time, newest first

                    if (allPending.length === 0) {
                        pendingEl.innerHTML = `
                                                                    <div class="text-center py-8 text-gray-500 text-xs">
                                                                        <i class="fas fa-check-circle text-3xl mb-3 opacity-50 text-green-500"></i>
                                                                        <p>No pending operations</p>
                                                                        <p class="text-[10px] mt-2 text-gray-600">All operations are completed</p>
                                                                    </div>
                                                                `;
                        return;
                    }

                    // Group by type
                    const inscriptions = allPending.filter(o => o.type === 'inscription');
                    const mints = allPending.filter(o => o.type === 'mint');
                    const deposits = allPending.filter(o => o.type === 'deposit');
                    const withdrawals = allPending.filter(o => o.type === 'withdraw');

                    let html = '';

                    // ИСПРАВЛЕНИЕ: Mints (минт карточек)
                    if (mints.length > 0) {
                        html += '<div class="text-xs text-gray-500 mb-2 font-bold uppercase">Minting ID Cards</div>';
                        html += mints
                            .map(op => {
                                const statusIcon =
                                    op.status === 'pending'
                                        ? 'fa-clock'
                                        : op.status === 'inscribing'
                                          ? 'fa-spinner fa-spin'
                                          : 'fa-hourglass-half';
                                const statusColor =
                                    op.status === 'pending'
                                        ? 'text-yellow-500'
                                        : op.status === 'inscribing'
                                          ? 'text-blue-500'
                                          : 'text-gray-500';
                                let sizeKB = '';
                                try {
                                    const base64Content = btoa(unescape(encodeURIComponent(op.htmlCode || '')));
                                    const base64SizeBytes = (base64Content.length * 3) / 4;
                                    sizeKB = (base64SizeBytes / 1024).toFixed(2);
                                } catch (e) {}
                                return `
                                                                        <div class="bg-black/30 border border-white/5 rounded-lg p-4 mb-2">
                                                                            <div class="flex items-center justify-between">
                                                                                <div class="flex items-center gap-3">
                                                                                    <i class="fas ${statusIcon} ${statusColor} text-xl"></i>
                                                                                    <div>
                                                                                        <div class="text-sm font-bold text-white">Minting Fennec ID Card</div>
                                                                                        <div class="text-xs text-gray-400">Order ID: ${op.orderId?.slice(-8) || 'N/A'}</div>
                                                                                        <div class="text-[10px] text-gray-500 mt-1">Status: ${op.status}${sizeKB ? ` • HTML: ${sizeKB} KB` : ''}</div>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="text-right">
                                                                                    <div class="text-[10px] text-gray-500">Amount</div>
                                                                                    <div class="text-xs font-mono text-fennec">${(op.amount / 100000000).toFixed(8)} FB</div>
                                                                                    <button class="open-mint-html mt-2 text-[10px] font-black bg-fennec/15 text-fennec border border-fennec/30 px-3 py-1 rounded-lg hover:bg-fennec/25 transition" data-order-id="${op.orderId || ''}">OPEN CARD</button>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    `;
                            })
                            .join('');
                    }

                    // Inscriptions
                    if (inscriptions.length > 0) {
                        html += '<div class="text-xs text-gray-500 mb-2 font-bold uppercase">Inscriptions</div>';
                        html += inscriptions
                            .map(op => {
                                const statusIcon =
                                    op.status === 'pending'
                                        ? 'fa-clock'
                                        : op.status === 'inscribing'
                                          ? 'fa-spinner fa-spin'
                                          : 'fa-hourglass-half';
                                const statusColor =
                                    op.status === 'pending'
                                        ? 'text-yellow-500'
                                        : op.status === 'inscribing'
                                          ? 'text-blue-500'
                                          : 'text-gray-500';
                                // Нормализуем тикер: убираем префиксы sFB, sBTC и т.д.
                                let displayTick = op.tick || 'FB';
                                if (displayTick.includes('sFB') || displayTick === 'sFB___000') displayTick = 'FB';
                                if (displayTick.includes('sBTC') || displayTick === 'sBTC___000') displayTick = 'BTC';
                                if (displayTick.includes('FENNEC')) displayTick = 'FENNEC';
                                return `
                                                                        <div class="bg-black/30 border border-white/5 rounded-lg p-4 mb-2">
                                                                            <div class="flex items-center justify-between">
                                                                                <div class="flex items-center gap-3">
                                                                                    <i class="fas ${statusIcon} ${statusColor} text-xl"></i>
                                                                                    <div>
                                                                                        <div class="text-sm font-bold text-white">Creating Transfer Inscription</div>
                                                                                        <div class="text-xs text-gray-400">${op.amount} ${displayTick}</div>
                                                                                        <div class="text-[10px] text-gray-500 mt-1">Status: ${op.status}</div>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="text-right">
                                                                                    <div class="text-[10px] text-gray-500">Order ID</div>
                                                                                    <div class="text-xs font-mono text-fennec">${op.orderId?.slice(-8) || 'N/A'}</div>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    `;
                            })
                            .join('');
                    }

                    // Deposits
                    if (deposits.length > 0) {
                        html += '<div class="text-xs text-gray-500 mb-2 mt-4 font-bold uppercase">Deposits</div>';
                        html += deposits
                            .map(op => {
                                const cur = op.cur || 0;
                                const sum = op.sum || 0;
                                const percent = Math.round((cur / sum) * 100);
                                const amount = parseFloat(op.amount || 0);
                                const amountStr =
                                    amount % 1 === 0 ? amount.toString() : amount.toFixed(8).replace(/\.?0+$/, '');
                                // Нормализуем тикер: убираем префиксы sFB, sBTC и т.д.
                                let displayTick = op.tick || 'FB';
                                if (displayTick.includes('sFB') || displayTick === 'sFB___000') displayTick = 'FB';
                                if (displayTick.includes('sBTC') || displayTick === 'sBTC___000') displayTick = 'BTC';
                                if (displayTick.includes('FENNEC')) displayTick = 'FENNEC';
                                return `
                                                                        <div class="bg-black/30 border border-white/5 rounded-lg p-4 mb-2">
                                                                            <div class="flex items-center justify-between">
                                                                                <div class="flex items-center gap-3">
                                                                                    <i class="fas fa-arrow-down text-green-500 text-xl"></i>
                                                                                    <div>
                                                                                        <div class="text-sm font-bold text-white">Deposit ${amountStr} ${displayTick}</div>
                                                                                        <div class="text-xs text-gray-400">${cur}/${sum} confirmations</div>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="text-right">
                                                                                    <div class="text-xs font-bold text-green-400">${percent}%</div>
                                                                                    <div class="w-20 bg-white/10 rounded-full h-2 mt-1">
                                                                                        <div class="bg-green-500 h-2 rounded-full" style="width: ${percent}%"></div>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    `;
                            })
                            .join('');
                    }

                    // Withdrawals
                    if (withdrawals.length > 0) {
                        html += '<div class="text-xs text-gray-500 mb-2 mt-4 font-bold uppercase">Withdrawals</div>';
                        html += withdrawals
                            .map(op => {
                                const cur = op.cur || 0;
                                const sum = op.sum || 0;
                                const percent = Math.round((cur / sum) * 100);
                                const amount = parseFloat(op.amount || 0);
                                const amountStr =
                                    amount % 1 === 0 ? amount.toString() : amount.toFixed(8).replace(/\.?0+$/, '');
                                // Нормализуем тикер: убираем префиксы sFB, sBTC и т.д.
                                let displayTick = op.tick || 'FB';
                                if (displayTick.includes('sFB') || displayTick === 'sFB___000') displayTick = 'FB';
                                if (displayTick.includes('sBTC') || displayTick === 'sBTC___000') displayTick = 'BTC';
                                if (displayTick.includes('FENNEC')) displayTick = 'FENNEC';
                                return `
                                                                        <div class="bg-black/30 border border-white/5 rounded-lg p-4 mb-2">
                                                                            <div class="flex items-center justify-between">
                                                                                <div class="flex items-center gap-3">
                                                                                    <i class="fas fa-arrow-up text-fennec text-xl"></i>
                                                                                    <div>
                                                                                        <div class="text-sm font-bold text-white">Withdraw ${amountStr} ${displayTick}</div>
                                                                                        <div class="text-xs text-gray-400">${cur}/${sum} confirmations</div>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="text-right">
                                                                                    <div class="text-xs font-bold text-fennec">${percent}%</div>
                                                                                    <div class="w-20 bg-white/10 rounded-full h-2 mt-1">
                                                                                        <div class="bg-fennec h-2 rounded-full" style="width: ${percent}%"></div>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    `;
                            })
                            .join('');
                    }

                    pendingEl.innerHTML = html;

                    pendingEl.querySelectorAll('.open-mint-html').forEach(btn => {
                        btn.addEventListener('click', event => {
                            event.stopPropagation();
                            const orderId = btn.dataset.orderId;
                            if (!orderId) return;
                            const pendingOps = JSON.parse(localStorage.getItem('pending_operations') || '[]');
                            const op = pendingOps.find(o => o.type === 'mint' && o.orderId === orderId);
                            const htmlCode = op && op.htmlCode ? op.htmlCode : '';
                            if (!htmlCode) return;
                            const blob = new Blob([htmlCode], { type: 'text/html' });
                            const url = URL.createObjectURL(blob);
                            window.open(url, '_blank');
                            setTimeout(() => {
                                try {
                                    URL.revokeObjectURL(url);
                                } catch (e) {}
                            }, 60000);
                        });
                    });
                } catch (e) {
                    console.error('Error refreshing pending operations:', e);
                    pendingEl.innerHTML = `
                                                                <div class="text-center py-8 text-red-500 text-xs">
                                                                    <i class="fas fa-exclamation-triangle text-3xl mb-3"></i>
                                                                    <p>Error loading pending operations</p>
                                                                </div>
                                                            `;
                }
            }
            function switchDir() {
                isBuying = !isBuying;
                document.getElementById('swapIn').value = '';
                document.getElementById('swapOut').value = '';
                updateUI();
            }

            // Set swap pair (FB_FENNEC or BTC_FB)
            function setSwapPair(pair) {
                currentSwapPair = pair;
                isBuying = true; // Reset direction
                document.getElementById('swapIn').value = '';
                document.getElementById('swapOut').value = '';

                // Update button states (новые ID из предоставленного HTML)
                const pairFB = document.getElementById('pair-fb-fennec');
                const pairBTC = document.getElementById('pair-btc-fb');
                if (pairFB) {
                    pairFB.className =
                        pair === 'FB_FENNEC'
                            ? 'flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg transition'
                            : 'flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition';
                }
                if (pairBTC) {
                    pairBTC.className =
                        pair === 'BTC_FB'
                            ? 'flex-1 py-2 text-xs font-bold border border-fennec bg-fennec/10 text-fennec rounded-lg transition'
                            : 'flex-1 py-2 text-xs font-bold border border-white/10 text-gray-500 hover:text-white rounded-lg transition';
                }
                // Старые ID для совместимости
                const oldPairFB = document.getElementById('swap-pair-fb-fennec');
                const oldPairBTC = document.getElementById('swap-pair-btc-fb');
                if (oldPairFB) {
                    oldPairFB.className =
                        pair === 'FB_FENNEC'
                            ? 'flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer border-fennec text-fennec bg-fennec/10'
                            : 'flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer border-gray-700 text-gray-500 hover:text-white';
                }
                if (oldPairBTC) {
                    oldPairBTC.className =
                        pair === 'BTC_FB'
                            ? 'flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer border-fennec text-fennec bg-fennec/10'
                            : 'flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer border-gray-700 text-gray-500 hover:text-white';
                }

                // Update activeTickers based on pair
                if (pair === 'FB_FENNEC') {
                    activeTickers.tick0 = T_SFB;
                    activeTickers.tick1 = T_FENNEC;
                } else if (pair === 'BTC_FB') {
                    // Для пула используем правильные тикеры InSwap
                    activeTickers.tick0 = T_SBTC;
                    activeTickers.tick1 = T_SFB;
                }

                updateUI();
                fetchReserves(); // Загружаем резервы выбранного пула

                // Обновляем историю свапов для выбранной пары
                if (userAddress) {
                    setTimeout(refreshTransactionHistory, 500);
                }
            }

            function setMaxAmount() {
                if (!userAddress) return connectWallet();
                let bal;
                if (currentSwapPair === 'FB_FENNEC') {
                    bal = isBuying ? userBalances.sFB : userBalances.FENNEC;
                } else {
                    // BTC_FB
                    bal = isBuying ? poolReserves.user_sBTC || 0 : userBalances.sFB;
                }
                if (bal > 0) {
                    let feeBuffer = 0;
                    if (currentSwapPair === 'FB_FENNEC' && isBuying) feeBuffer = 0.05;
                    const maxAmount = Math.max(0, bal - feeBuffer);
                    if (maxAmount <= 0) {
                        if (typeof showNotification === 'function') {
                            showNotification('Not enough FB after reserving 0.05 for fees', 'warning', 2500);
                        }
                        return;
                    }
                    document.getElementById('swapIn').value = maxAmount.toFixed(8);
                    calc();
                }
            }

            function triggerSwapSuccessFx() {
                const btn = document.getElementById('swapBtn');
                if (btn) {
                    btn.classList.remove('swap-success-pulse');
                    void btn.offsetWidth;
                    btn.classList.add('swap-success-pulse');
                }

                const overlay = document.getElementById('swapSuccessOverlay');
                if (overlay) {
                    overlay.classList.remove('swap-success-overlay');
                    overlay.style.display = 'flex';
                    void overlay.offsetWidth;
                    overlay.classList.add('swap-success-overlay');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        overlay.classList.remove('swap-success-overlay');
                    }, 980);
                }
            }

            function openAddLiquidityFromSwap() {
                const pair =
                    typeof currentSwapPair === 'string' && currentSwapPair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';
                openAddLiquidityModal(pair);
            }

            function closeAddLiquidityModal() {
                const modal = document.getElementById('addLiquidityModal');
                if (modal) modal.classList.add('hidden');
                // Reset to Add tab
                switchLiquidityTab('add');
            }

            function switchLiquidityTab(tab) {
                const addContent = document.getElementById('liqAddContent');
                const removeContent = document.getElementById('liqRemoveContent');
                const addTab = document.getElementById('liqTabAdd');
                const removeTab = document.getElementById('liqTabRemove');

                if (tab === 'add') {
                    if (addContent) addContent.classList.remove('hidden');
                    if (removeContent) removeContent.classList.add('hidden');
                    if (addTab) {
                        addTab.className =
                            'flex-1 px-4 py-2 rounded-xl bg-fennec/15 border border-fennec/30 text-white font-black transition';
                    }
                    if (removeTab) {
                        removeTab.className =
                            'flex-1 px-4 py-2 rounded-xl bg-white/5 border border-white/10 text-gray-400 font-black transition';
                    }
                } else if (tab === 'remove') {
                    if (addContent) addContent.classList.add('hidden');
                    if (removeContent) removeContent.classList.remove('hidden');
                    if (addTab) {
                        addTab.className =
                            'flex-1 px-4 py-2 rounded-xl bg-white/5 border border-white/10 text-gray-400 font-black transition';
                    }
                    if (removeTab) {
                        removeTab.className =
                            'flex-1 px-4 py-2 rounded-xl bg-fennec/15 border border-fennec/30 text-white font-black transition';
                    }
                    // Load LP data when switching to remove tab
                    const ctx = window.__liqWithdrawCtx || null;
                    const lpBalEl = document.getElementById('removeLpBalance');
                    if (lpBalEl) {
                        const lpAvail = Number(ctx?.lp || 0) || 0;
                        lpBalEl.textContent = lpAvail > 0 ? lpAvail.toString() : '--';
                    }
                    const inp = document.getElementById('removeLpAmount');
                    if (inp) {
                        inp.value = '';
                        inp.addEventListener('input', updateRemoveLiquidityEstimate);
                    }
                    const recv = document.getElementById('removeReceive');
                    if (recv) recv.textContent = '--';
                    const btn = document.getElementById('removeLiqBtn');
                    if (btn) {
                        btn.disabled = true;
                        btn.className =
                            'mt-3 w-full bg-gradient-to-r from-fennec to-orange-400 text-black font-black text-base py-3 rounded-xl hover:brightness-110 transition opacity-50 cursor-not-allowed';
                    }
                }
            }

            async function openAddLiquidityModal(pair) {
                if (!userAddress) {
                    try {
                        await connectWallet();
                    } catch (_) {}
                    if (!userAddress) return;
                }

                const modal = document.getElementById('addLiquidityModal');
                if (modal) modal.classList.remove('hidden');

                try {
                    switchLiquidityTab('add');
                } catch (_) {}

                const p = pair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';

                // Update fixed pair display
                const fixedDisplay = document.getElementById('liqFixedPairDisplay');
                if (fixedDisplay) {
                    fixedDisplay.textContent = p === 'BTC_FB' ? 'BTC / FB' : 'FB / FENNEC';
                }

                const el0 = document.getElementById('liqAmount0');
                const el1 = document.getElementById('liqAmount1');
                const btn = document.getElementById('liqSupplyBtn');
                if (el0) el0.disabled = true;
                if (el1) el1.disabled = true;
                if (btn) btn.disabled = true;
                try {
                    await selectLiquidityPair(p);
                } catch (_) {
                    try {
                        currentLiquidityPair = p;
                        await loadLiquidityPoolData(currentLiquidityPair);
                        updateLiquidityBalancesUI();
                    } catch (_) {}
                }

                if (el0) el0.disabled = false;
                if (el1) el1.disabled = false;
                if (btn) btn.disabled = false;

                try {
                    const v0 = Number(el0?.value || 0);
                    const v1 = Number(el1?.value || 0);
                    if (v0 > 0) syncLiquidityAmounts(0);
                    else if (v1 > 0) syncLiquidityAmounts(1);
                } catch (_) {}

                try {
                    refreshMyLiquidityForSelectedPair(false);
                } catch (_) {}

                try {
                    if (el0) setTimeout(() => el0.focus(), 50);
                } catch (_) {}
            }

            let currentLiquidityPair = 'FB_FENNEC';
            let __liqSyncGuard = false;
            let liquidityPoolData = {
                pair: 'FB_FENNEC',
                apiTick0: T_FENNEC,
                apiTick1: T_SFB,
                apiReserve0: 0,
                apiReserve1: 0,
                uiReserve0: 0,
                uiReserve1: 0,
                poolLp: 0
            };

            function __extractPoolInfoData(json) {
                if (!json) return null;
                if (json.data && json.data.tick0) return json.data;
                if (json.pool && json.pool.tick0) return json.pool;
                if (json.data && Array.isArray(json.data.list) && json.data.list.length > 0) return json.data.list[0];
                return null;
            }

            function __extractPoolLp(data) {
                const candidates = [
                    data?.poolLp,
                    data?.poolLP,
                    data?.pool_lp,
                    data?.lp,
                    data?.lpSupply,
                    data?.poolLpSupply,
                    data?.poolLpAmount,
                    data?.pool_lp_supply
                ];
                for (const v of candidates) {
                    const n = Number(v);
                    if (Number.isFinite(n) && n > 0) return n;
                }
                return 0;
            }

            async function loadLiquidityPoolData(pair) {
                const p = pair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';
                const queryTick0 = p === 'BTC_FB' ? T_SBTC : T_FENNEC;
                const queryTick1 = T_SFB;

                try {
                    const now = Date.now();
                    const url = `${BACKEND_URL}?action=quote&tick0=${encodeURIComponent(queryTick0)}&tick1=${encodeURIComponent(queryTick1)}&t=${now}`;
                    const json = await safeFetchJson(url, { timeoutMs: 12000, retries: 2 });
                    const data = __extractPoolInfoData(json);
                    if (!data) return;

                    const apiTick0 = data.tick0 || queryTick0;
                    const apiTick1 = data.tick1 || queryTick1;
                    const apiReserve0 = Number(data.amount0 || 0) || 0;
                    const apiReserve1 = Number(data.amount1 || 0) || 0;
                    const poolLp = __extractPoolLp(data);

                    let uiReserve0 = 0;
                    let uiReserve1 = 0;

                    if (p === 'FB_FENNEC') {
                        const isApi0Fennec = (apiTick0 || '').toString().toUpperCase().includes('FENNEC');
                        uiReserve0 = isApi0Fennec ? apiReserve0 : apiReserve1; // UI0 = FENNEC
                        uiReserve1 = isApi0Fennec ? apiReserve1 : apiReserve0; // UI1 = FB
                    } else {
                        const isApi0Btc = (apiTick0 || '').toString().toUpperCase().includes('SBTC');
                        uiReserve0 = isApi0Btc ? apiReserve0 : apiReserve1; // UI0 = BTC
                        uiReserve1 = isApi0Btc ? apiReserve1 : apiReserve0; // UI1 = FB
                    }

                    liquidityPoolData = {
                        pair: p,
                        apiTick0,
                        apiTick1,
                        apiReserve0,
                        apiReserve1,
                        uiReserve0,
                        uiReserve1,
                        poolLp
                    };
                } catch (e) {
                    console.warn('loadLiquidityPoolData failed:', e);
                }
            }

            async function selectLiquidityPair(pair) {
                currentLiquidityPair = pair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';
                const btn0 = document.getElementById('liqPairFBF');
                const btn1 = document.getElementById('liqPairBFB');
                if (btn0 && btn1) {
                    btn0.className =
                        currentLiquidityPair === 'FB_FENNEC'
                            ? 'px-4 py-3 rounded-xl bg-fennec/10 border border-fennec/25 text-white font-black hover:bg-fennec/15 hover:border-fennec/45 transition'
                            : 'px-4 py-3 rounded-xl bg-white/5 border border-white/10 text-white font-black hover:bg-white/10 hover:border-white/20 transition';
                    btn1.className =
                        currentLiquidityPair === 'BTC_FB'
                            ? 'px-4 py-3 rounded-xl bg-fennec/10 border border-fennec/25 text-white font-black hover:bg-fennec/15 hover:border-fennec/45 transition'
                            : 'px-4 py-3 rounded-xl bg-white/5 border border-white/10 text-white font-black hover:bg-white/10 hover:border-white/20 transition';
                }

                const tick0El = document.getElementById('liqTick0Label');
                const tick1El = document.getElementById('liqTick1Label');
                if (tick0El && tick1El) {
                    if (currentLiquidityPair === 'FB_FENNEC') {
                        tick0El.innerText = 'FENNEC';
                        tick1El.innerText = 'FB';
                    } else {
                        tick0El.innerText = 'BTC';
                        tick1El.innerText = 'FB';
                    }
                }

                await loadLiquidityPoolData(currentLiquidityPair);
                updateLiquidityBalancesUI();
                syncLiquidityAmounts(0);
                refreshMyLiquidityForSelectedPair(false);
            }

            let __myLiqCache = null;
            let __myLiqCacheAt = 0;

            async function fetchMyLiquiditySummary(force) {
                if (!userAddress) return null;
                const now = Date.now();
                if (!force && __myLiqCache && now - __myLiqCacheAt < 15000) return __myLiqCache;
                try {
                    const pubkey = typeof userPubkey === 'string' && userPubkey ? userPubkey : '';
                    const url = pubkey
                        ? `${BACKEND_URL}?action=inswap_summary&address=${encodeURIComponent(userAddress)}&pubkey=${encodeURIComponent(pubkey)}&t=${now}`
                        : `${BACKEND_URL}?action=inswap_summary&address=${encodeURIComponent(userAddress)}&t=${now}`;
                    const json = await safeFetchJson(url, { timeoutMs: 15000, retries: 1 });
                    const data = json && typeof json === 'object' ? json.data || null : null;
                    __myLiqCache = data;
                    __myLiqCacheAt = now;
                    return data;
                } catch (_) {
                    return __myLiqCache;
                }
            }

            function __normalizeTickLabel(tick) {
                const t = String(tick || '').toUpperCase();
                if (t.includes('FENNEC')) return 'FENNEC';
                if (t.includes('SBTC') || t === 'BTC') return 'BTC';
                if (t.includes('SFB') || t === 'FB') return 'FB';
                return String(tick || '');
            }

            function __poolMatchesPair(pool, pair) {
                const a = String(pool?.tick0 || '').toUpperCase();
                const b = String(pool?.tick1 || '').toUpperCase();
                const hasFennec = a.includes('FENNEC') || b.includes('FENNEC');
                const hasFB =
                    a.includes('SFB') ||
                    b.includes('SFB') ||
                    a === 'FB' ||
                    b === 'FB' ||
                    a === 'SFB___000' ||
                    b === 'SFB___000' ||
                    a.includes('FB') ||
                    b.includes('FB');
                const hasBTC =
                    a.includes('SBTC') ||
                    b.includes('SBTC') ||
                    a === 'BTC' ||
                    b === 'BTC' ||
                    a === 'SBTC___000' ||
                    b === 'SBTC___000' ||
                    a.includes('BTC') ||
                    b.includes('BTC');
                if (pair === 'FB_FENNEC') return hasFennec && hasFB;
                if (pair === 'BTC_FB') return hasBTC && hasFB;
                return false;
            }

            function __formatMaybeNum(v) {
                const n = Number(v);
                if (!Number.isFinite(n)) return null;
                return Math.abs(n) >= 1e8 ? n.toExponential(3) : Math.abs(n) >= 1 ? n.toFixed(6) : n.toFixed(10);
            }

            function __escapeHtml(s) {
                return String(s)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            function __collectEarningFields(obj) {
                const out = { claimed: [], unclaimed: [] };
                if (!obj || typeof obj !== 'object') return out;
                const keys = Object.keys(obj);
                for (const k of keys) {
                    const lk = k.toLowerCase();
                    const v = obj[k];
                    if (v === null || v === undefined) continue;
                    const numStr = __formatMaybeNum(v);
                    if (!numStr) continue;
                    if (
                        lk.includes('unclaimed') ||
                        lk.includes('unclaim') ||
                        lk.includes('claimable') ||
                        lk.includes('pending') ||
                        lk.includes('owed')
                    ) {
                        out.unclaimed.push({ k, v: numStr });
                        continue;
                    }
                    if (lk.includes('claimed')) {
                        out.claimed.push({ k, v: numStr });
                        continue;
                    }
                }
                return out;
            }

            function __prettyRewardLabel(key, tick0, tick1) {
                const k = String(key || '');
                const lk = k.toLowerCase();
                const isUnclaimed = lk.includes('unclaimed') || lk.includes('unclaim') || lk.includes('claimable');
                const idx = lk.endsWith('0') ? 0 : lk.endsWith('1') ? 1 : null;
                const t = idx === 0 ? String(tick0 || '') : idx === 1 ? String(tick1 || '') : '';
                const base = isUnclaimed ? 'Claimable rewards' : 'Claimed rewards';
                return t ? `${base} (${t})` : base;
            }

            async function refreshMyLiquidityForSelectedPair(force) {
                const box = document.getElementById('liqMyPos');
                const body = document.getElementById('liqMyPosBody');
                const withdrawBox = document.getElementById('liqWithdrawPanel');
                if (!box || !body) return;

                if (!userAddress) {
                    box.classList.add('hidden');
                    if (withdrawBox) withdrawBox.classList.add('hidden');
                    window.__liqWithdrawCtx = null;
                    return;
                }

                body.innerHTML = '<div class="text-[10px] text-gray-500 font-mono">Loading...</div>';
                box.classList.remove('hidden');
                if (withdrawBox) withdrawBox.classList.add('hidden');

                const data = await fetchMyLiquiditySummary(!!force);
                const list = data && Array.isArray(data.lp_list) ? data.lp_list : [];

                const pair = currentLiquidityPair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';
                const pools = list.filter(p => __poolMatchesPair(p, pair));

                if (!pools.length) {
                    body.innerHTML =
                        '<div class="text-[10px] text-gray-500 font-mono">No liquidity found for this pair.</div>';
                    if (withdrawBox) withdrawBox.classList.add('hidden');
                    window.__liqWithdrawCtx = null;
                    return;
                }

                let uiAmt0 = 0;
                let uiAmt1 = 0;
                let share = 0;
                let lp = 0;
                const uiTick0 = pair === 'BTC_FB' ? 'BTC' : 'FENNEC';
                const uiTick1 = 'FB';

                for (const p of pools) {
                    const a0 = Number(p.amount0 || 0) || 0;
                    const a1 = Number(p.amount1 || 0) || 0;
                    const api0 = String(p.tick0 || '').toUpperCase();
                    if (pair === 'FB_FENNEC') {
                        const api0IsFennec = api0.includes('FENNEC');
                        uiAmt0 += api0IsFennec ? a0 : a1;
                        uiAmt1 += api0IsFennec ? a1 : a0;
                    } else {
                        const api0IsBtc = api0.includes('SBTC') || api0 === 'BTC' || api0.includes('BTC');
                        uiAmt0 += api0IsBtc ? a0 : a1;
                        uiAmt1 += api0IsBtc ? a1 : a0;
                    }
                    share += Number(p.shareOfPool || p.share || 0) || 0;
                    lp += Number(p.lp || p.liq || p.liquidity || 0) || 0;
                }

                const lpStr = lp ? __formatMaybeNum(lp) || String(lp) : '--';
                const shareStr = share ? __formatMaybeNum(share) || String(share) : '--';

                body.innerHTML = `
                                                            <div class="grid grid-cols-2 gap-3">
                                                                <div class="bg-white/5 border border-white/10 rounded-xl p-3">
                                                                    <div class="text-[10px] text-gray-400 font-bold uppercase tracking-widest">${uiTick0}</div>
                                                                    <div class="mt-1 text-white text-base font-black">${__escapeHtml(__formatMaybeNum(uiAmt0) || '0')}</div>
                                                                </div>
                                                                <div class="bg-white/5 border border-white/10 rounded-xl p-3">
                                                                    <div class="text-[10px] text-gray-400 font-bold uppercase tracking-widest">${uiTick1}</div>
                                                                    <div class="mt-1 text-white text-base font-black">${__escapeHtml(__formatMaybeNum(uiAmt1) || '0')}</div>
                                                                </div>
                                                            </div>

                                                            <div class="mt-3 grid grid-cols-2 gap-3 text-[10px] font-mono">
                                                                <div class="text-gray-400">LP: <span class="text-white font-bold">${__escapeHtml(lpStr)}</span></div>
                                                                <div class="text-gray-400 text-right">Share: <span class="text-white font-bold">${__escapeHtml(shareStr)}</span></div>
                                                            </div>
                                                        `;

                try {
                    const cfg = typeof getLiquidityConfig === 'function' ? getLiquidityConfig() : null;
                    window.__liqWithdrawCtx = {
                        pair,
                        uiTick0,
                        uiTick1,
                        apiTick0: cfg?.apiTick0 || pools[0]?.tick0 || '',
                        apiTick1: cfg?.apiTick1 || pools[0]?.tick1 || '',
                        lp: Number(lp || 0) || 0
                    };
                } catch (_) {
                    window.__liqWithdrawCtx = null;
                }

                if (withdrawBox) withdrawBox.classList.add('hidden');
            }

            async function openRemoveLiquidityModal() {
                if (!userAddress) {
                    try {
                        await connectWallet();
                    } catch (_) {}
                    if (!userAddress) return;
                }
                const modal = document.getElementById('addLiquidityModal');
                if (!modal) return;
                modal.classList.remove('hidden');
                // Switch to Remove tab
                switchLiquidityTab('remove');
            }

            function setMaxRemoveLp() {
                const ctx = window.__liqWithdrawCtx || null;
                const lpAvail = Number(ctx?.lp || 0) || 0;
                const inp = document.getElementById('removeLpAmount');
                if (!inp) return;
                inp.value = lpAvail ? __normalizeAmountStr(lpAvail, 8) : '';
                updateRemoveLiquidityEstimate();
            }

            let __removeQuoteTimeout = null;
            async function updateRemoveLiquidityEstimate() {
                clearTimeout(__removeQuoteTimeout);
                const inp = document.getElementById('removeLpAmount');
                const recv = document.getElementById('removeReceive');
                const btn = document.getElementById('removeLiqBtn');
                const ctx = window.__liqWithdrawCtx || null;

                if (!inp || !recv || !ctx) return;

                const lpVal = Number(inp.value || 0) || 0;
                if (!lpVal || lpVal <= 0) {
                    recv.textContent = '--';
                    if (btn) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    return;
                }

                recv.textContent = 'Loading...';
                if (btn) {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                }

                __removeQuoteTimeout = setTimeout(async () => {
                    try {
                        const lpStr = __normalizeAmountStr(lpVal, 8);
                        const qUrl =
                            `${BACKEND_URL}?action=quote_remove_liq` +
                            `&address=${encodeURIComponent(userAddress)}` +
                            `&tick0=${encodeURIComponent(ctx.apiTick0)}` +
                            `&tick1=${encodeURIComponent(ctx.apiTick1)}` +
                            `&lp=${encodeURIComponent(lpStr)}`;
                        const q = await fetch(qUrl, {
                            headers: {
                                'x-public-key': userPubkey,
                                'x-address': userAddress
                            },
                            cache: 'no-store'
                        }).then(r => r.json());

                        if (q && q.code === 0 && q.data) {
                            const amount0Str = String(q.data.amount0 || q.data.amt0 || '').trim();
                            const amount1Str = String(q.data.amount1 || q.data.amt1 || '').trim();
                            if (amount0Str && amount1Str) {
                                let uiAmt0 = amount0Str;
                                let uiAmt1 = amount1Str;
                                if (ctx.pair === 'FB_FENNEC') {
                                    const api0 = String(ctx.apiTick0 || '').toUpperCase();
                                    const api0IsFennec = api0.includes('FENNEC');
                                    uiAmt0 = api0IsFennec ? amount0Str : amount1Str;
                                    uiAmt1 = api0IsFennec ? amount1Str : amount0Str;
                                } else {
                                    const api0 = String(ctx.apiTick0 || '').toUpperCase();
                                    const api0IsBtc = api0.includes('SBTC') || api0 === 'BTC' || api0.includes('BTC');
                                    uiAmt0 = api0IsBtc ? amount0Str : amount1Str;
                                    uiAmt1 = api0IsBtc ? amount1Str : amount0Str;
                                }
                                // Округлить до 2 знаков после запятой
                                const amt0Rounded = Number(uiAmt0).toFixed(2);
                                const amt1Rounded = Number(uiAmt1).toFixed(2);
                                recv.textContent = `${ctx.uiTick0}: ${amt0Rounded}   |   ${ctx.uiTick1}: ${amt1Rounded}`;
                                if (btn) {
                                    btn.disabled = false;
                                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                                }
                                return;
                            }
                        }
                        recv.textContent = 'Quote failed';
                    } catch (e) {
                        recv.textContent = 'Error';
                    }
                }, 500);
            }

            async function doRemoveLiquidity() {
                if (!userAddress) return connectWallet();

                const btn = document.getElementById('removeLiqBtn');
                const originalText = btn ? btn.innerText : '';
                try {
                    await checkFractalNetwork();

                    if (!userPubkey)
                        try {
                            userPubkey = await window.unisat.getPublicKey();
                        } catch (_) {}

                    const ctx = window.__liqWithdrawCtx || null;
                    if (!ctx || !ctx.apiTick0 || !ctx.apiTick1) throw new Error('No liquidity context');

                    const inp = document.getElementById('removeLpAmount');
                    const lpVal = Number(inp?.value || 0) || 0;
                    if (!lpVal || lpVal <= 0) throw new Error('Enter LP amount');

                    const lpStr = __normalizeAmountStr(lpVal, 8);
                    if (!lpStr || Number(lpStr) <= 0) throw new Error('Invalid LP amount');
                    if (ctx.lp && lpVal > Number(ctx.lp || 0) * 1.0000001)
                        throw new Error('LP amount exceeds your position');

                    if (btn) {
                        btn.disabled = true;
                        btn.innerText = 'QUOTING…';
                    }

                    const qUrl =
                        `${BACKEND_URL}?action=quote_remove_liq` +
                        `&address=${encodeURIComponent(userAddress)}` +
                        `&tick0=${encodeURIComponent(ctx.apiTick0)}` +
                        `&tick1=${encodeURIComponent(ctx.apiTick1)}` +
                        `&lp=${encodeURIComponent(lpStr)}`;
                    const q = await fetch(qUrl, {
                        headers: {
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        cache: 'no-store'
                    }).then(r => r.json());
                    if (!q || q.code !== 0 || !q.data) throw new Error(q?.msg || q?.error || 'quote_remove_liq failed');

                    const amount0Str = String(q.data.amount0 || q.data.amt0 || '').trim();
                    const amount1Str = String(q.data.amount1 || q.data.amt1 || '').trim();
                    if (!amount0Str || !amount1Str) throw new Error('quote_remove_liq returned empty amounts');

                    try {
                        const recv = document.getElementById('removeReceive');
                        if (recv) {
                            let uiAmt0 = amount0Str;
                            let uiAmt1 = amount1Str;
                            if (ctx.pair === 'FB_FENNEC') {
                                const api0 = String(ctx.apiTick0 || '').toUpperCase();
                                const api0IsFennec = api0.includes('FENNEC');
                                uiAmt0 = api0IsFennec ? amount0Str : amount1Str;
                                uiAmt1 = api0IsFennec ? amount1Str : amount0Str;
                            } else {
                                const api0 = String(ctx.apiTick0 || '').toUpperCase();
                                const api0IsBtc = api0.includes('SBTC') || api0 === 'BTC' || api0.includes('BTC');
                                uiAmt0 = api0IsBtc ? amount0Str : amount1Str;
                                uiAmt1 = api0IsBtc ? amount1Str : amount0Str;
                            }
                            recv.textContent = `${ctx.uiTick0}: ${uiAmt0}   |   ${ctx.uiTick1}: ${uiAmt1}`;
                        }
                    } catch (_) {}

                    const ts = Math.floor(Date.now() / 1000);
                    const feeTick = T_SFB;
                    const payType = 'tick';
                    const slippage = '0.05';

                    if (btn) btn.innerText = 'PREPARING…';
                    const preUrl =
                        `${BACKEND_URL}?action=pre_remove_liq` +
                        `&address=${encodeURIComponent(userAddress)}` +
                        `&tick0=${encodeURIComponent(ctx.apiTick0)}` +
                        `&tick1=${encodeURIComponent(ctx.apiTick1)}` +
                        `&amount0=${encodeURIComponent(amount0Str)}` +
                        `&amount1=${encodeURIComponent(amount1Str)}` +
                        `&lp=${encodeURIComponent(lpStr)}` +
                        `&slippage=${encodeURIComponent(slippage)}` +
                        `&ts=${encodeURIComponent(ts)}` +
                        `&feeTick=${encodeURIComponent(feeTick)}` +
                        `&payType=${encodeURIComponent(payType)}`;
                    const pre = await fetch(preUrl, {
                        headers: {
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        cache: 'no-store'
                    }).then(r => r.json());
                    if (!pre || pre.code !== 0 || !pre.data)
                        throw new Error(pre?.msg || pre?.error || 'pre_remove_liq failed');

                    const signMsgs = Array.isArray(pre.data.signMsgs)
                        ? pre.data.signMsgs
                        : pre.data.signMsg
                          ? [pre.data.signMsg]
                          : pre.data.sign_msg
                            ? [pre.data.sign_msg]
                            : pre.data.msg
                              ? [pre.data.msg]
                              : [];
                    const msgsToSign = signMsgs
                        .map(m =>
                            typeof m === 'object'
                                ? (m.text ?? m.msg ?? m.message ?? m.signMsg ?? m.sign_msg ?? m.id)
                                : m
                        )
                        .map(m => (m === null || m === undefined ? '' : String(m)))
                        .filter(m => m.length > 0);
                    if (!msgsToSign.length) throw new Error('pre_remove_liq returned empty signMsgs');

                    const feeAmount = String(pre.data.feeAmount || pre.data.fee_amount || '').trim();
                    const feeTickPrice = String(pre.data.feeTickPrice || pre.data.fee_tick_price || '').trim();
                    if (!feeAmount || !feeTickPrice)
                        throw new Error('pre_remove_liq returned empty feeAmount/feeTickPrice');

                    const sigs = [];
                    for (let i = 0; i < msgsToSign.length; i += 1) {
                        if (btn) btn.innerText = `SIGNING (${i + 1}/${msgsToSign.length})…`;
                        await new Promise(r => setTimeout(r, 250));
                        const sig = await window.unisat.signMessage(msgsToSign[i], 'bip322-simple');
                        sigs.push(sig);
                    }

                    if (
                        !Array.isArray(sigs) ||
                        sigs.length !== msgsToSign.length ||
                        sigs.some(s => !s || typeof s !== 'string')
                    ) {
                        throw new Error('Wallet returned invalid signature(s)');
                    }

                    if (btn) btn.innerText = 'SUBMITTING…';
                    const body = {
                        address: userAddress,
                        tick0: ctx.apiTick0,
                        tick1: ctx.apiTick1,
                        lp: lpStr,
                        amount0: amount0Str,
                        amount1: amount1Str,
                        slippage,
                        ts,
                        feeTick,
                        feeAmount,
                        feeTickPrice,
                        sigs,
                        payType,
                        rememberPayType: false
                    };

                    console.log('🔄 Submitting remove_liq with body:', body);

                    const sub = await fetch(`${BACKEND_URL}?action=remove_liq`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(body)
                    }).then(r => r.json());

                    if (!sub || sub.code !== 0) throw new Error(sub?.msg || sub?.error || 'remove_liq failed');

                    showSuccess(`Liquidity withdrawn! ID: ${sub.data?.id || 'OK'}`);
                    if (typeof showNotification === 'function')
                        showNotification('Liquidity withdrawn successfully', 'success', 3200);
                    closeAddLiquidityModal();
                    setTimeout(() => {
                        try {
                            refreshMyLiquidityForSelectedPair(true);
                        } catch (_) {}
                        try {
                            checkBalance();
                        } catch (_) {}
                    }, 1200);
                } catch (e) {
                    console.error('Remove liquidity error:', e);
                    if (typeof showNotification === 'function')
                        showNotification(e?.message || String(e), 'error', 4500);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    if (btn) {
                        btn.disabled = false;
                        btn.innerText = originalText;
                    }
                }
            }

            function getBalanceForTick(tick) {
                const t = (tick || '').toString().toUpperCase();
                if (t.includes('FENNEC')) return Number(userBalances.FENNEC || 0) || 0;
                if (t.includes('SBTC') || t === 'BTC') return Number(poolReserves.user_sBTC || 0) || 0;
                if (t.includes('SFB') || t === 'FB') return Number(userBalances.sFB || 0) || 0;
                return 0;
            }

            function getLiquidityConfig() {
                const p = currentLiquidityPair === 'BTC_FB' ? 'BTC_FB' : 'FB_FENNEC';
                const uiTick0 = p === 'BTC_FB' ? T_SBTC : T_FENNEC;
                const uiTick1 = T_SFB;

                const apiTick0 = liquidityPoolData?.pair === p ? liquidityPoolData.apiTick0 : uiTick0;
                const apiTick1 = liquidityPoolData?.pair === p ? liquidityPoolData.apiTick1 : uiTick1;
                const uiReserve0 = liquidityPoolData?.pair === p ? Number(liquidityPoolData.uiReserve0 || 0) || 0 : 0;
                const uiReserve1 = liquidityPoolData?.pair === p ? Number(liquidityPoolData.uiReserve1 || 0) || 0 : 0;
                const poolLp = liquidityPoolData?.pair === p ? Number(liquidityPoolData.poolLp || 0) || 0 : 0;

                const mapUiToApiAmounts = (amountUi0, amountUi1) => {
                    const a0 = Number(amountUi0 || 0) || 0;
                    const a1 = Number(amountUi1 || 0) || 0;
                    if (p === 'FB_FENNEC') {
                        const api0IsFennec = (apiTick0 || '').toString().toUpperCase().includes('FENNEC');
                        return api0IsFennec ? { amount0: a0, amount1: a1 } : { amount0: a1, amount1: a0 };
                    }
                    const api0IsBtc = (apiTick0 || '').toString().toUpperCase().includes('SBTC');
                    return api0IsBtc ? { amount0: a0, amount1: a1 } : { amount0: a1, amount1: a0 };
                };

                return {
                    label: p === 'BTC_FB' ? 'BTC/FB' : 'FB/FENNEC',
                    pair: p,
                    uiTick0,
                    uiTick1,
                    apiTick0,
                    apiTick1,
                    reserve0: uiReserve0,
                    reserve1: uiReserve1,
                    poolLp,
                    bal0: getBalanceForTick(uiTick0),
                    bal1: getBalanceForTick(uiTick1),
                    mapUiToApiAmounts
                };
            }

            function updateLiquidityBalancesUI() {
                const cfg = getLiquidityConfig();
                const b0 = document.getElementById('liqBal0');
                const b1 = document.getElementById('liqBal1');
                if (b0) b0.innerText = Number(cfg.bal0 || 0).toFixed(8);
                if (b1) b1.innerText = Number(cfg.bal1 || 0).toFixed(8);
            }

            function __toFixedTrim(num, maxDecimals) {
                const n = Number(num);
                if (!Number.isFinite(n)) return '';
                const d = Number.isFinite(Number(maxDecimals)) ? Math.max(0, Math.min(18, Number(maxDecimals))) : 8;
                const s = n.toFixed(d);
                return s
                    .replace(/\.0+$/, '')
                    .replace(/(\.\d*?)0+$/, '$1')
                    .replace(/\.$/, '');
            }

            function __normalizeAmountStr(value, maxDecimals) {
                if (value === null || value === undefined) return '';
                const s = String(value).trim();
                if (!s) return '';

                if (/e/i.test(s)) {
                    const n = Number(s);
                    return __toFixedTrim(n, maxDecimals);
                }

                if (!/^[0-9]*\.?[0-9]*$/.test(s)) {
                    const n = Number(s);
                    return __toFixedTrim(n, maxDecimals);
                }

                const n = Number(s);
                if (!Number.isFinite(n)) return '';
                return __toFixedTrim(n, maxDecimals);
            }

            function computeExpectedLp(amount0, amount1, reserve0, reserve1, poolLp) {
                const a0 = Number(amount0 || 0);
                const a1 = Number(amount1 || 0);
                const r0 = Number(reserve0 || 0);
                const r1 = Number(reserve1 || 0);
                const p = Number(poolLp || 0);
                if (!a0 || !a1) return 0;

                if (p > 0 && r0 > 0 && r1 > 0) {
                    return Math.max(0, Math.min((a0 * p) / r0, (a1 * p) / r1));
                }
                if (r0 > 0 && r1 > 0) {
                    const pEst = Math.sqrt(r0 * r1);
                    if (Number.isFinite(pEst) && pEst > 0) {
                        return Math.max(0, Math.min((a0 * pEst) / r0, (a1 * pEst) / r1));
                    }
                }
                return Math.max(0, Math.sqrt(a0 * a1));
            }

            function syncLiquidityAmounts(changedIndex) {
                if (__liqSyncGuard) return;
                __liqSyncGuard = true;
                try {
                    const cfg = getLiquidityConfig();
                    const el0 = document.getElementById('liqAmount0');
                    const el1 = document.getElementById('liqAmount1');
                    if (!el0 || !el1) return;

                    const r0 = Number(cfg.reserve0 || 0);
                    const r1 = Number(cfg.reserve1 || 0);
                    const v0 = parseFloat(el0.value || '0') || 0;
                    const v1 = parseFloat(el1.value || '0') || 0;

                    if (r0 > 0 && r1 > 0) {
                        if (changedIndex === 0 && v0 > 0) {
                            el1.value = (v0 * (r1 / r0)).toFixed(8);
                        }
                        if (changedIndex === 1 && v1 > 0) {
                            el0.value = (v1 * (r0 / r1)).toFixed(8);
                        }
                    }

                    const lpEl = document.getElementById('liqExpectedLP');
                    const lp = computeExpectedLp(
                        parseFloat(el0.value || '0') || 0,
                        parseFloat(el1.value || '0') || 0,
                        r0,
                        r1,
                        cfg.poolLp || 0
                    );
                    if (lpEl) lpEl.innerText = lp ? lp.toFixed(8) : '--';

                    // Активировать кнопку SUPPLY если введены суммы
                    const btn = document.getElementById('liqSupplyBtn');
                    if (btn) {
                        const v0Final = parseFloat(el0.value || '0') || 0;
                        const v1Final = parseFloat(el1.value || '0') || 0;
                        if (v0Final > 0 && v1Final > 0) {
                            btn.disabled = false;
                            btn.classList.remove('opacity-50', 'cursor-not-allowed');
                        } else {
                            btn.disabled = true;
                            btn.classList.add('opacity-50', 'cursor-not-allowed');
                        }
                    }
                } finally {
                    __liqSyncGuard = false;
                }
            }

            function setMaxLiqAmount(which) {
                if (!userAddress) return connectWallet();
                updateLiquidityBalancesUI();
                const cfg = getLiquidityConfig();
                const el0 = document.getElementById('liqAmount0');
                const el1 = document.getElementById('liqAmount1');
                if (!el0 || !el1) return;

                const feeBuffer = 0.05;
                const max0 = Math.max(0, Number(cfg.bal0 || 0) - (cfg.uiTick0 === T_SFB ? feeBuffer : 0));
                const max1 = Math.max(0, Number(cfg.bal1 || 0) - (cfg.uiTick1 === T_SFB ? feeBuffer : 0));

                if (which === 0) {
                    el0.value = max0.toFixed(8);
                    syncLiquidityAmounts(0);
                    return;
                }

                el1.value = max1.toFixed(8);
                syncLiquidityAmounts(1);
            }

            async function copyLiquidityPairForSearch() {
                const cfg = getLiquidityConfig();
                try {
                    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                        await navigator.clipboard.writeText(cfg.label);
                    }
                } catch (e) {}
            }

            async function doAddLiquidity() {
                if (!userAddress) return connectWallet();
                try {
                    await checkFractalNetwork();
                } catch (e) {
                    document.getElementById('errorMsg').innerText = e.message;
                    document.getElementById('errorModal').classList.remove('hidden');
                    return;
                }

                const cfg = getLiquidityConfig();
                const el0 = document.getElementById('liqAmount0');
                const el1 = document.getElementById('liqAmount1');
                const btn = document.getElementById('liqSupplyBtn');
                if (!el0 || !el1 || !btn) return;

                const amount0 = parseFloat(el0.value || '0') || 0;
                const amount1 = parseFloat(el1.value || '0') || 0;
                if (!amount0 || !amount1) {
                    if (typeof showNotification === 'function') showNotification('Enter amounts', 'warning', 2000);
                    return;
                }

                // Leave small FB buffer for fees
                const feeBuffer = 0.05;
                if (cfg.uiTick0 === T_SFB && amount0 > Math.max(0, cfg.bal0 - feeBuffer)) {
                    if (typeof showNotification === 'function')
                        showNotification('Reserved 0.05 FB for fees', 'info', 2200);
                    el0.value = Math.max(0, cfg.bal0 - feeBuffer).toFixed(8);
                    syncLiquidityAmounts(0);
                    return;
                }
                if (cfg.uiTick1 === T_SFB && amount1 > Math.max(0, cfg.bal1 - feeBuffer)) {
                    if (typeof showNotification === 'function')
                        showNotification('Reserved 0.05 FB for fees', 'info', 2200);
                    el1.value = Math.max(0, cfg.bal1 - feeBuffer).toFixed(8);
                    syncLiquidityAmounts(1);
                    return;
                }

                if (amount0 > (cfg.bal0 || 0) || amount1 > (cfg.bal1 || 0)) {
                    document.getElementById('depositLinkModal').classList.remove('hidden');
                    return;
                }

                btn.disabled = true;
                const originalText = btn.innerText;
                btn.innerText = 'PREPARING…';

                try {
                    if (!userPubkey)
                        try {
                            userPubkey = await window.unisat.getPublicKey();
                        } catch (e) {}

                    const ts = Math.floor(Date.now() / 1000);

                    // Estimate expected LP using poolLp if available
                    const expectedLp = computeExpectedLp(amount0, amount1, cfg.reserve0, cfg.reserve1, cfg.poolLp || 0);
                    const lpStr = __normalizeAmountStr(expectedLp || 0, 8);
                    if (!lpStr || Number(lpStr) <= 0) {
                        throw new Error('Invalid LP amount');
                    }

                    const apiAmounts = cfg.mapUiToApiAmounts(amount0, amount1);
                    const amount0Str = __normalizeAmountStr(apiAmounts.amount0, 8);
                    const amount1Str = __normalizeAmountStr(apiAmounts.amount1, 8);
                    if (!amount0Str || !amount1Str || Number(amount0Str) <= 0 || Number(amount1Str) <= 0) {
                        throw new Error('Invalid amount');
                    }
                    const feeTick = T_SFB;
                    const payType = 'tick';

                    const preUrl =
                        `${BACKEND_URL}?action=pre_add_liq` +
                        `&address=${encodeURIComponent(userAddress)}` +
                        `&tick0=${encodeURIComponent(cfg.apiTick0)}` +
                        `&tick1=${encodeURIComponent(cfg.apiTick1)}` +
                        `&amount0=${encodeURIComponent(amount0Str)}` +
                        `&amount1=${encodeURIComponent(amount1Str)}` +
                        `&lp=${encodeURIComponent(lpStr)}` +
                        `&slippage=${encodeURIComponent('0.05')}` +
                        `&ts=${encodeURIComponent(ts)}` +
                        `&feeTick=${encodeURIComponent(feeTick)}` +
                        `&payType=${encodeURIComponent(payType)}`;
                    const pre = await fetch(preUrl, {
                        headers: {
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        cache: 'no-store'
                    }).then(r => r.json());
                    if (!pre || pre.code !== 0 || !pre.data)
                        throw new Error(pre?.msg || pre?.error || 'pre_add_liq failed');

                    const signMsgs = Array.isArray(pre.data.signMsgs)
                        ? pre.data.signMsgs
                        : pre.data.signMsg
                          ? [pre.data.signMsg]
                          : pre.data.sign_msg
                            ? [pre.data.sign_msg]
                            : pre.data.msg
                              ? [pre.data.msg]
                              : [];
                    const msgsToSign = signMsgs
                        .map(m =>
                            typeof m === 'object'
                                ? (m.text ?? m.msg ?? m.message ?? m.signMsg ?? m.sign_msg ?? m.id)
                                : m
                        )
                        // IMPORTANT: do not trim/normalize; signature verification requires exact bytes
                        .map(m => (m === null || m === undefined ? '' : String(m)))
                        .filter(m => m.length > 0);
                    if (!msgsToSign.length) throw new Error('pre_add_liq returned empty signMsgs');

                    const feeAmount = String(pre.data.feeAmount || pre.data.fee_amount || '').trim();
                    const feeTickPrice = String(pre.data.feeTickPrice || pre.data.fee_tick_price || '').trim();
                    if (!feeAmount || !feeTickPrice)
                        throw new Error('pre_add_liq returned empty feeAmount/feeTickPrice');

                    const sigs = [];
                    for (let i = 0; i < msgsToSign.length; i += 1) {
                        btn.innerText = `SIGNING (${i + 1}/${msgsToSign.length})…`;
                        await new Promise(r => setTimeout(r, 250));
                        const sig = await window.unisat.signMessage(msgsToSign[i], 'bip322-simple');
                        sigs.push(sig);
                    }

                    btn.innerText = 'SUBMITTING…';

                    // API body по документации: address, tick0, tick1, amount0, amount1, lp, slippage, ts, feeTick, feeAmount, feeTickPrice, sigs, payType, rememberPayType
                    const body = {
                        address: userAddress,
                        tick0: cfg.apiTick0,
                        tick1: cfg.apiTick1,
                        amount0: amount0Str,
                        amount1: amount1Str,
                        lp: lpStr,
                        slippage: '0.05',
                        ts,
                        feeTick,
                        feeAmount,
                        feeTickPrice,
                        sigs,
                        payType,
                        rememberPayType: false
                    };

                    console.log('🔄 Submitting add_liq with body:', body);

                    const sub = await fetch(`${BACKEND_URL}?action=add_liq`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(body)
                    }).then(r => r.json());

                    if (!sub || sub.code !== 0) throw new Error(sub?.msg || sub?.error || 'add_liq failed');

                    showSuccess(`Liquidity supplied! ID: ${sub.data?.id || 'OK'}`);
                    if (typeof showNotification === 'function')
                        showNotification('Liquidity supplied successfully', 'success', 3200);
                    setTimeout(checkBalance, 2000);
                } catch (e) {
                    console.error('Add liquidity error:', e);
                    if (typeof showNotification === 'function')
                        showNotification(e?.message || String(e), 'error', 4500);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    btn.disabled = false;
                    btn.innerText = originalText;
                }
            }
            function updateUI() {
                // Update UI based on current swap pair
                let inTick, outTick, inIcon, outIcon, bal;
                if (currentSwapPair === 'FB_FENNEC') {
                    inTick = isBuying ? 'FB' : 'FENNEC';
                    outTick = isBuying ? 'FENNEC' : 'FB';
                    inIcon = isBuying ? 'img/FB.png' : 'img/fennec.jpg';
                    outIcon = isBuying ? 'img/fennec.jpg' : 'img/FB.png';
                    bal = isBuying ? userBalances.sFB : userBalances.FENNEC;
                } else {
                    // BTC_FB (sBTC <-> FB, но отображаем как BTC)
                    inTick = isBuying ? 'BTC' : 'FB';
                    outTick = isBuying ? 'FB' : 'BTC';
                    // SVG иконка для BTC
                    inIcon = isBuying ? 'img/BTC.svg' : 'img/FB.png';
                    outIcon = isBuying ? 'img/FB.png' : 'img/BTC.svg';

                    if (isBuying) {
                        // Продаем sBTC -> получаем FB. Нужен баланс sBTC на InSwap
                        bal = poolReserves.user_sBTC || 0;
                    } else {
                        // Продаем FB -> получаем sBTC. Нужен баланс FB на InSwap
                        bal = userBalances.sFB || 0;
                    }
                }

                const iconInEl = document.getElementById('iconIn');
                const tickerInEl = document.getElementById('tickerIn');
                const iconOutEl = document.getElementById('iconOut');
                const tickerOutEl = document.getElementById('tickerOut');
                const balInEl = document.getElementById('balIn');

                if (iconInEl) iconInEl.src = inIcon;
                if (tickerInEl) tickerInEl.innerText = inTick;
                if (iconOutEl) iconOutEl.src = outIcon;
                if (tickerOutEl) tickerOutEl.innerText = outTick;
                if (balInEl) balInEl.innerText = `Bal: ${bal.toFixed(4)}`;

                // UPDATE BUTTON TEXT - просто "SWAP" для всех пар
                const btn = document.getElementById('swapBtn');
                if (btn) {
                    btn.innerText = 'SWAP';
                }

                updateWithdrawUI();
            }

            // connectWallet is already defined at the top of the script

            async function fetchReserves() {
                try {
                    // Проверяем кэш
                    const now = Date.now();
                    if (poolCache.data && now - poolCache.timestamp < poolCache.ttl) {
                        console.log('📦 Using cached pool data');
                        return poolCache.data;
                    }

                    // Fetch pool info based on current swap pair
                    let queryParams = '';
                    if (currentSwapPair === 'BTC_FB') {
                        // Пробуем прямой порядок
                        queryParams = `tick0=${T_SBTC}&tick1=${T_SFB}`;
                    } else {
                        queryParams = `tick0=${T_FENNEC}&tick1=${T_SFB}`;
                    }

                    let poolUrl = `${BACKEND_URL}?action=quote&${queryParams}`;

                    const json = await safeFetchJson(poolUrl, { timeoutMs: 12000, retries: 2 });
                    if (!json) throw new Error('Failed to fetch pool data');
                    console.log(`📊 Pool response for ${currentSwapPair}:`, json);

                    let data = null;
                    // Логика извлечения данных
                    if (json.data) {
                        if (json.data.tick0)
                            data = json.data; // Одиночный объект
                        else if (Array.isArray(json.data.list) && json.data.list.length > 0) data = json.data.list[0];
                    } else if (json.pool) {
                        data = json.pool;
                    }

                    // Если данных нет, и это пара BTC_FB, пробуем поменять тикеры местами
                    if (!data && currentSwapPair === 'BTC_FB') {
                        console.log('Retrying pool fetch with swapped tickers...');
                        queryParams = `tick0=${T_SFB}&tick1=${T_SBTC}`;
                        poolUrl = `${BACKEND_URL}?action=quote&${queryParams}&t=${now}`;
                        const retryJson = await safeFetchJson(poolUrl, { timeoutMs: 12000, retries: 1 });
                        if (retryJson.data && retryJson.data.tick0) {
                            data = retryJson.data;
                        } else if (retryJson.pool) {
                            data = retryJson.pool;
                        }
                    }

                    if (data) {
                        // Сохраняем активные тикеры, как они вернулись из API
                        activeTickers.tick0 = data.tick0;
                        activeTickers.tick1 = data.tick1;

                        console.log(
                            `📊 Pool data: tick0=${data.tick0}, tick1=${data.tick1}, amount0=${data.amount0}, amount1=${data.amount1}`
                        );

                        // Парсим резервы
                        if (currentSwapPair === 'FB_FENNEC') {
                            if (data.tick0.includes('FENNEC')) {
                                poolReserves.FENNEC = parseFloat(data.amount0);
                                poolReserves.sFB = parseFloat(data.amount1);
                            } else {
                                poolReserves.sFB = parseFloat(data.amount0);
                                poolReserves.FENNEC = parseFloat(data.amount1);
                            }
                        } else {
                            // sBTC - FB pair
                            // Проверяем точное совпадение или частичное
                            const isTick0BTC = data.tick0 === T_SBTC || data.tick0.includes('sBTC');

                            if (isTick0BTC) {
                                poolReserves.BTC = parseFloat(data.amount0);
                                poolReserves.sFB = parseFloat(data.amount1);
                            } else {
                                poolReserves.sFB = parseFloat(data.amount0);
                                poolReserves.BTC = parseFloat(data.amount1);
                            }
                        }

                        console.log(
                            `📊 Pool reserves: BTC=${poolReserves.BTC}, sFB=${poolReserves.sFB}, FENNEC=${poolReserves.FENNEC}`
                        );

                        const statusEl = document.getElementById('statusVal');
                        if (statusEl) statusEl.innerText = 'Active';
                        // Кэшируем данные
                        poolCache.data = data;
                        poolCache.timestamp = now;
                        // Если есть введенное значение, пересчитываем
                        if (document.getElementById('swapIn').value) calc();
                    } else {
                        console.warn('Pool data not found for query:', queryParams);
                        const statusEl2 = document.getElementById('statusVal');
                        if (statusEl2) statusEl2.innerText = 'Empty';
                    }
                } catch (e) {
                    console.warn('Pool fetch error', e);
                    const statusEl3 = document.getElementById('statusVal');
                    if (statusEl3) statusEl3.innerText = 'Offline';
                }
            }
            async function checkBalance() {
                if (!userAddress) return;
                try {
                    // ОПТИМИЗАЦИЯ: Используем batch endpoint для получения всех балансов за один запрос
                    const ticks = [T_SFB, T_FENNEC, T_SBTC].join(',');
                    const batchRes = await fetch(
                        `${BACKEND_URL}?action=balance_batch&address=${userAddress}&ticks=${ticks}`
                    ).then(r => r.json());

                    // Парсим результаты из batch ответа
                    const rFB = batchRes.data?.[T_SFB] || {};
                    const rFennec = batchRes.data?.[T_FENNEC] || {};
                    const rBTC = batchRes.data?.[T_SBTC] || {};

                    userBalances.sFB = parseFloat(rFB.data?.balance?.swap || rFB.data?.balance?.available || 0);
                    userBalances.FENNEC = parseFloat(
                        rFennec.data?.balance?.swap || rFennec.data?.balance?.available || 0
                    );
                    // Баланс sBTC внутри InSwap (для свапа)
                    poolReserves.user_sBTC = parseFloat(rBTC.data?.balance?.swap || rBTC.data?.balance?.available || 0);

                    const nativeBal = await window.unisat.getBalance();
                    walletBalances.sFB = nativeBal.total / 100000000;

                    // 2. Native FB Balance (Wallet) - уже загружен выше

                    // Get FENNEC wallet balance (BRC-20 in wallet) via UniSat API
                    try {
                        const fennecBalanceUrl = `${BACKEND_URL}?action=balance&address=${userAddress}&tick=${T_FENNEC}&walletOnly=true`;
                        const fennecWalletRes = await fetch(fennecBalanceUrl).then(r => r.json());
                        console.log('FENNEC balance response:', fennecWalletRes);
                        // Try multiple possible fields for balance
                        const balance =
                            fennecWalletRes.data?.availableBalance ||
                            fennecWalletRes.data?.transferableBalance ||
                            fennecWalletRes.data?.balance?.availableBalance ||
                            fennecWalletRes.data?.balance?.transferableBalance ||
                            fennecWalletRes.data?.balance?.available ||
                            fennecWalletRes.data?.balance?.transferable ||
                            0;
                        walletBalances.FENNEC = parseFloat(balance);
                        console.log('FENNEC wallet balance:', walletBalances.FENNEC);
                    } catch (e) {
                        console.warn('Failed to load FENNEC wallet balance:', e);
                        walletBalances.FENNEC = 0;
                    }

                    updatePnL();
                    updateUI();
                    if (typeof updateLiquidityBalancesUI === 'function') {
                        updateLiquidityBalancesUI();
                    }
                    const liqModal = document.getElementById('addLiquidityModal');
                    if (liqModal && !liqModal.classList.contains('hidden')) {
                        if (typeof loadLiquidityPoolData === 'function') {
                            loadLiquidityPoolData(currentLiquidityPair);
                        }
                    }
                } catch (e) {
                    console.warn('Balance check failed', e);
                }
            }

            // ===== PERSONAL PNL (MY STASH) =====
            function updatePnL() {
                try {
                    const pnlCard = document.getElementById('pnlCard');
                    if (!pnlCard) return; // Element doesn't exist, skip

                    // Check if user has FENNEC balance
                    const fennecBalance = userBalances.FENNEC || 0;

                    if (fennecBalance < 0.01) {
                        pnlCard.classList.add('hidden');
                        return;
                    }

                    // Show card
                    pnlCard.classList.remove('hidden');
                    const pnlAmount = document.getElementById('pnlAmount');
                    if (pnlAmount) {
                        const fennecBalNum =
                            typeof fennecBalance === 'number' ? fennecBalance : parseFloat(fennecBalance || 0);
                        pnlAmount.innerText = fennecBalNum.toFixed(2);
                    }

                    // Get current price from chart
                    const currentPriceEl = document.getElementById('chartPrice');
                    if (currentPriceEl && currentPriceEl.innerText !== '--') {
                        // ИСПРАВЛЕНИЕ: Используем точное значение из data-атрибута если есть, иначе парсим
                        const currentPrice = currentPriceEl.dataset.price
                            ? parseFloat(currentPriceEl.dataset.price)
                            : parseFloat(currentPriceEl.innerText);
                        if (!isNaN(currentPrice)) {
                            const valueInFB = fennecBalance * currentPrice;
                            const pnlPercent = document.getElementById('pnlPercent');
                            if (pnlPercent) {
                                pnlPercent.innerText = `≈ ${valueInFB.toFixed(2)} FB`;
                                pnlPercent.className = 'text-lg font-bold font-mono text-fennec';
                            }
                        }
                    }
                } catch (e) {
                    console.warn('PnL update error:', e);
                }
            }

            // ===== THE DIG ANIMATION =====
            let digInterval = null;
            function startDiggingAnimation() {
                const btn = document.getElementById('swapBtn');
                if (!btn) return;

                // Save original text
                if (!btn.dataset.originalText) btn.dataset.originalText = btn.innerText;

                // Change button
                btn.innerHTML = `
                                                            <div class="flex items-center justify-center gap-3">
                                                                <span class="text-xl digging-fox">⛏️</span>
                                                                <span>DIGGING FOR TOKENS...</span>
                                                            </div>
                                                        `;

                // Clear previous interval if exists
                if (digInterval) clearInterval(digInterval);

                // Flying dirt effect
                digInterval = setInterval(() => {
                    if (!btn.disabled) {
                        clearInterval(digInterval);
                        digInterval = null;
                        return;
                    }

                    const rect = btn.getBoundingClientRect();
                    const dirt = document.createElement('div');
                    dirt.className = 'dirt-particle';
                    // Random position around button
                    dirt.style.left = rect.left + rect.width / 2 + (Math.random() * 40 - 20) + 'px';
                    dirt.style.top = rect.top + 20 + 'px';
                    dirt.style.animation = `dirtFly ${0.5 + Math.random()}s ease-out forwards`;
                    document.body.appendChild(dirt);

                    setTimeout(() => dirt.remove(), 1000);
                }, 100);
            }

            function stopDiggingAnimation() {
                const btn = document.getElementById('swapBtn');
                if (digInterval) {
                    clearInterval(digInterval);
                    digInterval = null;
                }
                if (btn && btn.dataset.originalText) {
                    btn.innerText = btn.dataset.originalText;
                }
            }

            // ===== WHALE WATCHER =====
            let lastWhaleTx = '';

            // ИСПРАВЛЕНИЕ: Кэш для swap_history чтобы не делать дублирующиеся запросы
            let swapHistoryCache = {
                data: null,
                timestamp: 0,
                ttl: 30000 // 30 секунд кэш
            };

            // ИСПРАВЛЕНИЕ: Единая функция загрузки swap_history для всех вкладок
            async function loadSwapHistory(useCache = true) {
                const now = Date.now();

                // Используем кэш если он свежий
                if (useCache && swapHistoryCache.data && now - swapHistoryCache.timestamp < swapHistoryCache.ttl) {
                    console.log('📦 Using cached swap history');
                    return swapHistoryCache.data;
                }

                try {
                    console.log('📡 Loading swap history (all pairs)...');
                    // ИСПРАВЛЕНИЕ: Загружаем обе пары одним запросом (параллельно)
                    const [sResFB_FENNEC, sResBTC_FB] = await Promise.all([
                        safeFetchJson(`${BACKEND_URL}?action=swap_history&start=0&limit=10&tick=sFB___000/FENNEC`, {
                            timeoutMs: 12000,
                            retries: 2
                        }).then(r => r || { code: -1 }),
                        safeFetchJson(`${BACKEND_URL}?action=swap_history&start=0&limit=10&tick=sBTC___000/sFB___000`, {
                            timeoutMs: 12000,
                            retries: 2
                        }).then(r => r || { code: -1 })
                    ]);

                    const result = {
                        fbFennec: sResFB_FENNEC,
                        btcFb: sResBTC_FB,
                        timestamp: now
                    };

                    // Сохраняем в кэш
                    swapHistoryCache.data = result;
                    swapHistoryCache.timestamp = now;

                    console.log('✅ Swap history loaded and cached');
                    return result;
                } catch (e) {
                    console.warn('Swap history load error', e);
                    return swapHistoryCache.data || { fbFennec: { code: -1 }, btcFb: { code: -1 } };
                }
            }

            async function checkWhales() {
                try {
                    // ИСПРАВЛЕНИЕ: Используем кэшированные данные вместо нового запроса
                    const swapData = await loadSwapHistory(true);
                    const sResFB_FENNEC = swapData.fbFennec;

                    if (sResFB_FENNEC.code === 0 && sResFB_FENNEC.data?.list?.length > 0) {
                        const tx = sResFB_FENNEC.data.list[0]; // Most recent

                        // If this is a new transaction (not the one we saw last time)
                        if (tx.txid !== lastWhaleTx) {
                            lastWhaleTx = tx.txid;

                            // Determine direction and amounts
                            const tickIn = tx.tickIn || tx.tick0 || '';
                            const tickOut = tx.tickOut || tx.tick1 || '';
                            const amountIn = parseFloat(tx.amountIn || tx.amount0 || tx.amount || 0);
                            const amountOut = parseFloat(tx.amountOut || tx.amount1 || 0);

                            const isFennecToFB = tickIn.includes('FENNEC');
                            const fennecAmount = isFennecToFB ? amountIn : amountOut;
                            const fbAmount = isFennecToFB ? amountOut : amountIn;

                            // Whale threshold: > 1000 FENNEC or > 10 FB
                            if (fennecAmount > 1000 || fbAmount > 10) {
                                showWhaleAlert(fennecAmount, fbAmount, isFennecToFB);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Whale check error:', e);
                }
            }

            function showWhaleAlert(fennecAmount, fbAmount, isFennecToFB) {
                const el = document.getElementById('whaleWatcher');
                const msg = document.getElementById('whaleMsg');

                el.classList.remove('hidden');
                // Small delay for slide-in animation
                setTimeout(() => el.classList.remove('translate-y-[200%]'), 100);

                // Format message
                const direction = isFennecToFB ? 'FENNEC → FB' : 'FB → FENNEC';
                const mainAmount = isFennecToFB ? fennecAmount : fbAmount;
                const mainTick = isFennecToFB ? 'FENNEC' : 'FB';

                msg.innerHTML = `Wow! Someone just swapped <span class="text-fennec font-bold">${mainAmount.toFixed(0)} ${mainTick}</span>! (${direction})`;

                // Hide after 7 seconds
                setTimeout(() => {
                    el.classList.add('translate-y-[200%]');
                }, 7000);
            }

            // ИСПРАВЛЕНИЕ: Отключен автоматический whale watching для снижения нагрузки на API
            // Whale watching теперь происходит только при обновлении истории транзакций
            // setInterval(checkWhales, 10000); // Отключено

            // ИСПРАВЛЕНИЕ: Увеличен debounce для снижения количества запросов к API
            let timer, reverseTimer;
            function debounceQuote() {
                clearTimeout(timer);
                timer = setTimeout(() => calc(), 500);
            } // Увеличено с 100ms до 500ms
            function debounceReverse() {
                clearTimeout(reverseTimer);
                reverseTimer = setTimeout(() => calcReverse(), 500);
            } // Увеличено с 100ms до 500ms

            async function calc() {
                const val = parseFloat(document.getElementById('swapIn').value);
                if (!val) {
                    document.getElementById('swapOut').value = '';
                    return 0;
                }

                // Определяем тикеры для запроса
                let tickIn, tickOut;
                if (currentSwapPair === 'FB_FENNEC') {
                    tickIn = isBuying ? T_SFB : T_FENNEC;
                    tickOut = isBuying ? T_FENNEC : T_SFB;
                } else {
                    // BTC_FB
                    tickIn = isBuying ? T_SBTC : T_SFB;
                    tickOut = isBuying ? T_SFB : T_SBTC;
                }

                // Используем quote_swap API для получения точного курса
                try {
                    // Формируем URL правильно - проверяем, есть ли уже параметры в BACKEND_URL
                    const separator = BACKEND_URL.includes('?') ? '&' : '?';
                    // ВАЖНО: address обязателен для quote_swap, если нет - используем пустую строку или подключаем кошелек
                    if (!userAddress) {
                        console.warn('⚠️ No address for quote_swap, connecting wallet...');
                        connectWallet();
                        // Используем fallback расчет если адрес недоступен
                        throw new Error('Address required');
                    }
                    const quoteUrl = `${BACKEND_URL}${separator}action=quote_swap&exactType=exactIn&tickIn=${tickIn}&tickOut=${tickOut}&amount=${val}&address=${userAddress}`;
                    console.log('📊 Quote request:', quoteUrl);
                    const quoteRes = await fetch(quoteUrl).then(r => {
                        if (!r.ok) {
                            console.error('Quote API error:', r.status, r.statusText);
                            return r
                                .json()
                                .catch(() => ({ code: -1, msg: `HTTP ${r.status}`, error: 'Unknown action' }));
                        }
                        return r.json();
                    });

                    console.log('📊 Quote response:', quoteRes);

                    if (quoteRes.code === 0 && quoteRes.data) {
                        // ЛОГИРУЕМ СЫРОЕ ЗНАЧЕНИЕ ДЛЯ ОТЛАДКИ
                        console.log('Raw expect value:', quoteRes.data.expect);

                        // ЯВНАЯ ПРОВЕРКА: Сначала ищем expect
                        let rawAmount = quoteRes.data.expect;

                        // Если expect нет, ищем другие поля
                        if (!rawAmount) {
                            rawAmount =
                                quoteRes.data.amountOut ||
                                quoteRes.data.outAmount ||
                                quoteRes.data.receiveAmount ||
                                quoteRes.data.amount;
                        }

                        const amountOut = parseFloat(rawAmount);

                        console.log(`Parsed amountOut: ${amountOut} from raw: ${rawAmount}`);

                        if (amountOut > 0) {
                            document.getElementById('swapOut').value = amountOut.toFixed(6);

                            // Обновляем курс
                            const rate = amountOut / val;
                            let rateText;
                            if (currentSwapPair === 'FB_FENNEC') {
                                rateText = `1 ${isBuying ? 'FB' : 'FENNEC'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FENNEC' : 'FB'}`;
                            } else {
                                // BTC_FB
                                rateText = `1 ${isBuying ? 'BTC' : 'FB'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FB' : 'BTC'}`;
                            }
                            document.getElementById('rateVal').innerText = rateText;
                            return amountOut;
                        } else {
                            console.warn('quote_swap returned invalid amountOut:', quoteRes.data);
                        }
                    } else {
                        console.warn('quote_swap failed:', quoteRes);
                    }
                } catch (e) {
                    console.error('quote_swap error:', e);
                    console.warn('quote_swap failed, using fallback calculation:', e);
                }

                // Fallback: расчет из резервов (аналогично FB-FENNEC)
                let rIn, rOut;
                if (currentSwapPair === 'FB_FENNEC') {
                    rIn = isBuying ? poolReserves.sFB : poolReserves.FENNEC;
                    rOut = isBuying ? poolReserves.FENNEC : poolReserves.sFB;
                } else {
                    // BTC_FB - используем резервы из пула sBTC/sFB
                    rIn = isBuying ? poolReserves.BTC : poolReserves.sFB;
                    rOut = isBuying ? poolReserves.sFB : poolReserves.BTC;
                }
                if (rIn === 0 || rOut === 0) {
                    console.warn('Pool reserves are zero, cannot calculate');
                    return 0;
                }
                // AMM формула: out = (amountIn * 985 * rOut) / (rIn * 1000 + amountIn * 985)
                const fee = val * 985;
                const out = (fee * rOut) / (rIn * 1000 + fee);
                const rate = out / val;
                document.getElementById('swapOut').value = out.toFixed(6);
                // Update rate display based on current pair
                let rateText;
                if (currentSwapPair === 'FB_FENNEC') {
                    rateText = `1 ${isBuying ? 'FB' : 'FENNEC'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FENNEC' : 'FB'}`;
                } else {
                    // BTC_FB
                    rateText = `1 ${isBuying ? 'BTC' : 'FB'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FB' : 'BTC'}`;
                }
                document.getElementById('rateVal').innerText = rateText;
                return out;
            }

            async function calcReverse() {
                const desiredOut = parseFloat(document.getElementById('swapOut').value);
                if (!desiredOut) {
                    document.getElementById('swapIn').value = '';
                    return;
                }

                // Определяем тикеры для запроса
                let tickIn, tickOut;
                if (currentSwapPair === 'FB_FENNEC') {
                    tickIn = isBuying ? T_SFB : T_FENNEC;
                    tickOut = isBuying ? T_FENNEC : T_SFB;
                } else {
                    // BTC_FB
                    tickIn = isBuying ? T_SBTC : T_SFB;
                    tickOut = isBuying ? T_SFB : T_SBTC;
                }

                // Используем quote_swap API с exactType=exactOut для обратного расчета
                try {
                    const separator = BACKEND_URL.includes('?') ? '&' : '?';
                    // ВАЖНО: address обязателен для quote_swap
                    if (!userAddress) {
                        console.warn('⚠️ No address for quote_swap, connecting wallet...');
                        connectWallet();
                        throw new Error('Address required');
                    }
                    const quoteUrl = `${BACKEND_URL}${separator}action=quote_swap&exactType=exactOut&tickIn=${tickIn}&tickOut=${tickOut}&amount=${desiredOut}&address=${userAddress}`;
                    const quoteRes = await fetch(quoteUrl).then(r => {
                        if (!r.ok) {
                            console.error('Quote API error (reverse):', r.status, r.statusText);
                            return r.json().catch(() => ({ code: -1, msg: `HTTP ${r.status}` }));
                        }
                        return r.json();
                    });

                    if (quoteRes.code === 0 && quoteRes.data) {
                        // ЛОГИРУЕМ СЫРОЕ ЗНАЧЕНИЕ ДЛЯ ОТЛАДКИ
                        console.log('Raw expect value (reverse):', quoteRes.data.expect);

                        // ЯВНАЯ ПРОВЕРКА: Сначала ищем expect
                        let rawAmount = quoteRes.data.expect;

                        // Если expect нет, ищем другие поля
                        if (!rawAmount) {
                            rawAmount =
                                quoteRes.data.amountIn ||
                                quoteRes.data.inAmount ||
                                quoteRes.data.payAmount ||
                                quoteRes.data.amount;
                        }

                        const amountIn = parseFloat(rawAmount);

                        console.log(`Parsed amountIn: ${amountIn} from raw: ${rawAmount}`);

                        if (amountIn > 0) {
                            document.getElementById('swapIn').value = amountIn.toFixed(6);

                            // Обновляем курс
                            const rate = desiredOut / amountIn;
                            let rateText;
                            if (currentSwapPair === 'FB_FENNEC') {
                                rateText = `1 ${isBuying ? 'FB' : 'FENNEC'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FENNEC' : 'FB'}`;
                            } else {
                                // BTC_FB
                                rateText = `1 ${isBuying ? 'BTC' : 'FB'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FB' : 'BTC'}`;
                            }
                            document.getElementById('rateVal').innerText = rateText;
                            return;
                        } else {
                            console.warn('quote_swap returned invalid amountIn:', quoteRes.data);
                        }
                    } else {
                        console.warn('quote_swap failed:', quoteRes);
                    }
                } catch (e) {
                    console.warn('quote_swap failed, using fallback calculation:', e);
                }

                // Fallback: расчет из резервов (старый метод)
                let rIn, rOut;
                if (currentSwapPair === 'FB_FENNEC') {
                    rIn = isBuying ? poolReserves.sFB : poolReserves.FENNEC;
                    rOut = isBuying ? poolReserves.FENNEC : poolReserves.sFB;
                } else {
                    // BTC_FB
                    rIn = isBuying ? poolReserves.BTC : poolReserves.sFB;
                    rOut = isBuying ? poolReserves.sFB : poolReserves.BTC;
                }
                if (rOut === 0) return;

                // Обратная формула AMM: amountIn = (desiredOut * rIn * 1000) / ((rOut - desiredOut) * 985)
                const numerator = desiredOut * rIn * 1000;
                const denominator = (rOut - desiredOut) * 985;
                if (denominator <= 0) return alert('Amount too large for pool');

                const amountIn = numerator / denominator;
                document.getElementById('swapIn').value = amountIn.toFixed(6);

                const rate = desiredOut / amountIn;
                // Update rate display based on current pair
                let rateText;
                if (currentSwapPair === 'FB_FENNEC') {
                    rateText = `1 ${isBuying ? 'FB' : 'FENNEC'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FENNEC' : 'FB'}`;
                } else {
                    // BTC_FB
                    rateText = `1 ${isBuying ? 'BTC' : 'FB'} ≈ ${rate.toFixed(2)} ${isBuying ? 'FB' : 'BTC'}`;
                }
                document.getElementById('rateVal').innerText = rateText;
            }

            async function doSwap() {
                if (!userAddress) return connectWallet();

                // CHECK NETWORK FIRST
                try {
                    await checkFractalNetwork();
                } catch (e) {
                    document.getElementById('errorMsg').innerText = e.message;
                    document.getElementById('errorModal').classList.remove('hidden');
                    return;
                }

                let amount = parseFloat(document.getElementById('swapIn').value);
                if (!amount) {
                    if (typeof showNotification === 'function') showNotification('Enter amount', 'warning', 2000);
                    return;
                }

                // Check balance
                let bal;
                if (currentSwapPair === 'FB_FENNEC') {
                    bal = isBuying ? userBalances.sFB : userBalances.FENNEC;
                } else {
                    // BTC_FB
                    bal = isBuying ? poolReserves.user_sBTC || 0 : userBalances.sFB;
                }

                if (currentSwapPair === 'FB_FENNEC' && isBuying) {
                    const feeBuffer = 0.05;
                    const maxAllowed = Math.max(0, bal - feeBuffer);
                    if (maxAllowed <= 0) {
                        if (typeof showNotification === 'function') {
                            showNotification('Not enough FB after reserving 0.05 for fees', 'warning', 2500);
                        }
                        return;
                    }
                    if (amount > maxAllowed) {
                        amount = maxAllowed;
                        document.getElementById('swapIn').value = amount.toFixed(8);
                        calc();
                        if (typeof showNotification === 'function') {
                            showNotification('Reserved 0.05 FB for fees', 'info', 2200);
                        }
                    }
                }

                if (bal < amount) {
                    document.getElementById('depositLinkModal').classList.remove('hidden');
                    return;
                }

                const btn = document.getElementById('swapBtn');
                btn.disabled = true;
                startDiggingAnimation();

                try {
                    if (!userPubkey)
                        try {
                            userPubkey = await window.unisat.getPublicKey();
                        } catch (e) {}

                    // Determine tickers - упрощенная логика
                    let tickIn, tickOut;

                    // Для пары BTC_FB всегда используем правильные тикеры
                    if (currentSwapPair === 'BTC_FB') {
                        tickIn = isBuying ? T_SBTC : T_SFB;
                        tickOut = isBuying ? T_SFB : T_SBTC;
                    } else {
                        // Для пары FB_FENNEC
                        if (isBuying) {
                            tickIn = T_SFB; // Платим FB
                            tickOut = T_FENNEC; // Получаем FENNEC
                        } else {
                            tickIn = T_FENNEC; // Платим FENNEC
                            tickOut = T_SFB; // Получаем FB
                        }
                    }

                    // 1. Получаем актуальный Quote перед созданием свапа
                    // Это критично для избежания slippage error
                    const quoteUrl = `${BACKEND_URL}?action=quote_swap&exactType=exactIn&tickIn=${tickIn}&tickOut=${tickOut}&amount=${amount}${userAddress ? `&address=${userAddress}` : ''}`;
                    console.log('🔄 Getting fresh quote for swap:', quoteUrl);
                    const quoteRes = await fetch(quoteUrl).then(r => {
                        if (!r.ok) {
                            console.error('Quote API error:', r.status, r.statusText);
                            return r.json().catch(() => ({ code: -1, msg: `HTTP ${r.status}` }));
                        }
                        return r.json();
                    });
                    console.log('🔄 Quote response:', quoteRes);

                    let expectedOut = 0;
                    if (quoteRes.code === 0 && quoteRes.data) {
                        // ЯВНАЯ ПРОВЕРКА: Сначала ищем expect
                        let rawAmount = quoteRes.data.expect;

                        // Если expect нет, ищем другие поля
                        if (!rawAmount) {
                            rawAmount =
                                quoteRes.data.amountOut ||
                                quoteRes.data.outAmount ||
                                quoteRes.data.receiveAmount ||
                                quoteRes.data.amount;
                        }

                        expectedOut = parseFloat(rawAmount);
                        console.log(`✅ Got quote expect: ${expectedOut} from raw: ${rawAmount}`);
                    }

                    if (!expectedOut || expectedOut <= 0) {
                        // Если quote не сработал, берем из поля ввода, но это рискованно
                        expectedOut = parseFloat(document.getElementById('swapOut').value);
                        console.warn('⚠️ Using value from input field:', expectedOut);
                    }

                    if (!expectedOut || isNaN(expectedOut) || expectedOut <= 0) {
                        throw new Error('Invalid amount: Please enter a valid swap amount');
                    }

                    console.log(`Swapping ${amount} ${tickIn} -> Expecting ${expectedOut} ${tickOut}`);

                    // 2. Create Swap
                    const ts = Math.floor(Date.now() / 1000);
                    // IMPORTANT: feeTick always sFB___000 (not FENNEC!)
                    // ВАЖНО: Передаем ОЖИДАЕМУЮ сумму (без вычета слиппейджа)
                    // InSwap сам применит slippage к amountOut на основе параметра slippage
                    const params = new URLSearchParams({
                        address: userAddress,
                        tickIn: tickIn,
                        tickOut: tickOut,
                        amountIn: amount.toString(),
                        amountOut: expectedOut.toString(), // ВАЖНО: Передаем ОЖИДАЕМУЮ сумму (без вычета слиппейджа)
                        slippage: '0.005', // InSwap сам применит этот % к amountOut
                        exactType: 'exactIn',
                        ts: ts,
                        feeTick: T_SFB, // Always sFB___000 for fees!
                        payType: 'tick'
                    });

                    const url = `${BACKEND_URL}?action=create_swap&${params.toString()}`;
                    console.log('=== SWAP CREATE ===');
                    console.log('URL:', url);
                    const res = await fetch(url).then(r => r.json());
                    console.log('Response:', res);

                    // Обработка ошибки -11 (System recovery in progress)
                    if (res.code === -11) {
                        throw new Error(
                            '⚠️ InSwap is currently under maintenance (System Recovery). Please try again in 10-15 minutes.'
                        );
                    }

                    if (res.code !== 0) throw new Error(res.msg || 'Swap Error');
                    const preSwap = res.data;

                    const signatures = [];
                    for (let msg of preSwap.signMsgs) {
                        let m = typeof msg === 'object' ? msg.text || msg.id : msg;
                        await new Promise(r => setTimeout(r, 500));
                        const sig = await window.unisat.signMessage(m, 'bip322-simple');
                        signatures.push(sig);
                    }

                    // 3. Submit (pubkey goes in HEADERS, not body!)
                    const body = {
                        address: userAddress,
                        tickIn: tickIn,
                        tickOut: tickOut,
                        amountIn: amount.toString(),
                        amountOut: expectedOut.toString(), // ИСПРАВЛЕНО: используем expectedOut вместо minOut
                        slippage: '0.005',
                        exactType: 'exactIn',
                        ts: ts,
                        feeTick: T_SFB, // Always sFB___000 for fees!
                        payType: 'tick',
                        feeAmount: preSwap.feeAmount,
                        feeTickPrice: preSwap.feeTickPrice,
                        sigs: signatures,
                        rememberPayType: false
                    };

                    console.log('Submit body:', JSON.stringify(body, null, 2));
                    const sub = await fetch(`${BACKEND_URL}?action=submit_swap`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(body)
                    }).then(r => r.json());

                    console.log('Submit response:', sub);
                    if (sub.code === 0) {
                        triggerSwapSuccessFx();
                        if (typeof showNotification === 'function') showNotification('Swap successful', 'swap', 3200);
                        document.getElementById('successTxId').innerText = sub.data || sub.txid || 'Swap success!';
                        document.getElementById('successModal').classList.remove('hidden');
                        setTimeout(checkBalance, 2000);
                    } else throw new Error(sub.msg || 'Submission failed');
                } catch (e) {
                    console.error('❌ Swap error:', e);
                    if (typeof showNotification === 'function')
                        showNotification(e?.message || String(e), 'error', 4500);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    stopDiggingAnimation();
                    btn.disabled = false;
                }
            }

            // DEPOSIT (STRICTLY FOLLOWS SCREENSHOT PARAMS)
            async function setDepositToken(tok) {
                depositToken = tok;
                document.getElementById('dep-btc').className =
                    `flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer ${tok === 'BTC' ? 'border-fennec text-fennec bg-fennec/10' : 'border-gray-700 text-gray-500 hover:text-white'}`;
                document.getElementById('dep-sfb').className =
                    `flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer ${tok === 'sFB' ? 'border-fennec text-fennec bg-fennec/10' : 'border-gray-700 text-gray-500 hover:text-white'}`;
                document.getElementById('dep-fennec').className =
                    `flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer ${tok === 'FENNEC' ? 'border-fennec text-fennec bg-fennec/10' : 'border-gray-700 text-gray-500 hover:text-white'}`;
                document.getElementById('dep-native-ui').style.display =
                    tok === 'sFB' || tok === 'BTC' ? 'block' : 'none';
                document.getElementById('dep-brc20-ui').style.display = tok === 'FENNEC' ? 'block' : 'none';

                // Update label based on token
                const labelEl = document.querySelector('#dep-native-ui span');
                if (labelEl) labelEl.innerText = tok === 'BTC' ? 'BTC' : 'FB';

                // Load fees when switching tokens
                if (tok === 'sFB' || tok === 'BTC') {
                    await loadFees('deposit');
                }

                // Update balance display
                const balanceDisplayEl = document.getElementById('depBalance');

                // Refresh balance for the selected token
                if (userAddress) {
                    if (tok === 'FENNEC') {
                        // Load FENNEC inscriptions (cards)
                        loadFennecInscriptions();
                    } else if (tok === 'BTC') {
                        // For BTC, get balance from Bitcoin Mainnet via Worker API (no network switch needed)
                        try {
                            const btcBalanceRes = await fetch(
                                `${BACKEND_URL}?action=btc_balance&address=${userAddress}`
                            ).then(r => r.json());
                            walletBalances.BTC = parseFloat(btcBalanceRes.data?.balance || 0);
                            if (balanceDisplayEl) {
                                balanceDisplayEl.innerText = `Balance: ${walletBalances.BTC.toFixed(8)} BTC`;
                            }
                        } catch (e) {
                            console.warn('Failed to refresh BTC balance:', e);
                            walletBalances.BTC = 0;
                            if (balanceDisplayEl) {
                                balanceDisplayEl.innerText = `Balance: 0.00000000 BTC`;
                            }
                        }
                    } else {
                        // For sFB (Fractal Bitcoin)
                        try {
                            const currentChain = await window.unisat.getChain();
                            const wasOnBitcoin = currentChain === 'BITCOIN_MAINNET';

                            if (wasOnBitcoin) {
                                await window.unisat.switchChain('FRACTAL_BITCOIN_MAINNET');
                            }

                            const nativeBal = await window.unisat.getBalance();
                            walletBalances.sFB = nativeBal.total / 100000000;

                            if (balanceDisplayEl) {
                                balanceDisplayEl.innerText = `Balance: ${walletBalances.sFB.toFixed(8)} FB`;
                            }

                            // Switch back to Bitcoin if we were on it
                            if (wasOnBitcoin) {
                                await window.unisat.switchChain('BITCOIN_MAINNET');
                            }
                        } catch (e) {
                            console.warn('Failed to refresh FB balance:', e);
                            walletBalances.sFB = 0;
                            if (balanceDisplayEl) {
                                balanceDisplayEl.innerText = `Balance: 0.00000000 FB`;
                            }
                        }
                    }
                } else {
                    // No wallet connected
                    if (balanceDisplayEl) {
                        balanceDisplayEl.innerText = tok === 'BTC' ? 'Balance: -- BTC' : 'Balance: -- FB';
                    }
                }

                let bal = 0;
                if (tok === 'BTC') {
                    bal = walletBalances.BTC || 0;
                } else if (tok === 'sFB') {
                    bal = walletBalances.sFB;
                } else {
                    bal = walletBalances.FENNEC;
                }
                const minText = tok === 'sFB' ? ' (Min: 1 FB)' : tok === 'BTC' ? ' (Min: 0.00001 BTC)' : '';
                const balEl = document.getElementById('dep-bal');
                if (balEl) balEl.innerText = `Wallet Balance: ${bal.toFixed(8)}${minText}`;
            }

            function setDepositFee(speed) {
                // Reset all buttons first
                const mediumEl = document.getElementById('dep-fee-medium');
                const fastEl = document.getElementById('dep-fee-fast');
                const customEl = document.getElementById('dep-fee-custom');
                const customInput = document.getElementById('dep-fee-custom-input');

                if (speed === 'custom') {
                    if (customInput) {
                        customInput.style.display = 'block';
                        customInput.focus();
                    }
                    // Highlight custom button, reset others
                    if (customEl)
                        customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-fennec bg-fennec/10 text-fennec`;
                    if (mediumEl)
                        mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    if (fastEl)
                        fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    return;
                }

                depositFeeRate = speed === 'fast' ? fractalFees.fastestFee : fractalFees.halfHourFee;
                // Update UI - only one button active
                if (mediumEl)
                    mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer ${speed === 'medium' ? 'border-fennec bg-fennec/10 text-fennec' : 'border-white/10 text-gray-500 hover:text-white'}`;
                if (fastEl)
                    fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer ${speed === 'fast' ? 'border-fennec bg-fennec/10 text-fennec' : 'border-white/10 text-gray-500 hover:text-white'}`;
                if (customEl)
                    customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                if (customInput) customInput.style.display = 'none';
            }

            function setDepositFeeCustom(value) {
                const fee = parseFloat(value);
                if (fee && fee >= 1) {
                    depositFeeRate = fee;
                    const customEl = document.getElementById('dep-fee-custom');
                    const mediumEl = document.getElementById('dep-fee-medium');
                    const fastEl = document.getElementById('dep-fee-fast');
                    if (customEl)
                        customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-fennec bg-fennec/10 text-fennec`;
                    if (mediumEl)
                        mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    if (fastEl)
                        fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                }
            }

            function setWithdrawFee(speed) {
                // Reset all buttons first
                const mediumEl = document.getElementById('wd-fee-medium');
                const fastEl = document.getElementById('wd-fee-fast');
                const customEl = document.getElementById('wd-fee-custom');
                const customInput = document.getElementById('wd-fee-custom-input');

                if (speed === 'custom') {
                    if (customInput) {
                        customInput.style.display = 'block';
                        customInput.focus();
                    }
                    // Highlight custom button, reset others
                    if (customEl)
                        customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-fennec bg-fennec/10 text-fennec`;
                    if (mediumEl)
                        mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    if (fastEl)
                        fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    return;
                }

                withdrawFeeRate = speed === 'fast' ? fractalFees.fastestFee : fractalFees.halfHourFee;
                // Update UI - only one button active
                if (mediumEl)
                    mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer ${speed === 'medium' ? 'border-fennec bg-fennec/10 text-fennec' : 'border-white/10 text-gray-500 hover:text-white'}`;
                if (fastEl)
                    fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer ${speed === 'fast' ? 'border-fennec bg-fennec/10 text-fennec' : 'border-white/10 text-gray-500 hover:text-white'}`;
                if (customEl)
                    customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                if (customInput) customInput.style.display = 'none';
            }

            function setWithdrawFeeCustom(value) {
                const fee = parseFloat(value);
                if (fee && fee >= 1) {
                    withdrawFeeRate = fee;
                    const customEl = document.getElementById('wd-fee-custom');
                    const mediumEl = document.getElementById('wd-fee-medium');
                    const fastEl = document.getElementById('wd-fee-fast');
                    if (customEl)
                        customEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-fennec bg-fennec/10 text-fennec`;
                    if (mediumEl)
                        mediumEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                    if (fastEl)
                        fastEl.className = `flex-1 py-2 text-xs font-bold border transition cursor-pointer border-white/10 text-gray-500 hover:text-white`;
                }
            }

            window.setDepositFeeCustom = setDepositFeeCustom;
            window.setWithdrawFeeCustom = setWithdrawFeeCustom;

            async function loadFees(type) {
                try {
                    const res = await fetch(`${BACKEND_URL}?action=gas`)
                        .then(r => r.json())
                        .catch(() => ({}));
                    if (res.fastestFee && res.halfHourFee && res.hourFee) {
                        fractalFees = res;
                        // Update fee display
                        if (type === 'deposit' || type === 'both') {
                            const mediumEl = document.getElementById('dep-fee-medium-value');
                            const fastEl = document.getElementById('dep-fee-fast-value');
                            if (mediumEl) mediumEl.innerText = `${res.halfHourFee} sat/vB`;
                            if (fastEl) fastEl.innerText = `${res.fastestFee} sat/vB`;
                        }
                        if (type === 'withdraw' || type === 'both') {
                            const mediumEl = document.getElementById('wd-fee-medium-value');
                            const fastEl = document.getElementById('wd-fee-fast-value');
                            if (mediumEl) mediumEl.innerText = `${res.halfHourFee} sat/vB`;
                            if (fastEl) fastEl.innerText = `${res.fastestFee} sat/vB`;
                        }
                        // Set default to medium
                        if (type === 'deposit' || type === 'both') {
                            setDepositFee('medium');
                        }
                        if (type === 'withdraw' || type === 'both') {
                            setWithdrawFee('medium');
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load fees:', e);
                }
            }

            // Make fee functions globally available
            window.setDepositFee = setDepositFee;
            window.setWithdrawFee = setWithdrawFee;
            window.loadFees = loadFees;
            async function doDeposit() {
                // Route to correct function based on token
                if (depositToken === 'FENNEC') {
                    return doDepositFennec();
                }

                if (depositToken === 'BTC') {
                    return doDepositBTC();
                }

                // FB deposit (native)
                if (!userAddress) return connectWallet();

                // CHECK NETWORK FIRST
                try {
                    await checkFractalNetwork();
                } catch (e) {
                    document.getElementById('errorMsg').innerText = e.message;
                    document.getElementById('errorModal').classList.remove('hidden');
                    return;
                }

                const amount = parseFloat(document.getElementById('depAmount').value);
                if (!amount || amount < 1) return alert('Enter amount (min 1 FB)');
                const btn = document.getElementById('btnDeposit');
                btn.innerText = 'SIGNING...';
                btn.disabled = true;
                try {
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();
                    const url = `${BACKEND_URL}?action=create_deposit&pubkey=${userPubkey}&address=${userAddress}&tick=FB&amount=${amount}&assetType=btc&networkType=FRACTAL_BITCOIN_MAINNET&feeRate=${depositFeeRate}`;
                    console.log('=== DEPOSIT CREATE ===');
                    console.log('URL:', url);
                    const res = await fetch(url).then(r => r.json());
                    console.log('Response:', res);
                    if (res.code !== 0) throw new Error(res.msg || 'Failed to create deposit');
                    if (!res.data?.psbt) throw new Error('No PSBT in response');

                    // Подписываем PSBT - пусть UniSat сам определит какие входы подписывать
                    console.log('Signing PSBT...');
                    const signedPsbt = await window.unisat.signPsbt(res.data.psbt, { autoFinalized: false });
                    console.log('✅ PSBT signed');

                    const confirmBody = {
                        address: userAddress,
                        amount: amount.toString(),
                        assetType: 'btc',
                        networkType: 'FRACTAL_BITCOIN_MAINNET',
                        psbt: signedPsbt,
                        pubkey: userPubkey,
                        tick: 'FB'
                    };

                    console.log('Confirming deposit...');
                    const conf = await fetch(`${BACKEND_URL}?action=confirm_deposit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(confirmBody)
                    }).then(r => r.json());

                    console.log('Confirm response:', conf);
                    if (conf.code === 0) {
                        const txid = conf.data?.txid || conf.data || 'Deposit sent!';

                        // Auto-swap BTC to FB after deposit (only for BTC deposits)
                        if (depositToken === 'BTC') {
                            btn.innerText = 'SWAPPING BTC TO FB...';
                            try {
                                // Wait a bit for deposit to be processed
                                await new Promise(r => setTimeout(r, 3000));

                                // Get current balance after deposit
                                await checkBalance();
                                const availableBTC = userBalances.sFB; // After deposit, BTC becomes FB balance

                                if (availableBTC > 0.1) {
                                    // If we have at least 0.1 FB
                                    console.log(`Auto-swapping ${availableBTC} FB (from BTC deposit)...`);
                                    // No swap needed - BTC deposit already becomes FB
                                    console.log('✅ BTC deposit converted to FB automatically!');
                                }
                            } catch (swapError) {
                                console.warn('Auto-conversion check failed (deposit still successful):', swapError);
                            }
                        }

                        trackDepositProgress(txid, depositToken);
                    } else throw new Error(conf.msg || 'Deposit confirmation failed');
                } catch (e) {
                    console.error('❌ Deposit error:', e);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    btn.innerText = 'DEPOSIT';
                    btn.disabled = false;
                }
            }

            async function doDepositBTC() {
                if (!userAddress) return connectWallet();

                // For BTC deposit from Bitcoin Mainnet, we need to switch to Bitcoin Mainnet first
                // Then use Simple Bridge to deposit to Fractal Bitcoin

                const amount = parseFloat(document.getElementById('depAmount').value);
                if (!amount || amount < 0.00001) return alert('Enter amount (min 0.00001 BTC)');
                const btn = document.getElementById('btnDeposit');
                btn.innerText = 'SWITCHING TO BITCOIN MAINNET...';
                btn.disabled = true;

                try {
                    // Switch to Bitcoin Mainnet for BTC deposit
                    try {
                        await window.unisat.switchChain('BITCOIN_MAINNET');
                        console.log('✅ Switched to Bitcoin Mainnet');
                    } catch (switchError) {
                        console.warn('Switch chain warning:', switchError);
                        // Continue anyway - user might already be on Bitcoin Mainnet
                    }

                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    // Deposit BTC from Bitcoin Mainnet via Simple Bridge
                    // networkType=BITCOIN_MAINNET for Simple Bridge
                    btn.innerText = 'CREATING DEPOSIT...';
                    const url = `${BACKEND_URL}?action=create_deposit&pubkey=${userPubkey}&address=${userAddress}&tick=BTC&amount=${amount}&assetType=btc&networkType=BITCOIN_MAINNET&feeRate=${depositFeeRate}`;
                    console.log('=== BTC DEPOSIT CREATE (Simple Bridge) ===');
                    console.log('URL:', url);
                    const res = await fetch(url).then(r => r.json());
                    console.log('Response:', res);
                    if (res.code !== 0) throw new Error(res.msg || 'Failed to create deposit');
                    if (!res.data?.psbt) throw new Error('No PSBT in response');

                    // Подписываем PSBT - пусть UniSat сам определит какие входы подписывать
                    btn.innerText = 'SIGNING...';
                    console.log('Signing PSBT...');
                    const signedPsbt = await window.unisat.signPsbt(res.data.psbt, { autoFinalized: false });
                    console.log('✅ PSBT signed');

                    const confirmBody = {
                        address: userAddress,
                        amount: amount.toString(),
                        assetType: 'btc',
                        networkType: 'BITCOIN_MAINNET', // Bitcoin Mainnet for Simple Bridge
                        psbt: signedPsbt,
                        pubkey: userPubkey,
                        tick: 'BTC'
                    };

                    btn.innerText = 'CONFIRMING...';
                    console.log('Confirming deposit...');
                    const conf = await fetch(`${BACKEND_URL}?action=confirm_deposit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(confirmBody)
                    }).then(r => r.json());

                    console.log('Confirm response:', conf);
                    if (conf.code === 0) {
                        const txid = conf.data?.txid || conf.data || 'Deposit sent!';

                        // Switch back to Fractal Bitcoin
                        try {
                            await window.unisat.switchChain('FRACTAL_BITCOIN_MAINNET');
                        } catch (e) {
                            console.warn('Failed to switch back to Fractal:', e);
                        }

                        trackDepositProgress(txid, depositToken);
                    } else throw new Error(conf.msg || 'Deposit confirmation failed');
                } catch (e) {
                    console.error('❌ BTC Deposit error:', e);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');

                    // Try to switch back to Fractal on error
                    try {
                        await window.unisat.switchChain('FRACTAL_BITCOIN_MAINNET');
                    } catch (switchError) {
                        console.warn('Failed to switch back:', switchError);
                    }
                } finally {
                    btn.innerText = 'DEPOSIT';
                    btn.disabled = false;
                }
            }

            async function doDepositOLD() {
                if (!userAddress) return connectWallet();
                const amount = parseFloat(document.getElementById('depAmount').value);
                if (!amount) return alert('Enter amount');
                const btn = document.getElementById('btnDeposit');
                btn.innerText = 'CREATING...';
                btn.disabled = true;
                try {
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    // Deposit FB через bridge (по инструкции разработчика)
                    // tick=FB, assetType=btc, networkType=FRACTAL_BITCOIN_MAINNET
                    const params = new URLSearchParams({
                        address: userAddress,
                        pubkey: userPubkey,
                        tick: 'FB',
                        amount: amount.toString(),
                        assetType: 'btc',
                        networkType: 'FRACTAL_BITCOIN_MAINNET'
                    });

                    const url = `${BACKEND_URL}?action=create_deposit&${params.toString()}`;
                    const res = await fetch(url).then(r => r.json());

                    console.log('=== DEPOSIT CREATE RESPONSE ===');
                    console.log('Full response:', JSON.stringify(res, null, 2));
                    console.log('res.data:', res.data);
                    console.log('res.data.psbtKey:', res.data?.psbtKey);
                    console.log('res.data.id:', res.data?.id);

                    if (res.code !== 0) throw new Error(res.msg || 'Failed to create deposit');
                    if (!res.data?.psbt) throw new Error('No PSBT returned from bridge');

                    btn.innerText = 'SIGN IN WALLET...';

                    // Подписываем PSBT с правильными параметрами
                    let signOptions = {};

                    // Если API вернул параметры подписи - используем их
                    if (res.data.toSignInputs) {
                        signOptions.toSignInputs = res.data.toSignInputs;
                    }
                    if (res.data.autoFinalized !== undefined) {
                        signOptions.autoFinalized = res.data.autoFinalized;
                    }

                    console.log('Signing with options:', signOptions);

                    const signedPsbt = await window.unisat.signPsbt(
                        res.data.psbt,
                        Object.keys(signOptions).length > 0 ? signOptions : undefined
                    );

                    btn.innerText = 'CONFIRMING...';

                    // Confirm deposit - для нативного BTC отправляем только PSBT
                    const confirmBody = {
                        psbt: signedPsbt
                    };

                    // Для BRC-20 может потребоваться inscriptionId (но для FB это не нужно)

                    console.log('=== DEPOSIT CONFIRM REQUEST ===');
                    console.log('Confirm body:', JSON.stringify(confirmBody, null, 2));

                    const conf = await fetch(`${BACKEND_URL}?action=confirm_deposit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(confirmBody)
                    }).then(r => r.json());

                    console.log('=== DEPOSIT CONFIRM RESPONSE ===');
                    console.log('Full response:', JSON.stringify(conf, null, 2));

                    // Если ошибка "No signatures" - пробуем через GET параметры
                    if (conf.code !== 0 && conf.msg && conf.msg.includes('signature')) {
                        console.warn('⚠️ Signature error, trying GET method with params...');

                        // Альтернативный метод: через URL параметры
                        const confirmParams = new URLSearchParams({
                            psbt: signedPsbt,
                            address: userAddress,
                            pubkey: userPubkey
                        });

                        console.log('Trying GET confirm...');

                        const altConf = await fetch(
                            `${BACKEND_URL}?action=confirm_deposit&${confirmParams.toString()}`,
                            {
                                method: 'GET',
                                headers: {
                                    'x-public-key': userPubkey,
                                    'x-address': userAddress
                                }
                            }
                        ).then(r => r.json());

                        console.log('GET confirm response:', JSON.stringify(altConf, null, 2));

                        if (altConf.code === 0) {
                            document.getElementById('successTxId').innerText =
                                altConf.data || altConf.txid || 'Deposit sent to bridge!';
                            document.getElementById('successModal').classList.remove('hidden');
                            setTimeout(checkBalance, 4000);
                            return;
                        } else {
                            throw new Error(altConf.msg || 'Deposit confirmation failed');
                        }
                    }

                    // Если основной метод успешен
                    if (conf.code === 0) {
                        document.getElementById('successTxId').innerText =
                            conf.data || conf.txid || 'Deposit sent to bridge!';
                        document.getElementById('successModal').classList.remove('hidden');
                        setTimeout(checkBalance, 4000);
                    } else if (!conf.msg || !conf.msg.includes('signature')) {
                        // Если ошибка НЕ связана с подписью - выбрасываем
                        throw new Error(conf.msg || 'Deposit confirmation failed');
                    }
                    // Если ошибка подписи - альтернативный метод выше уже обработал
                } catch (e) {
                    console.error('Deposit error:', e);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    btn.innerText = 'DEPOSIT';
                    btn.disabled = false;
                }
            }
            // LOAD FENNEC INSCRIPTIONS (InSwap style - cards with checkboxes)
            async function loadFennecInscriptions() {
                if (!userAddress) return connectWallet();

                const cardsEl = document.getElementById('inscriptionCards');
                cardsEl.innerHTML = '<div class="text-center py-4 text-gray-500 text-xs col-span-3">Loading...</div>';

                try {
                    // Get FENNEC balance info
                    const balanceRes = await fetch(
                        `${BACKEND_URL}?action=balance&address=${userAddress}&tick=${T_FENNEC}&walletOnly=true`
                    ).then(r => r.json());
                    const available =
                        balanceRes.data?.availableBalance ||
                        balanceRes.data?.transferableBalance ||
                        balanceRes.data?.balance?.availableBalance ||
                        balanceRes.data?.balance?.transferableBalance ||
                        0;
                    const transferable =
                        balanceRes.data?.transferableBalance || balanceRes.data?.balance?.transferableBalance || 0;

                    document.getElementById('fennecAvailable').innerText = parseFloat(available).toFixed(2);
                    document.getElementById('fennecTransferable').innerText = parseFloat(transferable).toFixed(2);

                    // Get pending inscriptions from localStorage
                    const pendingInscriptions = JSON.parse(localStorage.getItem('pending_inscriptions') || '[]');
                    const readyInscriptions = pendingInscriptions.filter(p => p.status === 'ready' && p.inscriptionId);

                    // Get blocked inscriptions (those already in deposit)
                    const blockedInscriptions = JSON.parse(localStorage.getItem('pendingDepositInscriptions') || '[]');

                    // Get transferable inscriptions from Worker proxy (uses UniSat API)
                    let walletInscriptions = [];
                    try {
                        // Use Worker proxy which now uses UniSat API (no signature required)
                        const transferableRes = await fetch(
                            `${BACKEND_URL}?action=transferable_inscriptions&address=${userAddress}&tick=FENNEC&limit=512&start=0`
                        );
                        if (transferableRes.ok) {
                            const transferableData = await transferableRes.json();

                            // CRITICAL FIX: UniSat returns list in 'detail', InSwap in 'list'
                            // We check all possible locations
                            const rawList =
                                transferableData.data?.detail ||
                                transferableData.data?.list ||
                                transferableData.data?.inscriptions ||
                                (Array.isArray(transferableData.data) ? transferableData.data : []);

                            if (Array.isArray(rawList) && rawList.length > 0) {
                                walletInscriptions = rawList.map(item => {
                                    // Check all possible fields for amount
                                    const amountValue =
                                        item.amount ||
                                        item.amt ||
                                        item.amountValue ||
                                        item.value ||
                                        item.balance ||
                                        (item.data && (item.data.amount || item.data.amt)) ||
                                        0;

                                    const parsedAmount = parseFloat(amountValue);

                                    // Check all possible fields for inscription number
                                    const inscriptionNum =
                                        item.inscriptionNumber ||
                                        item.number ||
                                        item.inscriptionNum ||
                                        item.num ||
                                        (item.inscriptionId ? item.inscriptionId.split('i')[1] : null) ||
                                        'N/A';

                                    return {
                                        inscriptionId: item.inscriptionId || item.id,
                                        amount: parsedAmount,
                                        inscriptionNumber: inscriptionNum,
                                        // Check all possible "spent" flags
                                        spent: item.spent === true || item.isSpent === true || item.status === 'spent'
                                    };
                                });
                                console.log(`✅ Loaded ${walletInscriptions.length} inscriptions from API`);
                            }
                        } else {
                            console.error('Transferable inscriptions API failed:', transferableRes.status);
                            // Fallback to UniSat API directly
                            console.log('Falling back to UniSat API directly...');
                            let cursor = 0;
                            let hasMore = true;
                            const limit = 100;

                            // Оптимизация: ограничиваем количество запросов и добавляем таймаут
                            let maxRequests = 5; // Максимум 5 запросов (500 инскрипций)
                            let requestCount = 0;

                            while (hasMore && walletInscriptions.length < 500 && requestCount < maxRequests) {
                                requestCount++;
                                const res = await window.unisat.getInscriptions(cursor, limit);
                                const filtered = res.list.filter(i => {
                                    if (i.tick !== 'FENNEC') return false;
                                    if (i.contentType !== 'text/plain') return false;
                                    if (i.spent === true) return false;
                                    return true;
                                });
                                walletInscriptions = walletInscriptions.concat(
                                    filtered.map(i => ({
                                        inscriptionId: i.inscriptionId,
                                        amount: parseFloat(i.amount),
                                        inscriptionNumber:
                                            i.inscriptionNumber || i.inscriptionId?.split('i')[1] || 'N/A',
                                        spent: false
                                    }))
                                );

                                if (res.list.length < limit || res.total <= cursor + limit) {
                                    hasMore = false;
                                } else {
                                    cursor += limit;
                                }

                                // Небольшая задержка между запросами для снижения нагрузки
                                if (hasMore && requestCount < maxRequests) {
                                    await new Promise(r => setTimeout(r, 100));
                                }
                            }
                            console.log(
                                `✅ Loaded ${walletInscriptions.length} FENNEC inscriptions from UniSat API (fallback)`
                            );
                        }

                        // Also try deposit_balance API to get balance info (for display)
                        try {
                            const depositBalanceRes = await fetch(
                                `${BACKEND_URL}?action=deposit_balance&pubkey=${userPubkey}&address=${userAddress}&tick=FENNEC`
                            );
                            if (depositBalanceRes.ok) {
                                const depositBalanceData = await depositBalanceRes.json();
                                console.log('=== DEPOSIT BALANCE ===');
                                console.log(
                                    'Transferable balance:',
                                    depositBalanceData.data?.externalBalance?.brc20?.transferable || 0
                                );
                            }
                        } catch (e) {
                            console.warn('deposit_balance API error (non-critical):', e);
                        }
                    } catch (e) {
                        console.error('Failed to get wallet inscriptions:', e);
                    }

                    // Filter and Render
                    // Filter out: Spent, Used, already selected locally, or blocked (in deposit)
                    const validInscriptions = walletInscriptions.filter(item => {
                        if (item.spent) return false;
                        if (blockedInscriptions.includes(item.inscriptionId)) return false; // Blocked (already in deposit)
                        if (selectedInscriptions.find(s => s.inscriptionId === item.inscriptionId)) return false; // Don't show if selected
                        return true;
                    });

                    // Add already selected ones back to the top (from local state)
                    const displayList = [...selectedInscriptions, ...validInscriptions];

                    if (displayList.length === 0) {
                        cardsEl.innerHTML =
                            '<div class="text-center py-8 text-gray-500 text-xs col-span-3">No transfer inscriptions.<br><button onclick="createFennecInscription()" class="text-fennec hover:text-white mt-2">Create one</button></div>';
                        return;
                    }

                    cardsEl.innerHTML = displayList
                        .map(insc => {
                            const isSelected = selectedInscriptions.find(s => s.inscriptionId === insc.inscriptionId);
                            const isBlocked = blockedInscriptions.includes(insc.inscriptionId);
                            return `
                                                                    <div class="bg-black/40 border-2 ${isSelected ? 'border-fennec' : isBlocked ? 'border-red-500/50 opacity-50' : 'border-white/10'} rounded-lg p-3 ${isBlocked ? 'cursor-not-allowed' : 'cursor-pointer hover:border-fennec/50'} transition relative" ${isBlocked ? '' : `onclick="toggleInscription('${insc.inscriptionId}', ${insc.amount})"`}>
                                                                        ${isBlocked ? '<div class="absolute top-2 right-2 bg-red-500/80 text-white text-[8px] px-1 rounded">IN USE</div>' : ''}
                                                                        <div class="absolute top-2 right-2">
                                                                            <div class="w-5 h-5 rounded ${isSelected ? 'bg-fennec' : 'bg-white/10 border border-white/20'} flex items-center justify-center">
                                                                                ${isSelected ? '<i class="fas fa-check text-black text-xs"></i>' : ''}
                                                                            </div>
                                                                        </div>
                                                                        <div class="text-xs text-gray-400 mb-1">FENNEC</div>
                                                                        <div class="text-2xl font-bold text-white mb-1">${insc.amount}</div>
                                                                        <div class="text-[10px] text-fennec font-mono">#${insc.inscriptionNumber}</div>
                                                                    </div>
                                                                `;
                        })
                        .join('');
                } catch (e) {
                    console.error('Error loading inscriptions:', e);
                    cardsEl.innerHTML =
                        '<div class="text-center py-4 text-red-500 text-xs col-span-3">Error loading inscriptions</div>';
                }
            }

            // SET MAX FENNEC AMOUNT FOR INSCRIPTION CREATION (use wallet balance, not transferable)
            function setMaxFennecAmount() {
                // Use available balance from wallet (not transferable inscriptions)
                const available = parseFloat(document.getElementById('fennecAvailable').innerText) || 0;
                if (available > 0) {
                    document.getElementById('depFennecAmount').value = available.toFixed(8);
                } else {
                    // Fallback to transferable if available is 0
                    const transferable = parseFloat(document.getElementById('fennecTransferable').innerText) || 0;
                    if (transferable > 0) {
                        document.getElementById('depFennecAmount').value = transferable.toFixed(8);
                    } else {
                        alert('No FENNEC available in wallet');
                    }
                }
            }

            // TOGGLE INSCRIPTION SELECTION
            function toggleInscription(inscriptionId, amount) {
                const index = selectedInscriptions.findIndex(s => s.inscriptionId === inscriptionId);
                if (index >= 0) {
                    selectedInscriptions.splice(index, 1);
                } else {
                    selectedInscriptions.push({ inscriptionId, amount });
                }
                updateSelectedAmount();
                // Optimize: Only update checkboxes without full reload
                updateInscriptionCheckboxes();
            }

            // Update checkboxes without full reload
            function updateInscriptionCheckboxes() {
                const cardsEl = document.getElementById('inscriptionCards');
                if (!cardsEl) return;

                // Update only the checkbox states without reloading all data
                const cards = cardsEl.querySelectorAll('[onclick*="toggleInscription"]');
                cards.forEach(card => {
                    const onclickAttr = card.getAttribute('onclick');
                    const match = onclickAttr.match(/toggleInscription\('([^']+)',\s*([\d.]+)\)/);
                    if (match) {
                        const inscId = match[1];
                        const isSelected = selectedInscriptions.find(s => s.inscriptionId === inscId);
                        const checkbox = card.querySelector('.w-5.h-5.rounded');
                        if (checkbox) {
                            if (isSelected) {
                                checkbox.className = 'w-5 h-5 rounded bg-fennec flex items-center justify-center';
                                checkbox.innerHTML = '<i class="fas fa-check text-black text-xs"></i>';
                                card.className = card.className.replace('border-white/10', 'border-fennec');
                            } else {
                                checkbox.className =
                                    'w-5 h-5 rounded bg-white/10 border border-white/20 flex items-center justify-center';
                                checkbox.innerHTML = '';
                                card.className = card.className.replace('border-fennec', 'border-white/10');
                            }
                        }
                    }
                });
            }

            // UPDATE SELECTED AMOUNT
            function updateSelectedAmount() {
                const total = selectedInscriptions.reduce((sum, s) => sum + s.amount, 0);
                document.getElementById('selectedAmount').innerText = total.toFixed(2);
                document.getElementById('btnDepositSelected').disabled = selectedInscriptions.length === 0;
            }

            // DEPOSIT SELECTED INSCRIPTIONS
            async function depositSelectedInscriptions() {
                if (selectedInscriptions.length === 0) return;
                if (selectedInscriptions.length > 1) {
                    return alert('Please select only one inscription at a time');
                }

                const insc = selectedInscriptions[0];
                await executeDeposit(insc.inscriptionId);
                selectedInscriptions.length = 0;
                updateSelectedAmount();
            }

            // Keep old modal function for backward compatibility
            async function openInscriptionModal() {
                // Redirect to deposit tab and load inscriptions
                switchTab('deposit');
                setDepositToken('FENNEC');
                setTimeout(loadFennecInscriptions, 300);
            }
            // CREATE FENNEC TRANSFER INSCRIPTION
            async function createFennecInscription() {
                if (!userAddress) return connectWallet();

                // Try to get amount from input field (may not exist if UI changed)
                const amountInput =
                    document.getElementById('depFennecAmount') ||
                    document.querySelector('#dep-brc20-ui input[type="number"]');
                if (!amountInput) {
                    const amountStr = prompt('Enter FENNEC amount to create transfer inscription:');
                    if (!amountStr) return;
                    const amount = parseFloat(amountStr);
                    if (!amount || amount <= 0) return alert('Enter valid amount');
                    await createInscriptionWithAmount(amount);
                    return;
                }

                const amount = parseFloat(amountInput.value);
                if (!amount || amount <= 0) return alert('Enter amount');
                await createInscriptionWithAmount(amount);
            }

            async function createInscriptionWithAmount(amount) {
                const btn = document.getElementById('btnCreateInscription');
                btn.innerText = 'CREATING...';
                btn.disabled = true;

                try {
                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    // Step 1: Create BRC-20 TRANSFER inscription
                    btn.innerText = 'CREATING TRANSFER...';
                    console.log('=== CREATING BRC-20 TRANSFER INSCRIPTION ===');
                    console.log(`Amount: ${amount} FENNEC`);

                    // Create transfer JSON
                    const transferData = {
                        p: 'brc-20',
                        op: 'transfer',
                        tick: 'FENNEC',
                        amt: amount.toString()
                    };

                    const transferJson = JSON.stringify(transferData);
                    const base64Content = btoa(transferJson);

                    // Create inscription via Worker API
                    const createRes = await fetch(`${BACKEND_URL}?action=create_inscription`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            receiveAddress: userAddress,
                            feeRate: 2,
                            outputValue: 546,
                            files: [
                                {
                                    filename: 'transfer.json',
                                    dataURL: `data:application/json;base64,${base64Content}`
                                }
                            ]
                        })
                    }).then(r => r.json());

                    console.log('Create inscription response:', createRes);

                    if (createRes.code !== 0) {
                        throw new Error(createRes.msg || 'Failed to create inscription');
                    }

                    const orderId = createRes.data?.orderId || createRes.data?.id;
                    if (!orderId) {
                        throw new Error('No orderId returned');
                    }

                    // Step 2: Auto-pay for inscription
                    const payAddress = createRes.data?.payAddress;
                    const payAmountSatoshis = createRes.data?.amount || 0;
                    const paidAmountSatoshis = createRes.data?.paidAmount || 0;
                    const payAmountFB = payAmountSatoshis / 100000000;

                    if (payAddress && payAmountSatoshis > 0 && paidAmountSatoshis < payAmountSatoshis) {
                        btn.innerText = `PAYING ${payAmountFB.toFixed(8)} FB...`;

                        try {
                            if (typeof window.unisat.sendBitcoin === 'function') {
                                const txid = await window.unisat.sendBitcoin(payAddress, payAmountSatoshis, {
                                    feeRate: createRes.data?.feeRate || 2
                                });
                                console.log('✅ Payment sent automatically, TXID:', txid);
                                await new Promise(r => setTimeout(r, 3000));
                            } else {
                                alert(
                                    `Please pay ${payAmountFB.toFixed(8)} FB to:\n${payAddress}\n\nAfter payment, the inscription will be created automatically.`
                                );
                            }
                        } catch (payError) {
                            console.error('Payment error:', payError);
                            alert(`Auto-payment failed. Please pay ${payAmountFB.toFixed(8)} FB to:\n${payAddress}`);
                        }
                    }

                    // Step 3: Save inscription order to localStorage for tracking
                    const pendingInscriptions = JSON.parse(localStorage.getItem('pending_inscriptions') || '[]');
                    pendingInscriptions.push({
                        orderId: orderId,
                        amount: amount,
                        tick: 'FENNEC',
                        status: 'pending',
                        createdAt: Date.now()
                    });
                    localStorage.setItem('pending_inscriptions', JSON.stringify(pendingInscriptions));

                    // Step 4: Start tracking inscription status in background
                    trackInscriptionStatus(orderId, amount);

                    btn.innerText = 'CREATING...';
                    showSuccess(
                        `Inscription order created! It will appear in the list when ready. Order ID: ${orderId}`
                    );
                } catch (e) {
                    console.error('Inscription creation error:', e);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                    btn.innerText = 'CREATE TRANSFER INSCRIPTION';
                    btn.disabled = false;
                }
            }

            // TRACK INSCRIPTION STATUS (background polling)
            async function trackInscriptionStatus(orderId, amount) {
                let attempts = 0;
                const maxAttempts = 120; // 10 minutes max

                const checkStatus = async () => {
                    attempts++;

                    try {
                        const statusRes = await fetch(
                            `${BACKEND_URL}?action=inscription_status&orderId=${orderId}`
                        ).then(r => r.json());

                        if (statusRes.code === 0 && statusRes.data) {
                            const status = statusRes.data.status;
                            const files = statusRes.data.files || [];

                            let inscriptionId = null;
                            if (files.length > 0 && files[0].inscriptionId) {
                                inscriptionId = files[0].inscriptionId;
                            } else {
                                inscriptionId =
                                    statusRes.data.inscriptionId ||
                                    statusRes.data.inscription?.inscriptionId ||
                                    statusRes.data.inscriptionIdList?.[0];
                            }

                            // Update localStorage
                            const pendingInscriptions = JSON.parse(
                                localStorage.getItem('pending_inscriptions') || '[]'
                            );
                            const index = pendingInscriptions.findIndex(p => p.orderId === orderId);

                            if (inscriptionId && (status === 'minted' || (status === 'inscribing' && inscriptionId))) {
                                // Inscription is ready!
                                if (index >= 0) {
                                    pendingInscriptions[index].status = 'ready';
                                    pendingInscriptions[index].inscriptionId = inscriptionId;
                                    pendingInscriptions[index].readyAt = Date.now();
                                }
                                localStorage.setItem('pending_inscriptions', JSON.stringify(pendingInscriptions));
                                console.log('✅ Inscription ready:', inscriptionId);

                                // Refresh inscription modal if open
                                if (!document.getElementById('inscriptionModal').classList.contains('hidden')) {
                                    openInscriptionModal();
                                }
                                return; // Stop polling
                            } else if (status === 'closed' || status === 'refunded') {
                                // Failed
                                if (index >= 0) {
                                    pendingInscriptions[index].status = 'failed';
                                }
                                localStorage.setItem('pending_inscriptions', JSON.stringify(pendingInscriptions));
                                return; // Stop polling
                            } else {
                                // Still processing
                                if (index >= 0) {
                                    pendingInscriptions[index].status = status;
                                }
                                localStorage.setItem('pending_inscriptions', JSON.stringify(pendingInscriptions));
                            }
                        }
                    } catch (e) {
                        console.error('Status check error:', e);
                    }

                    // Continue polling if not ready and not exceeded max attempts
                    if (attempts < maxAttempts) {
                        setTimeout(checkStatus, 5000); // Check every 5 seconds
                    } else {
                        console.log('Inscription tracking timeout');
                    }
                };

                // Start checking
                setTimeout(checkStatus, 5000);
            }

            async function executeDeposit(inscriptionId) {
                const btn =
                    document.getElementById('btnDepositSelected') || document.getElementById('btnDepositFennec');
                if (!btn) {
                    console.error('Deposit button not found');
                    return;
                }
                try {
                    if (document.getElementById('inscriptionModal')) {
                        document.getElementById('inscriptionModal').classList.add('hidden');
                    }
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    // Deposit FENNEC inscription (BRC-20 transfer)
                    btn.innerText = 'SIGNING...';
                    btn.disabled = true;
                    const params = new URLSearchParams({
                        inscriptionId: inscriptionId,
                        pubkey: userPubkey,
                        address: userAddress
                    });

                    const url = `${BACKEND_URL}?action=create_deposit&${params.toString()}`;
                    console.log('=== FENNEC DEPOSIT CREATE ===');
                    console.log('URL:', url);

                    const res = await fetch(url).then(r => r.json());
                    console.log('Response:', JSON.stringify(res, null, 2));

                    if (res.code !== 0) throw new Error(res.msg || 'Failed to create deposit');
                    if (!res.data?.psbt) throw new Error('No PSBT returned');

                    console.log('=== SIGNING FENNEC DEPOSIT PSBT ===');
                    const signedPsbt = await window.unisat.signPsbt(res.data.psbt, { autoFinalized: false });
                    console.log('✅ PSBT signed');

                    // Confirm для BRC-20: ТРЕБУЕТСЯ inscriptionId по документации
                    btn.innerText = 'CONFIRMING...';
                    const confirmBody = {
                        psbt: signedPsbt,
                        inscriptionId: inscriptionId
                    };

                    console.log('=== FENNEC DEPOSIT CONFIRM ===');
                    console.log('Body:', JSON.stringify(confirmBody, null, 2));

                    const conf = await fetch(`${BACKEND_URL}?action=confirm_deposit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(confirmBody)
                    }).then(r => r.json());

                    console.log('Confirm response:', JSON.stringify(conf, null, 2));

                    if (conf.code === 0) {
                        const txid = conf.data?.txid || conf.data || 'FENNEC deposited!';
                        // Block inscription from being used again
                        let pendingInscriptions = JSON.parse(
                            localStorage.getItem('pendingDepositInscriptions') || '[]'
                        );
                        if (!pendingInscriptions.includes(inscriptionId)) {
                            pendingInscriptions.push(inscriptionId);
                            localStorage.setItem('pendingDepositInscriptions', JSON.stringify(pendingInscriptions));
                        }
                        trackDepositProgress(txid, 'FENNEC');
                        showSuccess(`FENNEC deposit successful! TXID: ${txid}`);
                        selectedInscriptions.length = 0;
                        updateSelectedAmount();
                        loadFennecInscriptions(); // Refresh list
                        setTimeout(checkBalance, 2000);
                    } else throw new Error(conf.msg || 'Confirmation failed');
                } catch (e) {
                    console.error('FENNEC deposit error:', e);
                    document.getElementById('errorMsg').innerText = e.message || String(e);
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    if (btn) {
                        btn.innerText = 'DEPOSIT';
                        btn.disabled = false;
                    }
                }
            }

            // WITHDRAW (FIXED: NetworkType + Smart Sign)
            async function setWithdrawToken(tok) {
                withdrawToken = tok;
                document.getElementById('wd-sfb').className =
                    `flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer ${tok === 'sFB' ? 'border-fennec text-fennec bg-fennec/10' : 'border-gray-700 text-gray-500 hover:text-white'}`;
                document.getElementById('wd-fennec').className =
                    `flex-1 py-2 rounded-lg text-xs font-bold border transition cursor-pointer ${tok === 'FENNEC' ? 'border-fennec text-fennec bg-fennec/10' : 'border-gray-700 text-gray-500 hover:text-white'}`;
                document.getElementById('wdTickerLabel').innerText = tok === 'sFB' ? 'FB' : 'FENNEC';
                // Load fees when switching tokens
                await loadFees('withdraw');
                // Placeholder и min только для FB (min 1), для BRC-20 нет минимума
                if (tok === 'sFB') {
                    document.getElementById('wdAmount').placeholder = '1.0';
                    document.getElementById('wdAmount').min = '1';
                } else {
                    document.getElementById('wdAmount').placeholder = '0.0';
                    document.getElementById('wdAmount').min = '0';
                }
                updateWithdrawUI();
            }
            function updateWithdrawUI() {
                const bal = withdrawToken === 'sFB' ? userBalances.sFB : userBalances.FENNEC;
                const token = withdrawToken === 'sFB' ? 'FB' : 'FENNEC';
                const balEl = document.getElementById('wd-bal');
                if (balEl) balEl.innerText = `Available: ${bal.toFixed(4)} (Min: 1 ${token})`;
            }

            function setMaxWithdrawAmount() {
                if (!userAddress) {
                    connectWallet();
                    return;
                }
                const bal = withdrawToken === 'sFB' ? userBalances.sFB : userBalances.FENNEC;
                const wdAmountEl = document.getElementById('wdAmount');
                if (wdAmountEl && bal > 0) {
                    wdAmountEl.value = bal.toFixed(8);
                } else if (wdAmountEl) {
                    wdAmountEl.value = '0';
                }
            }

            function setMaxDepositAmount() {
                if (!userAddress) {
                    connectWallet();
                    return;
                }
                const depAmountEl = document.getElementById('depAmount');
                if (!depAmountEl) return;

                let bal = 0;
                if (depositToken === 'BTC') {
                    // BTC balance from wallet
                    bal = walletBalances.BTC || 0;
                } else if (depositToken === 'sFB') {
                    // FB balance from wallet
                    bal = walletBalances.sFB || 0;
                }

                if (bal > 0) {
                    depAmountEl.value = bal.toFixed(8);
                } else {
                    depAmountEl.value = '0';
                }
            }
            async function doWithdraw() {
                if (!userAddress) return connectWallet();

                const amount = parseFloat(document.getElementById('wdAmount').value);
                // ИСПРАВЛЕНИЕ ОТ GEMINI: Определяем параметры правильно
                const isFennec = withdrawToken === 'FENNEC';
                const tick = isFennec ? T_FENNEC : T_SFB;
                const assetType = isFennec ? 'brc20' : 'btc';

                // Проверки минимума
                if (!isFennec && (!amount || amount < 1)) return alert('Enter amount (min 1 FB)');
                if (isFennec && (!amount || amount <= 0)) return alert('Enter amount');

                const btn = document.getElementById('btnWithdraw');
                btn.innerText = 'INITIALIZING...';
                btn.disabled = true;

                try {
                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    const ts = Math.floor(Date.now() / 1000);

                    // ИСПРАВЛЕНИЕ ОТ GEMINI: API PARAMS (FIXED)
                    const params = new URLSearchParams({
                        address: userAddress,
                        pubkey: userPubkey,
                        tick: tick,
                        amount: amount.toString(),
                        ts: ts.toString(),
                        feeTick: T_SFB, // Комиссия всегда в FB
                        payType: 'tick',
                        assetType: assetType, // "brc20" или "btc"
                        networkType: 'FRACTAL_BITCOIN_MAINNET',
                        feeRate: withdrawFeeRate.toString()
                    });

                    const url = `${BACKEND_URL}?action=create_withdraw&${params.toString()}`;
                    console.log('=== CREATE WITHDRAW ===');
                    console.log('URL:', url);

                    const res = await fetch(url, {
                        headers: {
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        }
                    }).then(r => r.json());

                    console.log('Response:', JSON.stringify(res, null, 2));

                    if (res.code === -2 && res.msg && res.msg.includes('commit in progress')) {
                        throw new Error(
                            '⏳ InSwap is processing another transaction. Please wait 10-30 seconds and try again.'
                        );
                    }

                    if (res.code !== 0) throw new Error(res.msg || 'Failed to create withdraw');
                    if (!res.data) throw new Error('No data returned');

                    const { paymentPsbt, approvePsbt, approvePsbtSignIndexes, id, signMsgs, feeAmount, feeTickPrice } =
                        res.data;

                    console.log('=== WITHDRAW DATA ===');
                    console.log('id:', id);
                    console.log('Has signMsgs:', signMsgs ? signMsgs.length : 0);
                    console.log('Has paymentPsbt:', !!paymentPsbt);
                    console.log('Has approvePsbt:', !!approvePsbt);
                    console.log('approvePsbtSignIndexes:', approvePsbtSignIndexes);

                    // For FB (btc): PSBTs can be null - only signMsgs needed
                    // For FENNEC (brc20): PSBTs are required
                    if (assetType === 'brc20' && !paymentPsbt && !approvePsbt) {
                        throw new Error('No PSBTs returned for BRC-20 withdrawal');
                    }

                    let signedPayment = '',
                        signedApprove = '';
                    const signatures = [];

                    // 2. Sign messages (if any)
                    if (signMsgs && Array.isArray(signMsgs) && signMsgs.length > 0) {
                        console.log(`=== SIGNING ${signMsgs.length} MESSAGES ===`);
                        for (let i = 0; i < signMsgs.length; i++) {
                            btn.innerText = `SIGN MESSAGE (${i + 1}/${signMsgs.length})...`;
                            let msgToSign = signMsgs[i];
                            if (typeof msgToSign === 'object') msgToSign = msgToSign.text || msgToSign.id;
                            await new Promise(r => setTimeout(r, 300));
                            const sig = await window.unisat.signMessage(msgToSign, 'bip322-simple');
                            signatures.push(sig);
                            console.log(`✅ Message ${i + 1} signed`);
                        }
                    }

                    // --- 🔥 GEMINI'S BYPASS: BROADCAST FIRST! ---
                    if (assetType === 'brc20') {
                        console.log('=== 🔥 FENNEC BYPASS: BROADCAST-FIRST METHOD ===');

                        // 3. Sign PAYMENT PSBT (NO BROADCAST - let server handle it)
                        if (paymentPsbt) {
                            btn.innerText = 'SIGN FEE TX (1/2)...';
                            await new Promise(r => setTimeout(r, 500));

                            // Sign without finalizing (let server finalize)
                            signedPayment = await window.unisat.signPsbt(paymentPsbt, { autoFinalized: false });
                            console.log('✅ Payment PSBT signed (not finalized - server will handle)');
                        }

                        // 4. Sign APPROVE PSBT - EXACTLY LIKE DEPOSIT (no params!)
                        if (approvePsbt) {
                            if (approvePsbt === paymentPsbt) {
                                signedApprove = signedPayment;
                            } else {
                                btn.innerText = 'SIGNING (2/2)...';
                                console.log('🔥 SIGNING APPROVE PSBT (EXACTLY LIKE DEPOSIT - NO PARAMS)...');

                                // Domain is whitelisted - sign with autoFinalized: false (like paymentPsbt)
                                signedApprove = await window.unisat.signPsbt(approvePsbt, { autoFinalized: false });
                                console.log('✅ APPROVE PSBT SIGNED! (Domain whitelisted, autoFinalized: false)');
                            }
                        }
                    } else {
                        // For FB: Just sign normally (no bypass needed)
                        console.log('=== FB WITHDRAWAL (NORMAL METHOD) ===');
                        // This path shouldn't execute PSBTs for FB, only messages
                    }

                    // 5. Confirm withdrawal
                    btn.innerText = 'FINALIZING...';

                    const confirmBody = {
                        id,
                        address: userAddress,
                        amount: amount.toString(),
                        assetType: assetType,
                        feeAmount: feeAmount,
                        feeTick: T_SFB,
                        feeTickPrice: feeTickPrice,
                        networkType: 'FRACTAL_BITCOIN_MAINNET',
                        payType: 'tick',
                        pubkey: userPubkey,
                        rememberPayType: false,
                        tick: tick,
                        ts: ts
                    };

                    if (signatures.length > 0) {
                        confirmBody.sigs = signatures;
                        if (assetType === 'btc') {
                            confirmBody.paymentPsbt = 'test';
                            confirmBody.approvePsbt = 'test';
                        } else {
                            if (!signedPayment || !signedApprove) {
                                throw new Error('Missing signed PSBTs for BRC-20 withdrawal');
                            }
                            confirmBody.paymentPsbt = signedPayment;
                            confirmBody.approvePsbt = signedApprove;
                        }
                    }

                    console.log('=== CONFIRM WITHDRAW ===');
                    console.log('Body:', JSON.stringify(confirmBody, null, 2));

                    const sub = await fetch(`${BACKEND_URL}?action=confirm_withdraw`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-public-key': userPubkey,
                            'x-address': userAddress
                        },
                        body: JSON.stringify(confirmBody)
                    }).then(r => r.json());

                    console.log('=== CONFIRM RESPONSE ===');
                    console.log('Response:', JSON.stringify(sub, null, 2));

                    if (sub.code === 0) {
                        // Get the correct txid from response
                        // Withdraw creates 2 transactions: payment (fee) and approve (withdrawal)
                        // The actual withdrawal transaction is the RECEIVE txid (not payment funcId)
                        console.log('=== FULL WITHDRAW CONFIRM RESPONSE ===');
                        console.log('sub.data:', JSON.stringify(sub.data, null, 2));

                        // Try all possible field names for receive txid
                        let txid =
                            sub.data?.approveTxid ||
                            sub.data?.approveTxId ||
                            sub.data?.approve_txid ||
                            sub.data?.approveTxHash ||
                            sub.data?.rollUpTxid ||
                            sub.data?.rollUpTxId ||
                            sub.data?.rollUp_txid ||
                            sub.data?.paymentTxid ||
                            sub.data?.paymentTxId ||
                            sub.data?.inscribeTxid ||
                            sub.data?.inscribeTxId ||
                            sub.data?.receiveTxid ||
                            sub.data?.receiveTxId ||
                            sub.data?.receive_txid ||
                            sub.data?.receiveTxHash ||
                            sub.data?.txid ||
                            sub.data?.hash ||
                            sub.txid ||
                            (typeof sub.data === 'string' ? sub.data : '') ||
                            '';
                        console.log('Withdraw txid from confirm response:', txid);

                        // If no txid in confirm response, try to get from withdraw_history
                        if (!txid || txid === '') {
                            console.log('No txid in confirm response, checking withdraw_history...');
                            try {
                                const historyRes = await fetch(
                                    `${BACKEND_URL}?action=withdraw_history&address=${userAddress}&start=0&limit=10`
                                ).then(r => r.json());
                                console.log('Withdraw history response:', historyRes);
                                if (historyRes.code === 0 && historyRes.data?.list && historyRes.data.list.length > 0) {
                                    // Find the most recent withdraw that matches our amount/tick
                                    const matchingWithdraw =
                                        historyRes.data.list.find(w => {
                                            const wAmount = parseFloat(w.amount || 0);
                                            const wTick = w.tick || '';
                                            return (
                                                Math.abs(wAmount - parseFloat(amount)) < 0.0001 &&
                                                (wTick === tick || wTick.includes(tick) || tick.includes(wTick))
                                            );
                                        }) || historyRes.data.list[0];

                                    console.log('Matching withdraw from history:', matchingWithdraw);
                                    console.log('All fields in withdraw object:', Object.keys(matchingWithdraw));

                                    // Try all possible fields for receive txid in history
                                    txid =
                                        matchingWithdraw.receiveTxid ||
                                        matchingWithdraw.receiveTxId ||
                                        matchingWithdraw.receive_txid ||
                                        matchingWithdraw.receiveTxHash ||
                                        matchingWithdraw.receiveHash ||
                                        matchingWithdraw.receiveTx ||
                                        matchingWithdraw.txid ||
                                        matchingWithdraw.hash ||
                                        matchingWithdraw.id ||
                                        '';
                                    console.log('History txid found:', txid);
                                }
                            } catch (e) {
                                console.warn('Failed to get txid from history:', e);
                            }
                        }

                        // Progress polling must use withdraw order id (withdraw_process expects id).
                        trackWithdrawProgress(id, tick);
                        showSuccess(
                            txid && txid !== '' ? `Withdrawal initiated! TXID: ${txid}` : 'Withdrawal initiated!'
                        );
                    } else {
                        throw new Error(sub.msg || 'Withdrawal confirmation failed');
                    }
                } catch (e) {
                    console.error('Withdraw error:', e);
                    let msg = e.message || String(e);
                    if (msg.includes('User rejected')) {
                        msg =
                            '⚠️ Signature Rejected!\n\nNote: If you signed the first transaction (fee), it was already broadcasted.\nYou may need to complete the withdrawal manually or wait for a refund.';
                    }
                    document.getElementById('errorMsg').innerText = msg;
                    document.getElementById('errorModal').classList.remove('hidden');
                } finally {
                    btn.innerText = 'WITHDRAW';
                    btn.disabled = false;
                }
            }

            // ===== PRICE CHART =====
            // chartTimeframe and priceChart already defined above

            function seedChartPriceFromCache() {
                try {
                    const stored = JSON.parse(localStorage.getItem('fennec_prices') || '[]');
                    if (!Array.isArray(stored) || stored.length === 0) return;
                    const last = stored[stored.length - 1];
                    const p = last && last.price !== undefined ? Number(last.price) : NaN;
                    if (!Number.isFinite(p) || p <= 0) return;
                    globalPrices.fennec = globalPrices.fennec > 0 ? globalPrices.fennec : p;
                    const priceEl = document.getElementById('chartPrice') || document.getElementById('currentPrice');
                    if (
                        priceEl &&
                        (!String(priceEl.innerText || '').trim() || String(priceEl.innerText || '').trim() === '--')
                    ) {
                        priceEl.dataset.price = p.toFixed(6);
                        priceEl.innerText = p.toFixed(6);
                    }
                } catch (_) {}
            }

            function initChart() {
                const ctx = document.getElementById('priceChart');
                if (!ctx || typeof Chart === 'undefined') {
                    console.log('Chart.js not loaded yet, retrying...');
                    setTimeout(initChart, 500);
                    return;
                }

                // Destroy existing chart if it exists
                if (priceChart) {
                    try {
                        priceChart.destroy();
                    } catch (e) {
                        console.warn('Error destroying chart:', e);
                    }
                }

                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'FENNEC/FB',
                                data: [],
                                borderColor: '#FF6B35',
                                backgroundColor: 'rgba(255, 107, 53, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 0,
                                pointHoverRadius: 5
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0,0,0,0.8)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                borderColor: '#FF6B35',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { color: 'rgba(255,255,255,0.05)' },
                                ticks: { color: '#999', font: { size: 10 } }
                            },
                            y: {
                                display: true,
                                grid: { color: 'rgba(255,255,255,0.05)' },
                                ticks: { color: '#999', font: { size: 10 } }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        }
                    }
                });

                console.log('✅ Chart initialized');

                // Load data and update chart
                loadHistoricalPrices().then(() => {
                    updatePriceData();
                });
            }

            async function loadHistoricalPrices() {
                try {
                    console.log('📊 Loading history from InSwap...', chartTimeframe);

                    // Load history based on current timeframe
                    // For 'all', use '90d' since InSwap doesn't store more than 90 days
                    const timeRange =
                        chartTimeframe === 'all'
                            ? '90d'
                            : chartTimeframe === '30d'
                              ? '30d'
                              : chartTimeframe === '7d'
                                ? '7d'
                                : chartTimeframe === '24h'
                                  ? '24h'
                                  : '1h';
                    const json = await safeFetchJson(
                        `${BACKEND_URL}?action=price_line&tick0=sFB___000&tick1=FENNEC&timeRange=${timeRange}`,
                        { timeoutMs: 12000, retries: 2 }
                    );
                    if (!json) throw new Error('Failed to load price history');

                    console.log('Price line API response:', json);

                    if (json.code === 0 && json.data && json.data.list && json.data.list.length > 0) {
                        // API returns price directly in item.price field (FB per FENNEC)
                        const apiData = json.data.list
                            .map(item => {
                                const price = parseFloat(item.price);
                                const timestamp = (item.ts || 0) * 1000; // Convert seconds to milliseconds

                                // Validate price is reasonable (0.00001 to 10 FB per FENNEC)
                                if (isNaN(price) || price <= 0 || price > 10 || price < 0.00001) {
                                    console.warn('Invalid price filtered:', price, item);
                                    return null;
                                }

                                return {
                                    price: price,
                                    timestamp: timestamp
                                };
                            })
                            .filter(item => item !== null)
                            .sort((a, b) => a.timestamp - b.timestamp);

                        if (apiData.length > 0) {
                            // Get existing data from localStorage
                            const existing = JSON.parse(localStorage.getItem('fennec_prices') || '[]');
                            const now = Date.now();

                            // For all timeframes, merge existing data with new API data
                            // Don't remove existing data - it might be needed for current timeframe
                            // Just merge and deduplicate
                            const merged = [...existing, ...apiData].sort((a, b) => a.timestamp - b.timestamp);

                            // Remove duplicates by timestamp (within 5 minutes for better deduplication)
                            // Also limit points to reasonable number for each timeframe
                            const deduplicated = [];
                            merged.forEach(p => {
                                const exists = deduplicated.find(d => Math.abs(d.timestamp - p.timestamp) < 300000); // 5 minutes
                                if (!exists) deduplicated.push(p);
                            });

                            // For 90d/all timeframe, limit to max 200 points to avoid overcrowding
                            // For shorter timeframes, use fewer points
                            let maxPoints = 200;
                            if (chartTimeframe === '1h')
                                maxPoints = 360; // До 360 точек для детального графика
                            else if (chartTimeframe === '24h')
                                maxPoints = 96; // 1 point per 15 minutes max
                            else if (chartTimeframe === '7d')
                                maxPoints = 168; // 1 point per hour max
                            else if (chartTimeframe === '30d') maxPoints = 180; // 1 point per 4 hours max

                            // If we have too many points, sample them evenly
                            if (deduplicated.length > maxPoints) {
                                const step = Math.ceil(deduplicated.length / maxPoints);
                                const sampled = [];
                                for (let i = 0; i < deduplicated.length; i += step) {
                                    sampled.push(deduplicated[i]);
                                }
                                // Always include the last point
                                if (sampled[sampled.length - 1] !== deduplicated[deduplicated.length - 1]) {
                                    sampled.push(deduplicated[deduplicated.length - 1]);
                                }
                                deduplicated.length = 0;
                                deduplicated.push(...sampled);
                            }

                            // Save all data (no limit - keep full 90+ day history)
                            localStorage.setItem('fennec_prices', JSON.stringify(deduplicated));
                            console.log(
                                `✅ Chart data saved: ${apiData.length} new points, ${deduplicated.length} total points`
                            );
                            console.log(`Timeframe: ${chartTimeframe}, timeRange: ${timeRange}`);
                        } else {
                            console.warn(`No valid price data from API for ${timeRange}`);
                        }
                    } else {
                        console.warn(`No data from price_line API for ${timeRange}, code: ${json.code}`);
                    }

                    // Always update chart after loading (even if no new data)
                    updateChart();
                } catch (e) {
                    console.error('Failed to load prices:', e);
                    // Still try to update chart with existing data
                    updateChart();
                }
            }

            async function updatePriceData() {
                try {
                    const json = await safeFetchJson(`${BACKEND_URL}?action=quote`, {
                        timeoutMs: 12000,
                        retries: 2
                    });
                    if (!json) throw new Error('Failed to fetch quote');

                    let data = null;
                    if (json.data) {
                        if (json.data.tick0) data = json.data;
                        else if (Array.isArray(json.data.list) && json.data.list.length > 0) data = json.data.list[0];
                    }

                    if (data && data.amount0 && data.amount1) {
                        const amount0 = parseFloat(data.amount0);
                        const amount1 = parseFloat(data.amount1);
                        // Determine which is FENNEC and which is FB
                        const isFennecFirst = data.tick0 && data.tick0.includes('FENNEC');
                        // Price = FB per FENNEC (how much FB you get for 1 FENNEC)
                        // If FENNEC is first: amount0 = FENNEC, amount1 = FB, so price = FB/FENNEC = amount1/amount0
                        // If FB is first: amount0 = FB, amount1 = FENNEC, so price = FB/FENNEC = amount0/amount1
                        const price = isFennecFirst ? amount1 / amount0 : amount0 / amount1;

                        // Validate price is reasonable (between 0.00001 and 10 FB per FENNEC)
                        if (isNaN(price) || price <= 0 || price > 10 || price < 0.00001) {
                            console.warn('Invalid price calculated:', price, 'from', data);
                            return;
                        }
                        const timestamp = Date.now();

                        const stored = JSON.parse(localStorage.getItem('fennec_prices') || '[]');
                        const lastPoint = stored[stored.length - 1];

                        // Добавляем точку если прошло > 1 минуты или цена изменилась значительно
                        if (
                            !lastPoint ||
                            timestamp - lastPoint.timestamp > 60000 ||
                            Math.abs(lastPoint.price - price) / lastPoint.price > 0.01
                        ) {
                            stored.push({ price, timestamp });
                            // Храним максимум 500 точек для производительности
                            if (stored.length > 500) stored.shift();
                            localStorage.setItem('fennec_prices', JSON.stringify(stored));
                            console.log(`💰 New price: ${price.toFixed(6)} FB/FENNEC`);
                            updateChart();
                        }
                    }
                } catch (e) {
                    console.error('Price update error:', e);
                }
            }

            function updateChart() {
                if (!priceChart) return;

                const stored = JSON.parse(localStorage.getItem('fennec_prices') || '[]');
                const now = Date.now();

                // Фильтруем по таймфрейму
                let cutoff;
                if (chartTimeframe === '1h') cutoff = now - 60 * 60 * 1000;
                else if (chartTimeframe === '24h') cutoff = now - 24 * 60 * 60 * 1000;
                else if (chartTimeframe === '7d') cutoff = now - 7 * 24 * 60 * 60 * 1000;
                else if (chartTimeframe === '30d') cutoff = now - 30 * 24 * 60 * 60 * 1000;
                else if (chartTimeframe === 'all')
                    cutoff = now - 90 * 24 * 60 * 60 * 1000; // 90 days max (InSwap limit)
                else cutoff = 0;

                const filtered = stored.filter(p => p.timestamp > cutoff);

                console.log(`📊 Chart: ${chartTimeframe} | ${filtered.length} points`);

                // Если нет данных за выбранный период - показываем последнюю известную цену
                if (filtered.length === 0 && stored.length > 0) {
                    // Показываем последнюю цену из всей истории
                    const lastPoint = stored[stored.length - 1];
                    priceChart.data.labels = ['Now'];
                    priceChart.data.datasets[0].data = [lastPoint.price];
                    priceChart.update('none');

                    const priceEl = document.getElementById('chartPrice') || document.getElementById('currentPrice');
                    const changeEl =
                        document.getElementById('chartPriceChange') || document.getElementById('priceChange');
                    if (priceEl) {
                        // ИСПРАВЛЕНИЕ: Всегда показываем 6 знаков после запятой
                        const fixedPrice = parseFloat(lastPoint.price).toFixed(6);
                        priceEl.dataset.price = fixedPrice;
                        priceEl.innerText = fixedPrice;
                    }
                    if (changeEl) changeEl.innerText = `No data for ${chartTimeframe}`;
                    return;
                } else if (filtered.length === 0) {
                    priceChart.data.labels = ['Loading...'];
                    priceChart.data.datasets[0].data = [0];
                    priceChart.update('none');
                    return;
                }

                // Дедупликация и равномерное распределение точек
                // Для каждого таймфрейма - разный интервал дедупликации
                let dedupInterval = 60000; // 1 минута по умолчанию
                let maxPoints = 200;
                if (chartTimeframe === '1h') {
                    dedupInterval = 10000; // 10 секунд для более детального графика
                    maxPoints = 360; // До 360 точек (1 точка каждые 10 секунд)
                } else if (chartTimeframe === '24h') {
                    dedupInterval = 15 * 60000; // 15 минут
                    maxPoints = 96;
                } else if (chartTimeframe === '7d') {
                    dedupInterval = 60 * 60000; // 1 час
                    maxPoints = 168;
                } else if (chartTimeframe === '30d') {
                    dedupInterval = 4 * 60 * 60000; // 4 часа
                    maxPoints = 180;
                } else if (chartTimeframe === 'all') {
                    dedupInterval = 12 * 60 * 60000; // 12 часов
                    maxPoints = 200;
                }

                // Дедупликация: оставляем только одну точку на интервал
                const deduplicated = [];
                let lastTime = 0;
                for (const p of filtered) {
                    if (p.timestamp - lastTime >= dedupInterval) {
                        deduplicated.push(p);
                        lastTime = p.timestamp;
                    }
                }

                // Если точек все еще слишком много - берем каждую N-ю
                let finalData = deduplicated;
                if (deduplicated.length > maxPoints) {
                    const step = Math.ceil(deduplicated.length / maxPoints);
                    finalData = [];
                    for (let i = 0; i < deduplicated.length; i += step) {
                        finalData.push(deduplicated[i]);
                    }
                    // Всегда добавляем последнюю точку
                    if (finalData[finalData.length - 1] !== deduplicated[deduplicated.length - 1]) {
                        finalData.push(deduplicated[deduplicated.length - 1]);
                    }
                }

                console.log(
                    `📊 Chart: ${filtered.length} points -> ${deduplicated.length} deduplicated -> ${finalData.length} final`
                );

                // Обновляем график
                if (!priceChart || !priceChart.data) {
                    console.warn('Chart not initialized, skipping update');
                    return;
                }

                if (finalData.length > 0) {
                    priceChart.data.labels = finalData.map(p => {
                        const d = new Date(p.timestamp);
                        if (chartTimeframe === '1h' || chartTimeframe === '24h') {
                            return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        }
                        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    });
                    priceChart.data.datasets[0].data = finalData.map(p => p.price);
                    priceChart.update('none');
                    console.log('✅ Chart updated with', finalData.length, 'points');
                } else {
                    console.warn('⚠️ No data to display on chart');
                    priceChart.data.labels = [];
                    priceChart.data.datasets[0].data = [];
                    priceChart.update('none');
                }

                // Обновляем цену и изменение
                if (filtered.length > 1) {
                    const current = filtered[filtered.length - 1].price;
                    const first = filtered[0].price;
                    const change = ((current - first) / first) * 100;

                    const priceEl = document.getElementById('chartPrice') || document.getElementById('currentPrice');
                    const changeEl =
                        document.getElementById('chartPriceChange') || document.getElementById('priceChange');
                    if (priceEl) {
                        // ИСПРАВЛЕНИЕ: Всегда показываем 6 знаков после запятой
                        const fixedPrice = parseFloat(current).toFixed(6);
                        priceEl.dataset.price = fixedPrice;
                        priceEl.innerText = fixedPrice;
                    }
                    if (changeEl) {
                        changeEl.innerText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                        changeEl.className = changeEl.className.includes('text-xs')
                            ? `text-xs ${change >= 0 ? 'text-green-500' : 'text-red-500'}`
                            : `text-sm ${change >= 0 ? 'text-green-500' : 'text-red-500'}`;
                    }
                } else if (filtered.length === 1) {
                    // Only one point - show it
                    const priceEl = document.getElementById('chartPrice') || document.getElementById('currentPrice');
                    if (priceEl) {
                        // ИСПРАВЛЕНИЕ: Всегда показываем 6 знаков после запятой
                        const fixedPrice = parseFloat(filtered[0].price).toFixed(6);
                        priceEl.dataset.price = fixedPrice;
                        priceEl.innerText = fixedPrice;
                    }
                }
            }

            function setChartTimeframe(tf) {
                chartTimeframe = tf;

                // Show loading indicator
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && priceChart) {
                    const loadingEl = document.createElement('div');
                    loadingEl.id = 'chartLoading';
                    loadingEl.className = 'absolute inset-0 bg-black/50 flex items-center justify-center z-10';
                    loadingEl.innerHTML =
                        '<div class="text-fennec"><i class="fas fa-spinner fa-spin text-2xl"></i></div>';
                    chartContainer.appendChild(loadingEl);
                }

                // Update button states immediately
                document.querySelectorAll('button[onclick*="setChartTimeframe"]').forEach(btn => {
                    btn.classList.remove('bg-fennec/20', 'text-fennec');
                    btn.classList.add('bg-white/5', 'text-gray-400');
                });
                const activeBtn = Array.from(document.querySelectorAll('button[onclick*="setChartTimeframe"]')).find(
                    b => b.getAttribute('onclick').includes(`'${tf}'`)
                );
                if (activeBtn) {
                    activeBtn.classList.remove('bg-white/5', 'text-gray-400');
                    activeBtn.classList.add('bg-fennec/20', 'text-fennec');
                }

                // IMPORTANT: Reload historical data for new timeframe FIRST, then update chart
                loadHistoricalPrices()
                    .then(() => {
                        // Update chart with new data
                        updateChart();
                        // Remove loading indicator
                        const loadingEl = document.getElementById('chartLoading');
                        if (loadingEl) loadingEl.remove();
                    })
                    .catch(e => {
                        console.error('Chart loading error:', e);
                        // Still update chart with existing data
                        updateChart();
                        const loadingEl = document.getElementById('chartLoading');
                        if (loadingEl) loadingEl.remove();
                    });
            }

            function updateChartTimeframe(tf, event) {
                chartTimeframe = tf;
                // Reload historical data for new timeframe
                loadHistoricalPrices();
                // Update button states
                document.querySelectorAll('button[onclick*="setChartTimeframe"]').forEach(btn => {
                    btn.classList.remove('bg-fennec/20', 'text-fennec');
                    btn.classList.add('bg-white/5', 'text-gray-400');
                });
                const activeBtn = Array.from(document.querySelectorAll('button[onclick*="setChartTimeframe"]')).find(
                    b => b.getAttribute('onclick').includes(`'${tf}'`)
                );
                if (activeBtn) {
                    activeBtn.classList.remove('bg-white/5', 'text-gray-400');
                    activeBtn.classList.add('bg-fennec/20', 'text-fennec');
                }
            }

            // showSection is already defined at the top of script, no need to redefine

            // Live ticker update with prices and fees
            // GLOBAL VARIABLES FOR PRICES
            let globalPrices = { btc: 0, fb: 0, fennec: 0 };

            // UPDATED TICKER FUNCTION - Использует CoinMarketCap через worker
            async function updateLiveTicker() {
                try {
                    const tickerEl = document.getElementById('liveTicker');
                    if (!tickerEl) return;

                    const tickerContent = tickerEl.querySelector('#ticker-content') || tickerEl;

                    // Seed instantly from cache so it never stays blank on slow API
                    seedChartPriceFromCache();

                    const dash = await fetch(`${BACKEND_URL}?action=get_dashboard_data`, {
                        cache: 'force-cache'
                    })
                        .then(r => (r.ok ? r.json().catch(() => null) : null))
                        .catch(() => null);

                    const priceRes = dash?.data?.prices || null;
                    const fractalFee = dash?.data?.fees?.fractal || { fastestFee: 1 };
                    const btcFeeRes = dash?.data?.fees?.bitcoin || { fastestFee: 1 };

                    if (priceRes) {
                        globalPrices.btc = priceRes.btc || globalPrices.btc || 0;
                        globalPrices.fb = priceRes.fb || globalPrices.fb || 0;
                        globalPrices.fennec = priceRes.fennec_in_fb || globalPrices.fennec || 0;

                        // Обновляем заголовок вкладки браузера
                        if (globalPrices.fb > 0) {
                            document.title = `$${globalPrices.fb.toFixed(2)} FB | $FENNEC`;
                        }
                    }

                    // 3. Формируем HTML
                    const items = [];

                    // BTC (округляем до целых)
                    if (globalPrices.btc > 0) {
                        items.push(
                            `<span class="text-white inline-flex items-center gap-2 font-bold"><img src="img/BTC.svg" class="w-4 h-4 rounded-full" onerror="this.style.display='none'"> BTC: $${globalPrices.btc.toLocaleString('en-US', { maximumFractionDigits: 0 })}</span>`
                        );
                    }

                    // FB (показываем 2 знака, если цена > 1, иначе 4)
                    if (globalPrices.fb > 0) {
                        const fbDecimals = globalPrices.fb >= 1 ? 2 : 4;
                        items.push(
                            `<span class="text-white inline-flex items-center gap-2 font-bold"><img src="img/FB.png" class="w-4 h-4 rounded-full" onerror="this.style.display='none'"> FB: $${globalPrices.fb.toFixed(fbDecimals)}</span>`
                        );
                    } else {
                        items.push(
                            `<span class="text-white inline-flex items-center gap-2 font-bold"><img src="img/FB.png" class="w-4 h-4 rounded-full" onerror="this.style.display='none'"> FB: Loading...</span>`
                        );
                    }

                    // FENNEC - always show last known price (seeded from cache/pool)
                    let fennecPrice = globalPrices.fennec;
                    // Fallback к poolReserves если цена не загрузилась
                    if (
                        fennecPrice === 0 &&
                        typeof poolReserves !== 'undefined' &&
                        poolReserves &&
                        poolReserves.FENNEC > 0 &&
                        poolReserves.sFB > 0
                    ) {
                        fennecPrice = poolReserves.sFB / poolReserves.FENNEC;
                        globalPrices.fennec = fennecPrice; // Сохраняем для следующего обновления
                    }

                    if (fennecPrice > 0) {
                        items.push(
                            `<span class="text-fennec inline-flex items-center gap-2 font-bold"><img src="img/fennec.jpg" class="w-4 h-4 rounded-full" onerror="this.style.display='none'"> FENNEC: ${fennecPrice.toFixed(6)} FB</span>`
                        );
                    } else {
                        items.push(
                            `<span class="text-fennec inline-flex items-center gap-2 font-bold"><img src="img/fennec.jpg" class="w-4 h-4 rounded-full" onerror="this.style.display='none'"> FENNEC: --</span>`
                        );
                    }

                    // Gas
                    const fractalGas = fractalFee.fastestFee || 1;
                    const btcGas = btcFeeRes.fastestFee || 1;
                    items.push(
                        `<span class="text-gray-400 inline-flex items-center gap-2">⛽ Bitcoin: ${btcGas} sat/vB</span>`
                    );
                    items.push(
                        `<span class="text-gray-400 inline-flex items-center gap-2">⛽ Fractal: ${fractalGas} sat/vB</span>`
                    );

                    const tickerHtml = items.join('<span class="mx-6 text-gray-700">|</span>');

                    // ИСПРАВЛЕНИЕ: Убираем дублирование - показываем только один раз
                    if (tickerContent) {
                        tickerContent.innerHTML = tickerHtml;
                    } else {
                        tickerEl.innerHTML = tickerHtml;
                    }
                } catch (e) {
                    console.error('❌ Ticker update error:', e);
                    const tickerEl = document.getElementById('liveTicker');
                    if (tickerEl) {
                        tickerEl.innerHTML =
                            '<span class="text-fennec font-bold inline-flex items-center gap-1"><img src="img/fennec.jpg" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'"> FENNEC SYSTEM ONLINE</span>';
                    }
                }
            }

            let __publicTickerInterval = null;
            function startPublicTickerUpdates() {
                if (__publicTickerInterval) return;
                __publicTickerInterval = setInterval(() => {
                    try {
                        updateLiveTicker();
                    } catch (_) {}
                }, 600000);
            }

            function stopPublicTickerUpdates() {
                if (__publicTickerInterval) {
                    clearInterval(__publicTickerInterval);
                    __publicTickerInterval = null;
                }
            }

            // ИСПРАВЛЕНИЕ: Оптимизированные автоматические обновления с правильными интервалами
            // Баланс обновляется чаще, остальное - реже

            // Функция для ручного обновления всех данных
            async function manualRefresh() {
                const btn = document.getElementById('refreshBtn');
                if (btn) {
                    btn.classList.add('animate-spin');
                    btn.disabled = true;
                }

                try {
                    // Обновляем все данные параллельно
                    await Promise.all([
                        fetchReserves(),
                        userAddress ? checkBalance() : Promise.resolve(),
                        userAddress ? refreshTransactionHistory() : Promise.resolve(),
                        updateLiveTicker(),
                        updatePriceData()
                    ]);

                    // Показываем уведомление
                    if (typeof showNotification === 'function') {
                        showNotification('✅ Данные обновлены', 'success', 2000);
                    }
                } catch (e) {
                    console.error('Refresh error:', e);
                    if (typeof showNotification === 'function') {
                        showNotification('❌ Ошибка обновления', 'error', 2000);
                    }
                } finally {
                    if (btn) {
                        btn.classList.remove('animate-spin');
                        btn.disabled = false;
                    }
                }
            }

            // Инициализация - загружаем данные один раз при загрузке страницы
            seedChartPriceFromCache();
            fetchReserves();
            updateLiveTicker(); // Первый запуск тикера
            updatePriceData();

            // Load transaction history on page load if wallet connected (только один раз)
            if (userAddress) {
                setTimeout(() => {
                    checkBalance();
                    refreshTransactionHistory();
                }, 2000);
            }

            startPublicTickerUpdates();
            // Force Scroll to Top Logic
            window.onbeforeunload = function () {
                window.scrollTo(0, 0);
            };
            window.onload = function () {
                setTimeout(() => window.scrollTo(0, 0), 10);
                setTimeout(() => window.scrollTo(0, 0), 100);
            };

            // Scroll to top on page load
            window.scrollTo({ top: 0, behavior: 'instant' });
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    window.scrollTo({ top: 0, behavior: 'instant' });
                    setTimeout(() => window.scrollTo(0, 0), 10);
                    setTimeout(initChart, 1000);
                });
            } else {
                window.scrollTo({ top: 0, behavior: 'instant' });
                setTimeout(() => window.scrollTo(0, 0), 10);
                setTimeout(initChart, 1000);
            }

            document.addEventListener('visibilitychange', () => {
                try {
                    if (document.hidden) {
                        stopPublicTickerUpdates();
                        stopAutoUpdate();
                    } else {
                        window.scrollTo({ top: 0, behavior: 'instant' });
                        startPublicTickerUpdates();
                        if (window.__autoUpdateWanted && userAddress) startAutoUpdate();
                    }
                } catch (_) {}
            });

            console.log('📊 Chart loading historical data from InSwap API...');

            // ===== PROGRESS TRACKING =====
            let progressInterval = null;

            function closeProgress() {
                document.getElementById('progressModal').classList.add('hidden');
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            }

            async function trackWithdrawProgress(withdrawId, tick) {
                document.getElementById('progressModal').classList.remove('hidden');
                document.getElementById('progressTitle').innerText = `Withdrawing ${tick}`;
                document.getElementById('progressTxId').innerText = withdrawId;
                document.getElementById('progressStep').innerText = 'Initializing...';
                document.getElementById('progressPercent').innerText = '0%';
                document.getElementById('progressBar').style.width = '0%';

                let attempts = 0;
                const maxAttempts = 60; // 5 минут (каждые 5 сек)

                progressInterval = setInterval(async () => {
                    attempts++;

                    try {
                        const res = await fetch(`${BACKEND_URL}?action=withdraw_process&id=${withdrawId}`);
                        const json = await res.json();

                        if (json.code === 0 && json.data) {
                            const data = json.data;
                            const total = data.totalNum || 1;
                            const confirmed = data.totalConfirmedNum || 0;
                            const percent = Math.min(Math.round((confirmed / total) * 100), 100);

                            document.getElementById('progressPercent').innerText = `${percent}%`;
                            document.getElementById('progressBar').style.width = `${percent}%`;

                            // Статусы
                            if (data.status === 'completed') {
                                document.getElementById('progressStep').innerText = '✅ Completed!';
                                document.getElementById('progressTitle').innerText = 'Withdrawal Complete!';
                                clearInterval(progressInterval);
                                setTimeout(() => {
                                    closeProgress();
                                    checkBalance();
                                }, 3000);
                            } else if (data.status === 'pendingOrder') {
                                document.getElementById('progressStep').innerText =
                                    `⏳ Processing... (${confirmed}/${total} confirmed)`;
                            } else if (data.status === 'cancelled') {
                                document.getElementById('progressStep').innerText = '❌ Cancelled';
                                clearInterval(progressInterval);
                            } else {
                                document.getElementById('progressStep').innerText = `Status: ${data.status}`;
                            }

                            console.log(`📊 Withdraw progress: ${confirmed}/${total} (${percent}%) - ${data.status}`);
                        }
                    } catch (e) {
                        console.error('Progress tracking error:', e);
                    }

                    // Таймаут после 5 минут
                    if (attempts >= maxAttempts) {
                        document.getElementById('progressStep').innerText = '⏱️ Timeout - check InSwap manually';
                        clearInterval(progressInterval);
                    }
                }, 5000); // Проверяем каждые 5 секунд
            }

            async function trackDepositProgress(depositId, tick) {
                document.getElementById('progressModal').classList.remove('hidden');
                document.getElementById('progressTitle').innerText = `Depositing ${tick}`;
                document.getElementById('progressTxId').innerText = depositId;
                document.getElementById('progressStep').innerText = 'Waiting for confirmations...';
                document.getElementById('progressPercent').innerText = '0%';
                document.getElementById('progressBar').style.width = '0%';

                let attempts = 0;
                const maxAttempts = 60; // 5 minutes

                progressInterval = setInterval(async () => {
                    attempts++;

                    try {
                        // Use deposit_process API to get confirmation status
                        const res = await fetch(`${BACKEND_URL}?action=deposit_process&id=${depositId}`);
                        const json = await res.json();

                        if (json.code === 0 && json.data) {
                            const data = json.data;
                            const total = data.totalNum || 1;
                            const confirmed = data.totalConfirmedNum || 0;
                            const percent = Math.min(Math.round((confirmed / total) * 100), 100);

                            document.getElementById('progressPercent').innerText = `${percent}%`;
                            document.getElementById('progressBar').style.width = `${percent}%`;

                            // Status updates
                            if (data.status === 'completed') {
                                document.getElementById('progressStep').innerText = '✅ Completed!';
                                document.getElementById('progressTitle').innerText = 'Deposit Complete!';
                                clearInterval(progressInterval);
                                setTimeout(() => {
                                    closeProgress();
                                    checkBalance();
                                    refreshTransactionHistory();
                                }, 3000);
                            } else if (data.status === 'pendingOrder' || data.status === 'pending') {
                                document.getElementById('progressStep').innerText =
                                    `⏳ Processing... (${confirmed}/${total} confirmations)`;
                            } else if (data.status === 'cancelled') {
                                document.getElementById('progressStep').innerText = '❌ Cancelled';
                                clearInterval(progressInterval);
                            } else {
                                document.getElementById('progressStep').innerText =
                                    `Status: ${data.status} (${confirmed}/${total})`;
                            }

                            console.log(`📊 Deposit progress: ${confirmed}/${total} (${percent}%) - ${data.status}`);
                        } else {
                            // Fallback: check balance if API doesn't return status
                            await checkBalance();
                            const expectedAmount = parseFloat(document.getElementById('depAmount')?.value || 0);
                            const currentBalance =
                                depositToken === 'sFB'
                                    ? userBalances.sFB
                                    : depositToken === 'FENNEC'
                                      ? userBalances.FENNEC
                                      : userBalances.BTC;

                            if (expectedAmount > 0 && currentBalance > expectedAmount * 0.9) {
                                document.getElementById('progressStep').innerText = '✅ Deposit received!';
                                document.getElementById('progressPercent').innerText = '100%';
                                document.getElementById('progressBar').style.width = '100%';
                                clearInterval(progressInterval);
                                setTimeout(() => {
                                    closeProgress();
                                    refreshTransactionHistory();
                                }, 3000);
                            }
                        }
                    } catch (e) {
                        console.error('Deposit tracking error:', e);
                    }

                    if (attempts >= maxAttempts) {
                        document.getElementById('progressStep').innerText = '⏱️ Timeout - check InSwap manually';
                        clearInterval(progressInterval);
                    }
                }, 5000); // Check every 5 seconds
            }

            // --- REAL HISTORY (FIP-101) ---
            async function fetchHistory() {
                if (!userAddress) return;
                const listEl = document.getElementById('txList');
                if (!listEl) return; // Если элемента нет в верстке

                try {
                    // Определяем, какую историю грузить
                    const isNative = (activeTickers.tick0 && activeTickers.tick0.includes('FB')) || true; // Пока грузим общую или по тикеру

                    // 1. Грузим историю FENNEC
                    let resFennec = { code: -1 };
                    try {
                        const fennecRes = await fetch(
                            `${BACKEND_URL}?action=history&address=${userAddress}&tick=${T_FENNEC}`
                        );
                        if (fennecRes.ok) {
                            resFennec = await fennecRes.json();
                        }
                    } catch (e) {
                        console.warn('Failed to fetch FENNEC history:', e);
                    }

                    // 2. Грузим историю FB (Native)
                    let resFB = { code: -1 };
                    try {
                        const fbRes = await fetch(`${BACKEND_URL}?action=history&address=${userAddress}&tick=FB`);
                        if (fbRes.ok) {
                            resFB = await fbRes.json();
                        }
                    } catch (e) {
                        console.warn('Failed to fetch FB history:', e);
                    }

                    let txs = [];

                    // Парсим FENNEC (BRC-20)
                    if (resFennec.code === 0 && resFennec.data && resFennec.data.detail) {
                        txs = txs.concat(
                            resFennec.data.detail.map(item => ({
                                type: item.type === 'transfer' ? 'Send' : 'Receive',
                                amount: item.amount,
                                tick: 'FENNEC',
                                time: item.blocktime,
                                txid: item.txid
                            }))
                        );
                    }

                    // Парсим FB (Native)
                    if (resFB.code === 0 && resFB.data && resFB.data.detail) {
                        txs = txs.concat(
                            resFB.data.detail.map(item => {
                                // Вычисляем изменение баланса для определения типа
                                const netAmount = item.inSatoshi - item.outSatoshi; // Грубая оценка
                                return {
                                    type: 'Tx',
                                    amount: (Math.abs(item.inSatoshi || item.outSatoshi || 0) / 1e8).toFixed(4), // Просто показываем объем
                                    tick: 'FB',
                                    time: item.timestamp || item.blocktime,
                                    txid: item.txid
                                };
                            })
                        );
                    }

                    // Сортируем по времени (новые сверху) и берем топ 5
                    txs.sort((a, b) => b.time - a.time);
                    txs = txs.slice(0, 5);

                    // Рендерим
                    if (txs.length === 0) {
                        listEl.innerHTML = '<div class="text-center py-2 opacity-50">No recent transactions</div>';
                    } else {
                        listEl.innerHTML = txs
                            .map(tx => {
                                const date = new Date(tx.time * 1000).toLocaleTimeString([], {
                                    hour: '2-digit',
                                    minute: '2-digit'
                                });
                                const isFennec = tx.tick === 'FENNEC';
                                const colorClass = isFennec ? 'text-fennec' : 'text-white';

                                const txExplorerUrl = `https://uniscan.cc/fractal/tx/${tx.txid}`;

                                return `
                                                                    <div class="flex justify-between items-center py-3 border-b border-white/5 last:border-0 hover:bg-white/5 transition px-2 rounded">
                                                                        <div class="flex items-center gap-3">
                                                                            <div class="w-8 h-8 rounded-full bg-white/5 flex items-center justify-center text-xs">
                                                                                ${tx.tick === 'FENNEC' ? '<img src="img/fennec.jpg" class="w-4 h-4 inline-block object-contain">' : '⚡'}
                                                                            </div>
                                                                            <div>
                                                                                <div class="text-xs font-bold text-gray-300">${tx.type}</div>
                                                                                <div class="text-[10px] text-gray-600 font-mono">${date}</div>
                                                                            </div>
                                                                        </div>
                                                                        <div class="text-right">
                                                                            <div class="text-xs font-bold ${colorClass}">${tx.amount} ${tx.tick}</div>
                                                                            <a href="${txExplorerUrl}" target="_blank" class="text-[9px] text-gray-600 hover:text-white underline decoration-dotted">View</a>
                                                                        </div>
                                                                    </div>
                                                                    `;
                            })
                            .join('');
                    }
                } catch (e) {
                    console.error('History error', e);
                    const listEl = document.getElementById('txList');
                    if (listEl) {
                        listEl.innerHTML =
                            '<div class="text-center py-2 opacity-50 text-red-500">Error loading history</div>';
                    }
                }
            }

            // ===== TRANSACTION HISTORY (FIXED) =====
            async function refreshTransactionHistory() {
                const currentTab = document.querySelector('.tab-btn.active')?.id?.replace('tab-', '') || 'swap';

                // Find the correct history element based on current tab
                let historyEl;
                if (currentTab === 'swap') {
                    historyEl = document.getElementById('swapHistory') || document.getElementById('transactionHistory');
                } else if (currentTab === 'deposit') {
                    historyEl =
                        document.getElementById('depositHistory') || document.getElementById('transactionHistory');
                } else if (currentTab === 'withdraw') {
                    historyEl =
                        document.getElementById('withdrawHistory') || document.getElementById('transactionHistory');
                } else {
                    historyEl = document.getElementById('transactionHistory');
                }

                if (!historyEl) {
                    // For pending tab, it's normal - it has its own content
                    if (currentTab === 'pending') return;
                    console.warn('History element not found for tab:', currentTab);
                    return;
                }

                // For swap history, load immediately without wallet
                if (!userAddress && currentTab !== 'swap') {
                    historyEl.innerHTML = `<div class="text-center py-4 text-gray-500 text-xs">Connect wallet to view history</div>`;
                    return;
                }

                // Load swap history immediately even without wallet
                if (currentTab === 'swap' || !currentTab) {
                    // Continue to load swap history
                }

                try {
                    let filterTick = null;
                    let filterType =
                        currentTab === 'deposit' ? 'deposit' : currentTab === 'withdraw' ? 'withdraw' : 'swap';

                    if (filterType === 'deposit')
                        filterTick = depositToken === 'BTC' ? 'BTC' : depositToken === 'FENNEC' ? 'FENNEC' : 'FB';
                    // For withdraw, show both FB and FENNEC together (no filter)
                    else if (filterType === 'withdraw') filterTick = null; // Show all withdraws

                    // Загружаем данные параллельно
                    let deposits = [],
                        withdrawals = [];
                    if (userAddress) {
                        try {
                            // Запрашиваем все withdrawals без фильтра по tick (API может не поддерживать параметр tick)
                            const [dRes, wRes] = await Promise.all([
                                safeFetchJson(
                                    `${BACKEND_URL}?action=deposit_list&address=${userAddress}&start=0&limit=20`,
                                    { timeoutMs: 12000, retries: 2 }
                                ).then(r => r || { code: -1 }),
                                safeFetchJson(
                                    `${BACKEND_URL}?action=withdraw_history&address=${userAddress}&start=0&limit=50`,
                                    { timeoutMs: 12000, retries: 2 }
                                ).then(r => r || { code: -1 })
                            ]);
                            if (dRes.code === 0) deposits = dRes.data?.list || [];
                            if (wRes.code === 0) withdrawals = wRes.data?.list || [];
                        } catch (e) {
                            console.warn('Fetch history error', e);
                        }
                    }

                    let allTxs = [];

                    // --- ЛОГИКА DEPOSIT (показываем последние 10 для всех токенов) ---
                    if (filterType === 'deposit') {
                        // Показываем все депозиты (BTC, FB, FENNEC) вместе, последние 10
                        allTxs = deposits
                            .map(d => {
                                let tick = d.tick || 'FB';
                                if (tick.includes('sFB')) tick = 'FB';
                                if (tick === 'FENNEC') tick = 'FENNEC';
                                if (tick === 'BTC' || tick.includes('BTC')) tick = 'BTC';
                                return { ...d, type: 'deposit', tick };
                            })
                            .sort((a, b) => (b.ts || b.timestamp || 0) - (a.ts || a.timestamp || 0)) // Сортируем по времени (новые первые)
                            .slice(0, 10); // Берем последние 10
                    }
                    // --- ЛОГИКА WITHDRAW (ИСПРАВЛЕНО: Строгая фильтрация на клиенте по полю tick) ---
                    else if (filterType === 'withdraw') {
                        console.log(`📤 Loading withdraw history: ${withdrawals.length} total entries from API`);

                        // 1. Строгая фильтрация на клиенте - только FB и FENNEC withdrawals для текущего адреса
                        const basicList = withdrawals
                            .filter(w => {
                                // Проверяем адрес (если есть в ответе API)
                                if (w.address && w.address.toLowerCase() !== userAddress.toLowerCase()) {
                                    console.log(
                                        `⚠️ Skipping withdraw - wrong address. Expected: ${userAddress}, Got: ${w.address}`
                                    );
                                    return false;
                                }

                                // Проверяем поле tick в ответе API
                                const tick = (w.tick || '').toString();

                                // Только FB (sFB___000, sFB, FB) и FENNEC
                                const isFB =
                                    tick === 'sFB___000' ||
                                    tick === 'sFB' ||
                                    tick === 'FB' ||
                                    tick.toUpperCase() === 'SFB___000' ||
                                    tick.toUpperCase() === 'SFB';
                                const isFENNEC = tick === 'FENNEC' || tick.toUpperCase() === 'FENNEC';

                                // Allow sBTC for BTC withdrawals
                                const isBTC = tick === 'sBTC___000' || tick === 'sBTC' || tick === 'BTC';
                                if (!isFB && !isFENNEC && !isBTC) {
                                    console.log(`⚠️ Skipping withdraw - not FB/FENNEC/BTC. Tick: "${tick}"`, w);
                                    return false;
                                }

                                // Логируем успешный withdrawal для отладки
                                console.log(`✅ Valid withdraw: ${w.amount || 0} ${tick} (ID: ${w.id})`);
                                return true;
                            })
                            .map(w => {
                                // Нормализуем тикер для отображения
                                let tick = (w.tick || '').toString();
                                if (
                                    tick === 'sFB___000' ||
                                    tick === 'sFB' ||
                                    tick.toUpperCase() === 'SFB___000' ||
                                    tick.toUpperCase() === 'SFB'
                                ) {
                                    tick = 'FB';
                                } else if (tick === 'FENNEC' || tick.toUpperCase() === 'FENNEC') {
                                    tick = 'FENNEC';
                                } else if (tick === 'sBTC___000' || tick === 'sBTC' || tick === 'BTC') {
                                    // sBTC is valid for BTC withdrawals
                                    tick = 'BTC';
                                } else {
                                    // Fallback - если не распознали, но прошли фильтр, оставляем как есть
                                    console.warn(`⚠️ Unknown tick format but passed filter: "${tick}"`, w);
                                }
                                return { ...w, tick };
                            });

                        const isLikelyHash = value => {
                            const v = (value || '').toString();
                            return v.length >= 32 && v.length <= 128 && /^[a-fA-F0-9]+$/.test(v);
                        };

                        const limitedList = basicList
                            .sort((a, b) => (b.ts || b.timestamp || 0) - (a.ts || a.timestamp || 0))
                            .slice(0, 10);

                        console.log(
                            `✅ Filtered to ${basicList.length} valid withdrawals (FB + FENNEC) from ${withdrawals.length} total`
                        );

                        // 2. Обогащаем данные: запрашиваем детали для получения реального TXID
                        // Используем Promise.all для параллельной загрузки (быстро)
                        allTxs = await Promise.all(
                            limitedList.map(async w => {
                                let tick = w.tick || 'FB';
                                if (tick.includes('sFB') || tick === 'sFB___000') tick = 'FB';
                                if (tick === 'FENNEC' || tick.includes('FENNEC')) tick = 'FENNEC';
                                if (tick === 'BTC' || tick.includes('BTC')) tick = 'BTC';

                                // По умолчанию берем то, что есть (часто это ID ордера)
                                let displayTxid =
                                    w.receiveTxid ||
                                    w.receiveTxId ||
                                    w.receive_txid ||
                                    w.receiveTxHash ||
                                    w.txid ||
                                    w.hash ||
                                    w.id ||
                                    '';
                                let status = w.status;

                                const needsResolution = !isLikelyHash(displayTxid);

                                // ИСПРАВЛЕНИЕ: Всегда запрашиваем детали для получения receiveTxid (не payTxid)
                                // Для withdraw транзакций нужно использовать receiveTxid, а не payTxid
                                if (needsResolution) {
                                    try {
                                        // Запрашиваем детали БЕЗ параметра address (только ID)
                                        const detailRes = await safeFetchJson(
                                            `${BACKEND_URL}?action=withdraw_process&id=${w.id}`,
                                            { timeoutMs: 12000, retries: 2 }
                                        );

                                        if (detailRes && detailRes.code === 0 && detailRes.data) {
                                            // ИСПРАВЛЕНИЕ: Приоритет receiveTxid (это транзакция получения на Bitcoin Mainnet)
                                            // НЕ используем payTxid (это транзакция сжигания на Fractal)
                                            const realHash =
                                                detailRes.data.receiveTxid ||
                                                detailRes.data.receiveTxId ||
                                                detailRes.data.receive_txid ||
                                                detailRes.data.receiveTxHash ||
                                                detailRes.data.approveTxid ||
                                                detailRes.data.rollUpTxid ||
                                                detailRes.data.inscribeTxid ||
                                                detailRes.data.paymentTxid ||
                                                displayTxid;

                                            // НЕ используем payTxid, так как это транзакция сжигания, а не получения
                                            // payTxid = транзакция сжигания на Fractal
                                            // receiveTxid = транзакция получения на Bitcoin Mainnet (это то, что нужно)

                                            if (isLikelyHash(realHash)) {
                                                displayTxid = realHash;
                                                // console.log(`✅ Using receiveTxid for withdraw ${w.id} (${tick}) -> ${realHash}`);
                                            }
                                        }
                                    } catch (err) {
                                        console.warn(`Failed to verify withdraw ${w.id}`, err);
                                    }
                                }

                                return {
                                    ...w,
                                    type: 'withdraw',
                                    tick,
                                    txid: displayTxid, // Теперь тут реальный хеш
                                    status: status,
                                    ts: w.ts || w.timestamp || Math.floor(Date.now() / 1000) // Добавляем timestamp для сортировки
                                };
                            })
                        );

                        // Сортируем по времени (новые первые)
                        allTxs.sort((a, b) => (b.ts || 0) - (a.ts || 0));
                        console.log(`✅ Processed ${allTxs.length} withdrawals (sorted by time)`);
                    }
                    // --- ЛОГИКА SWAP (ИСПРАВЛЕНО: Используем кэшированные данные) ---
                    else if (filterType === 'swap') {
                        let swapList = [];

                        // ИСПРАВЛЕНИЕ: Используем единую функцию загрузки с кэшем
                        try {
                            const swapData = await loadSwapHistory(true);
                            const sResFB_FENNEC = swapData.fbFennec;
                            const sResBTC_FB = swapData.btcFb;

                            // Обрабатываем историю FB-FENNEC
                            if (sResFB_FENNEC.code === 0 && sResFB_FENNEC.data?.list) {
                                const fbFennecSwaps = sResFB_FENNEC.data.list.map(s => {
                                    const tickIn = s.tickIn || s.tick0 || '';
                                    const tickOut = s.tickOut || s.tick1 || '';
                                    const amountIn = parseFloat(s.amountIn || s.amount0 || s.amount || 0);
                                    const amountOut = parseFloat(s.amountOut || s.amount1 || 0);

                                    let payTick, receiveTick;
                                    if (tickIn.includes('FENNEC')) {
                                        payTick = 'FENNEC';
                                        receiveTick =
                                            tickOut.includes('FB') || tickOut.includes('sFB') ? 'FB' : tickOut;
                                    } else if (tickIn.includes('FB') || tickIn.includes('sFB')) {
                                        payTick = 'FB';
                                        receiveTick = tickOut.includes('FENNEC') ? 'FENNEC' : tickOut;
                                    } else {
                                        payTick = tickIn;
                                        receiveTick = tickOut;
                                    }

                                    return {
                                        ...s,
                                        type: 'swap',
                                        ts: s.ts || s.timestamp || Math.floor(Date.now() / 1000),
                                        payAmount: amountIn,
                                        receiveAmount: amountOut,
                                        payTick: payTick,
                                        receiveTick: receiveTick,
                                        txid: s.txid || s.hash || s.id
                                    };
                                });
                                swapList = swapList.concat(fbFennecSwaps);
                            }

                            // Обрабатываем историю BTC-FB
                            if (sResBTC_FB.code === 0 && sResBTC_FB.data?.list) {
                                const btcFbSwaps = sResBTC_FB.data.list.map(s => {
                                    const tickIn = s.tickIn || s.tick0 || '';
                                    const tickOut = s.tickOut || s.tick1 || '';
                                    const amountIn = parseFloat(s.amountIn || s.amount0 || s.amount || 0);
                                    const amountOut = parseFloat(s.amountOut || s.amount1 || 0);

                                    let payTick, receiveTick;
                                    if (tickIn.includes('BTC') || tickIn.includes('sBTC')) {
                                        payTick = 'BTC'; // Отображаем как BTC, не sBTC
                                        receiveTick =
                                            tickOut.includes('FB') || tickOut.includes('sFB') ? 'FB' : tickOut;
                                    } else if (tickIn.includes('FB') || tickIn.includes('sFB')) {
                                        payTick = 'FB';
                                        receiveTick =
                                            tickOut.includes('BTC') || tickOut.includes('sBTC') ? 'BTC' : tickOut; // Отображаем как BTC
                                    } else {
                                        payTick = tickIn.includes('sBTC') ? 'BTC' : tickIn;
                                        receiveTick = tickOut.includes('sBTC') ? 'BTC' : tickOut;
                                    }

                                    return {
                                        ...s,
                                        type: 'swap',
                                        ts: s.ts || s.timestamp || Math.floor(Date.now() / 1000),
                                        payAmount: amountIn,
                                        receiveAmount: amountOut,
                                        payTick: payTick,
                                        receiveTick: receiveTick,
                                        txid: s.txid || s.hash || s.id
                                    };
                                });
                                swapList = swapList.concat(btcFbSwaps);
                            }

                            console.log(`✅ Loaded ${swapList.length} swaps from API (FB-FENNEC + BTC-FB)`);
                        } catch (e) {
                            console.error('Failed to fetch swap history:', e);
                        }

                        // 2. Fallback на LocalStorage (ТОЛЬКО SWAP)
                        if (swapList.length === 0) {
                            const localHist = JSON.parse(localStorage.getItem('fennec_history') || '[]');
                            // !!! ФИЛЬТРУЕМ СТРОГО ПО ТИПУ SWAP !!!
                            swapList = localHist
                                .filter(tx => tx.type === 'swap')
                                .map(tx => ({
                                    ...tx,
                                    ts: Math.floor((tx.timestamp || Date.now()) / 1000)
                                }));
                        }

                        // 3. ФИЛЬТРАЦИЯ ПО ТЕКУЩЕЙ ПАРЕ (ИСПРАВЛЕНО)
                        // Показываем только свапы для выбранной пары
                        if (currentSwapPair === 'FB_FENNEC') {
                            // Для пары FB-FENNEC показываем только свапы между FB и FENNEC (без BTC)
                            swapList = swapList.filter(s => {
                                const payTick = s.payTick || '';
                                const receiveTick = s.receiveTick || '';
                                // Исключаем свапы с BTC
                                const hasBTC = payTick.includes('BTC') || receiveTick.includes('BTC');
                                // Включаем только свапы между FB и FENNEC
                                const hasFB = payTick.includes('FB') || receiveTick.includes('FB');
                                const hasFENNEC = payTick.includes('FENNEC') || receiveTick.includes('FENNEC');
                                return !hasBTC && hasFB && hasFENNEC;
                            });
                        } else if (currentSwapPair === 'BTC_FB') {
                            // Для пары BTC-FB показываем только свапы между BTC и FB (без FENNEC)
                            swapList = swapList.filter(s => {
                                const payTick = s.payTick || '';
                                const receiveTick = s.receiveTick || '';
                                // Исключаем свапы с FENNEC
                                const hasFENNEC = payTick.includes('FENNEC') || receiveTick.includes('FENNEC');
                                // Включаем только свапы между BTC и FB
                                const hasBTC = payTick.includes('BTC') || receiveTick.includes('BTC');
                                const hasFB = payTick.includes('FB') || receiveTick.includes('FB');
                                return !hasFENNEC && hasBTC && hasFB;
                            });
                        }

                        console.log(`✅ Filtered to ${swapList.length} swaps for pair ${currentSwapPair}`);
                        allTxs = swapList;
                    }

                    // Рендер
                    allTxs.sort((a, b) => (b.ts || 0) - (a.ts || 0));

                    if (allTxs.length === 0) {
                        if (historyEl) {
                            historyEl.innerHTML = `<div class="text-center py-4 text-gray-500 text-xs">No ${filterType} history found</div>`;
                        }
                        return;
                    }

                    // ИСПРАВЛЕНИЕ: Проверяем что historyEl существует перед рендером
                    if (!historyEl) {
                        console.warn('History element not found for rendering');
                        return;
                    }

                    historyEl.innerHTML = allTxs
                        .map(tx => {
                            const date = new Date((tx.ts || 0) * 1000);
                            const dateStr =
                                date.toLocaleDateString('en-GB', {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric'
                                }) +
                                ', ' +
                                date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                            const isDeposit = tx.type === 'deposit';
                            const isSwap = tx.type === 'swap';

                            // Статус
                            let status = tx.status || 'completed';
                            let statusColor = 'text-green-400';
                            let statusText = status;

                            // Для вывода обрабатываем подтверждения
                            if (tx.type === 'withdraw') {
                                if (status === 'completed' || tx.isSuccess) {
                                    statusText = 'Completed';
                                    statusColor = 'text-green-400';
                                } else {
                                    const cur = tx.cur || tx.totalConfirmedNum || 0;
                                    const sum = tx.sum || tx.totalNum || 1;
                                    statusText = `${cur}/${sum} confirm`;
                                    statusColor = 'text-yellow-400';
                                }
                            }

                            // Получаем реальный TXID (улучшенная логика для всех типов транзакций)
                            let realTxid = '';

                            if (tx.type === 'withdraw') {
                                realTxid =
                                    tx.approveTxid ||
                                    tx.rollUpTxid ||
                                    tx.inscribeTxid ||
                                    tx.paymentTxid ||
                                    tx.receiveTxid ||
                                    tx.receiveTxId ||
                                    tx.receive_txid ||
                                    tx.receiveTxHash ||
                                    tx.txid ||
                                    tx.hash ||
                                    tx.id ||
                                    '';
                            } else if (tx.type === 'deposit') {
                                // Для депозита: txid, hash, id
                                realTxid = tx.txid || tx.hash || tx.id || '';
                            } else {
                                // Для других типов (swap и т.д.)
                                realTxid = tx.txid || tx.hash || tx.id || '';
                            }

                            // Проверяем, что это валидный хеш транзакции (минимум 32 символа hex, максимум 128)
                            // Bitcoin/Fractal транзакции обычно 64 символа, но могут быть и другие форматы
                            const isHash =
                                realTxid &&
                                realTxid.length >= 32 &&
                                realTxid.length <= 128 &&
                                /^[a-fA-F0-9]+$/.test(realTxid) &&
                                !realTxid.includes('_') && // Исключаем ID ордеров с подчеркиваниями
                                !realTxid.includes('-'); // Исключаем UUID

                            let txLink = '';
                            if (tx.type !== 'swap' && isHash) {
                                // ИСПРАВЛЕНО: Все действия происходят во Fractal, кроме депозита BTC
                                // Для вывода: всегда Uniscan (Fractal), так как вывод происходит из Fractal
                                // Для депозита: только BTC депозиты ведут на mempool.space, остальное - Uniscan
                                const rawTick = (tx.tick || '').toString().toUpperCase();
                                const tickNorm =
                                    rawTick.includes('SBTC') || rawTick === 'BTC' || rawTick.includes('BTC')
                                        ? 'BTC'
                                        : rawTick.includes('SFB') || rawTick === 'FB'
                                          ? 'FB'
                                          : rawTick.includes('FENNEC')
                                            ? 'FENNEC'
                                            : rawTick;
                                const netRaw = (tx.networkType || tx.network_type || tx.network || '')
                                    .toString()
                                    .toUpperCase();
                                const isBitcoinMainnet = netRaw.includes('BITCOIN') && !netRaw.includes('FRACTAL');
                                const useMempool = tx.type === 'deposit' && (isBitcoinMainnet || tickNorm === 'BTC');

                                txLink = useMempool
                                    ? `<a href="https://mempool.space/tx/${realTxid}" target="_blank" class="text-[10px] text-fennec hover:text-white mt-1 block truncate w-20">View TX ↗</a>`
                                    : `<a href="https://uniscan.cc/fractal/tx/${realTxid}" target="_blank" class="text-[10px] text-fennec hover:text-white mt-1 block truncate w-20">View TX ↗</a>`;
                            }

                            // Format amounts with proper separators
                            const formatAmount = amt => {
                                const num = parseFloat(amt || 0);
                                if (num === 0) return '0';
                                // Use comma for thousands, period for decimals
                                const parts = num
                                    .toFixed(8)
                                    .replace(/\.?0+$/, '')
                                    .split('.');
                                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                                return parts.join('.');
                            };

                            // For swap, show Pay/Receive format with icons
                            if (isSwap) {
                                const payAmt = formatAmount(tx.payAmount || tx.amountIn || tx.amount);
                                const receiveAmt = formatAmount(tx.receiveAmount || tx.amountOut || 0);
                                const payTick = tx.payTick || (tx.tickIn?.includes('FENNEC') ? 'FENNEC' : 'FB');
                                const receiveTick =
                                    tx.receiveTick || (tx.tickOut?.includes('FENNEC') ? 'FENNEC' : 'FB');

                                // Icons for tokens (using site assets from img folder)
                                const payIcon =
                                    payTick === 'FENNEC'
                                        ? '<img src="img/fennec.jpg" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">'
                                        : payTick === 'BTC'
                                          ? '<img src="img/BTC.svg" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">'
                                          : '<img src="img/FB.png" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">';
                                const receiveIcon =
                                    receiveTick === 'FENNEC'
                                        ? '<img src="img/fennec.jpg" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">'
                                        : receiveTick === 'BTC'
                                          ? '<img src="img/BTC.svg" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">'
                                          : '<img src="img/FB.png" class="w-4 h-4 rounded-full" onerror="this.style.display=\'none\'">';

                                return `
                                                                        <div class="bg-black/30 border border-white/5 rounded-lg p-3 mb-2 hover:bg-black/40 transition">
                                                                            <div class="grid grid-cols-3 gap-2 text-xs">
                                                                                <div>
                                                                                    <div class="text-gray-500 text-[10px] mb-1">Pay</div>
                                                                                    <div class="flex items-center gap-1">
                                                                                        ${payIcon}
                                                                                        <span class="font-bold text-white">${payAmt}</span>
                                                                                    </div>
                                                                                </div>
                                                                                <div>
                                                                                    <div class="text-gray-500 text-[10px] mb-1">Receive</div>
                                                                                    <div class="flex items-center gap-1">
                                                                                        ${receiveIcon}
                                                                                        <span class="font-bold text-white">${receiveAmt}</span>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="text-right">
                                                                                    <div class="text-gray-500 text-[10px] mb-1">Time</div>
                                                                                    <div class="text-[10px] text-gray-400">${dateStr}</div>
                                                                                    ${txLink}
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    `;
                            }

                            // For deposit/withdraw, show simple format
                            let amount = formatAmount(tx.amount || tx.totalAmount || 0);

                            // Нормализуем тикер: убираем префиксы sFB, sBTC и т.д.
                            let displayTick = tx.tick || 'FB';
                            if (displayTick.includes('sFB') || displayTick === 'sFB___000') displayTick = 'FB';
                            if (displayTick.includes('sBTC') || displayTick === 'sBTC___000') displayTick = 'BTC';
                            if (displayTick.includes('FENNEC')) displayTick = 'FENNEC';

                            return `
                                                                    <div class="bg-black/30 border border-white/5 rounded-lg p-3 mb-2 hover:bg-black/40 transition">
                                                                        <div class="flex items-center justify-between">
                                                                            <div class="flex items-center gap-2">
                                                                                <div class="w-8 h-8 rounded-full flex items-center justify-center ${isDeposit ? 'bg-green-500/20 text-green-400' : 'bg-fennec/20 text-fennec'}">
                                                                                    <i class="fas ${isDeposit ? 'fa-arrow-down' : 'fa-arrow-up'} text-xs"></i>
                                                                                </div>
                                                                                <div>
                                                                                    <div class="text-xs font-bold text-white">${tx.type.toUpperCase()} ${amount} ${displayTick}</div>
                                                                                    <div class="text-[10px] text-gray-500">${dateStr}</div>
                                                                                </div>
                                                                            </div>
                                                                            <div class="text-right">
                                                                                <div class="text-xs font-bold ${isDeposit ? 'text-green-400' : 'text-fennec'}">${amount}</div>
                                                                                <div class="text-[10px] ${statusColor} mt-1">${statusText}</div>
                                                                                ${txLink}
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                `;
                        })
                        .join('');
                } catch (e) {
                    console.error('Hist Error', e);
                    historyEl.innerHTML = `<div class="text-center py-4 text-red-500 text-xs">Error loading history</div>`;
                }
            }

            // ===== FENNEC ORACLE LOGIC =====
            let isOracleOpen = false;

            // toggleChat is already defined at top, no need to redefine

            const CHAT_HISTORY_KEY = 'fennec_oracle_history_v1';

            function escapeHtml(str) {
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            function renderOracleMarkdown(text) {
                let t = String(text || '');
                t = t.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                t = t.replace(
                    /\[(.*?)\]\((https?:\/\/[^\s)]+)\)/g,
                    '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'
                );
                t = t.replace(/(^|\n)\s*-\s+(.*?)(?=\n|$)/g, '$1<ul><li>$2</li></ul>');
                t = t.replace(/<\/ul>\s*<ul>/g, '');
                t = t.replace(/\n/g, '<br>');
                return t;
            }

            function pushChatHistory(role, text) {
                try {
                    const raw = localStorage.getItem(CHAT_HISTORY_KEY);
                    const arr = raw ? JSON.parse(raw) : [];
                    arr.push({ role, text, ts: Date.now() });
                    while (arr.length > 30) arr.shift();
                    localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(arr));
                } catch (e) {}
            }

            function loadChatHistory() {
                try {
                    const raw = localStorage.getItem(CHAT_HISTORY_KEY);
                    const arr = raw ? JSON.parse(raw) : [];
                    return Array.isArray(arr) ? arr : [];
                } catch (e) {
                    return [];
                }
            }

            function renderChatHistory() {
                const chat = document.getElementById('chatMessages');
                if (!chat) return;
                const items = loadChatHistory();
                if (!items.length) return;

                chat.innerHTML = '';
                for (const it of items) {
                    if (it.role === 'user') {
                        chat.innerHTML += `<div class="flex justify-end msg-anim"><div class="bg-fennec/20 p-3 rounded-lg text-white max-w-[75%] text-xs leading-relaxed">${escapeHtml(it.text)}</div></div>`;
                    } else {
                        chat.innerHTML += `<div class="flex gap-2 items-start msg-anim"><div class="w-6 h-6 flex-shrink-0"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-3 rounded-lg text-gray-300 flex-1 text-xs leading-relaxed oracle-md">${renderOracleMarkdown(escapeHtml(it.text))}</div></div>`;
                    }
                }
                chat.scrollTop = chat.scrollHeight;
            }

            function setChatLoading(isLoading) {
                const el = document.getElementById('chatLoading');
                const btn = document.getElementById('chatSendBtn');
                if (el) el.classList.toggle('hidden', !isLoading);
                if (btn) btn.disabled = !!isLoading;
            }

            window.oracleQuick = function (type) {
                if (type === 'help') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'What can you do?';
                    return sendMessage();
                }
                if (type === 'prices') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'Show current price and explain how it is calculated.';
                    return sendMessage();
                }
                if (type === 'id') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'Open my Fennec ID and explain my tier.';
                    return sendMessage();
                }
                if (type === 'deposit') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'How do deposits work? What explorer link should I use?';
                    return sendMessage();
                }
                if (type === 'withdraw') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'How do withdrawals work and how do I verify them?';
                    return sendMessage();
                }
                if (type === 'swap') {
                    const input = document.getElementById('chatInput');
                    if (input) input.value = 'How do I swap tokens? Explain the swap process.';
                    return sendMessage();
                }
                if (type === 'clear') {
                    try {
                        localStorage.removeItem(CHAT_HISTORY_KEY);
                    } catch (e) {}
                    const chat = document.getElementById('chatMessages');
                    if (chat) {
                        chat.innerHTML = `<div class="flex gap-3"><div class="w-6 h-6 flex items-center"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-2 rounded-lg rounded-tl-none">Ask me anything about Fennec.</div></div>`;
                    }
                    const input = document.getElementById('chatInput');
                    if (input) input.focus();
                    return;
                }
            };

            async function sendMessage() {
                const input = document.getElementById('chatInput');
                const msg = input.value.trim();
                if (!msg) return;
                const chat = document.getElementById('chatMessages');
                chat.innerHTML += `<div class="flex justify-end msg-anim"><div class="bg-fennec/20 p-3 rounded-lg text-white max-w-[75%] text-xs leading-relaxed">${escapeHtml(msg)}</div></div>`;
                pushChatHistory('user', msg);
                input.value = '';
                try {
                    setChatLoading(true);
                    const activeSectionId = document.querySelector('.page-section.active')?.id || '';
                    const currentTab = document.querySelector('.tab-btn.active')?.id?.replace('tab-', '') || '';
                    const history = loadChatHistory()
                        .slice(-12)
                        .map(it => ({
                            role: it.role === 'assistant' ? 'assistant' : 'user',
                            content: String(it.text || '')
                        }));

                    const payload = {
                        message: msg,
                        history,
                        context: {
                            section: activeSectionId,
                            tab: currentTab,
                            swapPair: typeof currentSwapPair !== 'undefined' ? currentSwapPair : '',
                            depositToken: typeof depositToken !== 'undefined' ? depositToken : '',
                            withdrawToken: typeof withdrawToken !== 'undefined' ? withdrawToken : '',
                            isBuying: typeof isBuying !== 'undefined' ? !!isBuying : null,
                            address: typeof userAddress !== 'undefined' ? userAddress : null
                        }
                    };

                    const json = await safeFetchJson(`${BACKEND_URL}?action=chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        timeoutMs: 20000,
                        retries: 1
                    });
                    const reply = String(json && json.reply ? json.reply : '');
                    if (!reply) {
                        throw new Error('Empty reply');
                    }
                    // --- AI ACTION PARSER ---
                    const commandRegex = /\|\|\|(.*?)\|\|\|/;
                    const match = reply.match(commandRegex);
                    let cleanReply = reply;
                    if (match) {
                        const commandJson = match[1];
                        cleanReply = reply.replace(match[0], '');
                        try {
                            const action = JSON.parse(commandJson);
                            console.log('🤖 AI Action detected:', action);
                            executeAIAction(action);
                        } catch (err) {
                            console.error('❌ Failed to parse AI action:', err, 'Command JSON:', commandJson);
                        }
                    } else {
                        console.log('⚠️ No AI action command found in reply');
                    }
                    // ---------------------------
                    const cleanText = cleanReply.trim();
                    pushChatHistory('assistant', cleanText);
                    chat.innerHTML += `<div class="flex gap-2 items-start msg-anim"><div class="w-6 h-6 flex-shrink-0"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-3 rounded-lg text-gray-300 flex-1 text-xs leading-relaxed oracle-md">${renderOracleMarkdown(escapeHtml(cleanText))}</div></div>`;
                    chat.scrollTop = chat.scrollHeight;
                } catch (e) {
                    chat.innerHTML += `<div class="text-red-500 text-center text-[10px]">Error</div>`;
                } finally {
                    setChatLoading(false);
                }
            }

            // ===== AI ACTION EXECUTOR =====
            async function executeAIAction(action) {
                console.log('🤖 Executing AI action:', action.type, action.params);

                // 1. НАВИГАЦИЯ ПО ВКЛАДКАМ
                if (action.type === 'NAVIGATE') {
                    const tab = action.params.tab;
                    // Расширенный список вкладок
                    if (['swap', 'deposit', 'withdraw'].includes(tab)) {
                        switchTab(tab);
                        highlightElement(`tab-${tab}`);
                    }
                    // Открытие Fennec ID
                    if (tab === 'audit' || tab === 'id' || tab === 'fennecid') {
                        // Скроллим к секции ID
                        const auditSection =
                            document.getElementById('auditContainer') ||
                            document.querySelector('[onclick*="refreshAudit"]');
                        if (auditSection) {
                            auditSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        // Запускаем аудит если есть кошелек
                        if (false && userAddress && typeof window.refreshAudit === 'function') {
                            window.refreshAudit();
                        }
                        highlightElement('auditContainer');
                    }
                    // Переход на главную
                    if (tab === 'home' || tab === 'main') {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }
                }

                // 2. ПОДСВЕТКА ЭЛЕМЕНТОВ
                if (action.type === 'HIGHLIGHT') {
                    const elId = action.params.elementId;
                    highlightElement(elId);
                    const el = document.getElementById(elId);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // 3. ПОДКЛЮЧЕНИЕ КОШЕЛЬКА
                if (action.type === 'CONNECT_WALLET') {
                    if (!userAddress) {
                        await connectWallet();
                    }
                    highlightElement('connectBtn');
                }

                // 4. ВЫПОЛНЕНИЕ СВАПА (полный цикл)
                if (action.type === 'EXECUTE_SWAP') {
                    // Проверяем кошелек
                    if (!userAddress) {
                        await connectWallet();
                        await new Promise(r => setTimeout(r, 1000));
                        if (!userAddress) return;
                    }

                    switchTab('swap');
                    const params = action.params;

                    // Устанавливаем параметры
                    if (params.pair) setSwapPair(params.pair);
                    if (params.buy !== undefined && window.isBuying !== params.buy) {
                        switchDir();
                    }

                    await new Promise(r => setTimeout(r, 300));

                    const input = document.getElementById('swapIn');
                    if (input && params.amount) {
                        input.value = params.amount;
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        setTimeout(() => {
                            if (typeof calc === 'function') calc();
                        }, 300);
                    }

                    // Автоматически нажимаем кнопку свапа если указано
                    if (params.autoExecute) {
                        await new Promise(r => setTimeout(r, 500));
                        const swapBtn = document.getElementById('swapBtn');
                        if (swapBtn) swapBtn.click();
                    }

                    highlightElement('swapBtn');
                }

                // 5. ЗАПОЛНЕНИЕ ФОРМЫ СВАПА (без выполнения)
                if (action.type === 'FILL_SWAP') {
                    if (!userAddress) {
                        await connectWallet();
                        await new Promise(r => setTimeout(r, 1000));
                        if (!userAddress) return;
                    }

                    switchTab('swap');
                    const params = action.params;
                    const amount = params.amount;
                    // ИСПРАВЛЕНИЕ: buy=true означает покупку FENNEC (отдаем FB)
                    // buy=false означает продажу FENNEC (отдаем FENNEC)
                    const isBuy = params.buy !== undefined ? params.buy : true;

                    const pair = params.pair || 'FB_FENNEC';
                    setSwapPair(pair);

                    // isBuying=true => отдаем FB, получаем FENNEC
                    // isBuying=false => отдаем FENNEC, получаем FB
                    if (window.isBuying !== isBuy) {
                        switchDir();
                    }

                    await new Promise(r => setTimeout(r, 300));

                    const input = document.getElementById('swapIn');
                    if (input) {
                        input.value = amount;
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        setTimeout(() => {
                            if (typeof calc === 'function') calc();
                        }, 300);
                    }

                    highlightElement('swapBtn');
                }

                // 6. ОТКРЫТИЕ FENNEC ID
                if (action.type === 'OPEN_ID' || action.type === 'GET_ID') {
                    if (!userAddress) {
                        await connectWallet();
                        if (typeof switchTab === 'function') {
                            switchTab('audit');
                        }
                    }
                    if (userAddress && typeof window.refreshAudit === 'function') {
                        if (false) window.refreshAudit();
                    }
                    const container = document.getElementById('auditContainer');
                    if (container) container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // 7. ПЕРЕКЛЮЧЕНИЕ НАПРАВЛЕНИЯ СВАПА
                if (action.type === 'SWITCH_DIRECTION') {
                    if (typeof switchDir === 'function') {
                        switchDir();
                    }
                }

                // 8. УСТАНОВКА ПАРЫ
                if (action.type === 'SET_PAIR') {
                    const pair = action.params.pair;
                    if (typeof setSwapPair === 'function') {
                        setSwapPair(pair);
                    }
                }

                // 9. ОТКРЫТИЕ ДЕПОЗИТА
                if (action.type === 'OPEN_DEPOSIT') {
                    switchTab('deposit');
                    highlightElement('tab-deposit');
                }

                // 10. ОТКРЫТИЕ ВЫВОДА
                if (action.type === 'OPEN_WITHDRAW') {
                    switchTab('withdraw');
                    highlightElement('tab-withdraw');
                }

                // 11. ОБНОВЛЕНИЕ БАЛАНСОВ
                if (action.type === 'REFRESH_BALANCES') {
                    if (typeof fetchBalances === 'function') {
                        await fetchBalances();
                    }
                }
            }

            // Хелпер для подсветки
            function highlightElement(id) {
                const el = document.getElementById(id);
                if (!el) {
                    console.warn(`Element with id "${id}" not found`);
                    return;
                }

                el.classList.add('ai-highlight');

                // Убираем подсветку через 3 секунды
                setTimeout(() => {
                    el.classList.remove('ai-highlight');
                }, 3000);
            }

            // ===== THE BURROW ANIMATION =====
            // REMOVED - Burrow section disabled per user request

            // ===== FENNEC GRAND AUDIT =====
            // auditIdentity already defined above

            // Calculate Fennec Identity (Logic from React component)
            // Функция расчета (Использует готовые stats)
            function calculateFennecIdentity(data) {
                const {
                    netWorth,
                    txCount,
                    utxoCount,
                    first_tx_ts,
                    stats,
                    prices,
                    lpValueFB,
                    lpValueUSD,
                    stakedFB,
                    abandoned_utxo_count
                } = data;

                // ИСПРАВЛЕНИЕ: НЕ используем fallback - только реальные данные
                const now = Math.floor(Date.now() / 1000);
                const MIN_VALID = 1700000000; // Ноябрь 2023
                let daysAlive = 0;
                let validFirstTxTs = first_tx_ts || 0;

                // ИСПРАВЛЕНИЕ: Проверяем, не в миллисекундах ли timestamp
                if (validFirstTxTs > 1000000000000) {
                    // Если timestamp > 1000000000000, это миллисекунды, конвертируем в секунды
                    validFirstTxTs = Math.floor(validFirstTxTs / 1000);
                    console.log(`⚠️ Converted timestamp from milliseconds: ${validFirstTxTs}`);
                }

                // ИСПРАВЛЕНИЕ: Строгая валидация - проверяем что timestamp не в будущем
                if (validFirstTxTs > 0) {
                    const currentDate = new Date();
                    const currentYear = currentDate.getFullYear();
                    const currentMonth = currentDate.getMonth();
                    const currentDay = currentDate.getDate();

                    const tsDate = new Date(validFirstTxTs * 1000);
                    const tsYear = tsDate.getFullYear();
                    const tsMonth = tsDate.getMonth();
                    const tsDay = tsDate.getDate();

                    const isFutureYear = tsYear > currentYear;
                    const isFutureMonth = tsYear === currentYear && tsMonth > currentMonth;
                    const isFutureDay = tsYear === currentYear && tsMonth === currentMonth && tsDay > currentDay;
                    const isFuture = isFutureYear || isFutureMonth || isFutureDay || validFirstTxTs > now;

                    if (validFirstTxTs >= MIN_VALID && validFirstTxTs <= now && !isFuture) {
                        // Валидный timestamp - вычисляем возраст точно
                        daysAlive = Math.ceil((now - validFirstTxTs) / 86400);
                        if (daysAlive < 1) daysAlive = 1; // Минимум 1 день
                    } else if (isFuture) {
                        // Timestamp в будущем - возвращаем 0
                        console.error(
                            `❌ Invalid first_tx_ts in calculateFennecIdentity: ${validFirstTxTs} (date: ${new Date(validFirstTxTs * 1000).toISOString()}, year: ${tsYear}, month: ${tsMonth + 1}, day: ${tsDay}). Current: ${currentYear}-${currentMonth + 1}-${currentDay}, now: ${now}, validFirstTxTs > now: ${validFirstTxTs > now}`
                        );
                        validFirstTxTs = 0;
                        daysAlive = 0;
                    } else {
                        // Timestamp неправильный по другим причинам - возвращаем 0
                        console.error(
                            `❌ Invalid first_tx_ts in calculateFennecIdentity: ${validFirstTxTs} (date: ${new Date(validFirstTxTs * 1000).toISOString()}). Valid range: ${MIN_VALID} - ${now}`
                        );
                        validFirstTxTs = 0;
                        daysAlive = 0;
                    }
                } else {
                    // Нет timestamp - возвращаем 0
                    daysAlive = 0;
                }

                // 1. GENESIS CHECK (СТРОГО 24 ЧАСА)
                // Fractal Mainnet Launch: Sept 9, 2024
                const LAUNCH_DATE = 1725840000;
                const ONE_DAY = 86400;
                const isGenesis =
                    validFirstTxTs > 0 && validFirstTxTs >= LAUNCH_DATE && validFirstTxTs < LAUNCH_DATE + ONE_DAY;

                // 2. ОПРЕДЕЛЕНИЕ РОЛЕЙ (Без стейкера - отключен)
                const isNativeStaker = false; // Стейкинг отключен
                const netWorthUSD = Number(netWorth) || 0;
                const lpCount = stats && typeof stats.lp !== 'undefined' ? Number(stats.lp) || 0 : 0;
                const providerValueUSD = Number(lpValueUSD) || 0;
                const isLiquidityProvider = providerValueUSD >= 50;
                const isWhale = netWorthUSD >= 500;
                const brc20Count = stats && typeof stats.brc20 !== 'undefined' ? Number(stats.brc20) || 0 : 0;
                const runesCount = stats && typeof stats.runes !== 'undefined' ? Number(stats.runes) || 0 : 0;
                const ordinalsCount = stats && typeof stats.ordinals !== 'undefined' ? Number(stats.ordinals) || 0 : 0;
                const totalInscriptions = brc20Count + runesCount + ordinalsCount;
                const isArtifactHunter = totalInscriptions >= 50;
                const isRuneKeeper = runesCount >= 20;

                // 3. РАСЧЕТ ВОЗРАСТА
                const avgTxPerDay = daysAlive > 0 ? txCount / daysAlive : 0;

                // 4. СИСТЕМА БЕЙДЖЕЙ (BADGES)
                let archetype = {
                    title: 'THE DRIFTER',
                    tier: 'Nomad',
                    desc: 'Passing through the fractal dunes.',
                    color: 'text-gray-400',
                    badges: [],
                    icon: '<img src="img/drifter.png" class="w-full h-full object-contain">' // Drifter
                };

                // ✅ НОВАЯ ПРОВЕРКА: FENNEC SOUL (Холдер или LP)
                // Проверяем общий баланс FENNEC (Native + Swap)
                // ИСПРАВЛЕНИЕ: fennecBalance может быть строкой (toFixed), парсим
                const fennecTotal =
                    typeof data.fennecBalance === 'string' ? parseFloat(data.fennecBalance) : data.fennecBalance || 0;
                const fennecWalletOnly = Number(data.fennec_wallet_balance || 0) || 0;
                const hasFennecInLP = data.has_fennec_in_lp || false; // ИСПРАВЛЕНИЕ: Проверяем есть ли LP с FENNEC
                const fennecLpValueUSD = Number(data.fennec_lp_value_usd || 0) || 0;
                const hasFennecSoul = fennecWalletOnly >= 100 || fennecLpValueUSD >= 1;

                const nativeFB = Number(data.nativeBalance || 0) || 0;
                const isMempoolRider = (Number(txCount) || 0) >= 10000;
                const abandonedUtxoCountNum =
                    typeof abandoned_utxo_count === 'number' && Number.isFinite(abandoned_utxo_count)
                        ? abandoned_utxo_count
                        : null;
                const isSandSweeper = abandonedUtxoCountNum !== null && abandonedUtxoCountNum < 100;

                // Collection of all earned badges (v6)
                let badges = [];
                if (isGenesis)
                    badges.push({
                        name: 'GENESIS',
                        icon: '💎',
                        desc: 'You witnessed the first sunrise over the Fractal dunes.',
                        img: 'img/badge_genesis.png'
                    });
                if (isWhale)
                    badges.push({
                        name: 'WHALE',
                        icon: '🐋',
                        desc: 'When you move, the sands shift beneath you.',
                        img: 'img/badge_whale.png'
                    });
                if (isLiquidityProvider)
                    badges.push({
                        name: 'PROVIDER',
                        icon: '💧',
                        desc: 'The desert is thirsty, but your well runs deep.',
                        img: 'img/badge_provider.png'
                    });
                if (fennecTotal >= 10000 || hasFennecInLP)
                    badges.push({
                        name: 'FENNEC MAXI',
                        icon: '🔥',
                        desc: 'The Spirit of the Fox guides your path.',
                        img: 'img/badge_maxi.png'
                    });
                if (isArtifactHunter)
                    badges.push({
                        name: 'ARTIFACT HUNTER',
                        icon: '🏺',
                        desc: 'Your pockets are heavy with echoes of the chain.',
                        img: 'img/badge_collector.png'
                    });
                if (isRuneKeeper)
                    badges.push({
                        name: 'RUNE KEEPER',
                        icon: '🧿',
                        desc: 'You decipher the glyphs. The stones speak to you.',
                        img: 'img/badge_rune.png'
                    });
                if (isMempoolRider)
                    badges.push({
                        name: 'MEMPOOL RIDER',
                        icon: '⚡',
                        desc: 'Surfing the chaos of the 30-second block waves.',
                        img: 'img/badge_mempool_rider.png'
                    });
                if (isSandSweeper)
                    badges.push({
                        name: 'SAND SWEEPER',
                        icon: '🧹',
                        desc: 'Your UTXO set is clean. No trash left in the dunes.',
                        img: 'img/badge_sweeper.png'
                    });

                // Assign badges to archetype
                archetype.badges = badges;
                const badgeCount = badges.length;

                // --- 3. DETERMINE BASE ARCHETYPE ---
                // Сначала определяем "ветку развития" (Base Class)
                let baseKey = 'DRIFTER'; // default

                if (isGenesis && isLiquidityProvider && isWhale) baseKey = 'PRIME';
                else if (lpValueUSD >= 200) baseKey = 'LORD';
                else if (isGenesis) baseKey = 'WALKER';
                else if (isArtifactHunter && isRuneKeeper) baseKey = 'KEEPER';
                else if (txCount > 1000) baseKey = 'ENGINEER';
                else if (netWorthUSD >= 100) baseKey = 'MERCHANT';
                else if (runesCount >= 20) baseKey = 'SHAMAN';
                else baseKey = 'DRIFTER';

                if (badgeCount >= 7) baseKey = 'SINGULARITY';

                // --- 4. EVOLVE TITLE BASED ON BADGES (TIER SYSTEM) ---
                // Определяем уровень на основе количества бейджей
                let tierLevel = 0;
                if (badgeCount >= 6)
                    tierLevel = 3; // God Tier
                else if (badgeCount >= 4)
                    tierLevel = 2; // Elite
                else if (badgeCount >= 2)
                    tierLevel = 1; // Advanced
                else tierLevel = 0; // Basic

                if (baseKey === 'PRIME' || baseKey === 'SINGULARITY') tierLevel = 3;

                // База данных эволюций
                const tierNames = {
                    DRIFTER: ['DESERT RUNNER', 'SAND WANDERER', 'DUNE NOMAD', 'STORM SURFER'],
                    MERCHANT: ['CARAVAN MERCHANT', 'GOLD TRADER', 'OASIS KING', 'DESERT TYCOON'],
                    ENGINEER: ['CODE ENGINEER', 'SYSTEM BUILDER', 'NEURAL ARCHITECT', 'QUANTUM ENGINEER'],
                    SHAMAN: ['RUNE SHAMAN', 'RUNE SEER', 'RUNE PROPHET', 'RUNE DEITY'],
                    KEEPER: ['KEEPER OF LORE', 'CHRONICLER', 'GRAND ARCHIVIST', 'OMNISCIENT'],
                    WALKER: ['FIRST WALKER', 'ANCIENT WALKER', 'PRIMORDIAL', 'TIMELESS ENTITY'],
                    LORD: ['OASIS LORD', 'TERMINAL BARON', 'FRACTAL KING', 'EMPEROR'],
                    PRIME: ['FRACTAL PRIME', 'APEX PRIME', 'OMEGA PRIME', 'PRIME ABSOLUTE'],
                    SINGULARITY: ['THE SINGULARITY', 'THE SINGULARITY', 'THE SINGULARITY', 'THE SINGULARITY']
                };

                // Получаем финальное название
                const evolutionPath = tierNames[baseKey] || tierNames['DRIFTER'];
                // Защита от выхода за пределы массива
                const finalTitle = evolutionPath[Math.min(tierLevel, evolutionPath.length - 1)];

                // Формируем объект архетипа
                archetype = {
                    baseKey: baseKey, // Для выбора картинки
                    title: finalTitle, // Для отображения
                    tierLevel: tierLevel, // Для стилей текста (0-3)
                    tierLabel: '', // Подпись над именем
                    tier: '', // Для совместимости
                    badges: badges
                };

                // --- 4. SCORE & RARITY ---
                // --- 4. SCORE & RARITY (v6.0: 4 baskets + Soul Multiplier) ---
                const txCountNum = Number(txCount) || 0;
                const activityPoints = Math.round(
                    30 * (Math.log10(1 + Math.min(txCountNum, 10000)) / Math.log10(1 + 10000))
                );
                const wealthPoints = Math.round(20 * Math.sqrt(Math.min(netWorthUSD, 500) / 500));
                const timePoints = Math.round(15 * (Math.min(daysAlive, 365) / 365));

                const badgeWeights = {
                    GENESIS: 15,
                    WHALE: 10,
                    PROVIDER: 8,
                    'ARTIFACT HUNTER': 3,
                    'RUNE KEEPER': 3,
                    'MEMPOOL RIDER': 7,
                    'SAND SWEEPER': 3,
                    'FENNEC MAXI': 0
                };
                const badgesPointsRaw = badges.reduce((sum, b) => sum + (badgeWeights[b.name] || 0), 0);
                const badgesPoints = Math.min(35, badgesPointsRaw);
                const baseScoreRaw = activityPoints + wealthPoints + timePoints + badgesPoints;
                const baseScore = Math.min(100, baseScoreRaw);
                const hasMaxi = badges.some(b => b.name === 'FENNEC MAXI');
                const multiplier = hasMaxi ? 1.2 : 1;
                const finalScoreRaw = baseScore * multiplier;
                const activityScore = Math.min(100, Math.round(finalScoreRaw));

                let rarityName = 'CUB';
                let rarityClass = 'card-common';
                let rarityColor = 'text-gray-500'; // ИСПРАВЛЕНИЕ: Определяем rarityColor

                if (activityScore >= 95) {
                    rarityName = 'SPIRIT';
                    rarityClass = 'card-spirit';
                    rarityColor = 'text-spirit';
                } else if (activityScore >= 80) {
                    rarityName = 'ELDER';
                    rarityClass = 'card-elder';
                    rarityColor = 'text-elder';
                } else if (activityScore >= 65) {
                    rarityName = 'ALPHA';
                    rarityClass = 'card-alpha';
                    rarityColor = 'text-alpha';
                } else if (activityScore >= 50) {
                    rarityName = 'HUNTER';
                    rarityClass = 'card-hunter';
                    rarityColor = 'text-hunter';
                } else if (activityScore >= 30) {
                    rarityName = 'SCOUT';
                    rarityClass = 'card-scout';
                    rarityColor = 'text-scout';
                }

                // Статус для UI (дублирует эволюцию для ясности)
                let activityStatus = rarityName;
                let activityColor = rarityColor; // ИСПРАВЛЕНИЕ: Определяем activityColor

                // ИСПРАВЛЕНИЕ: hasFennecSoul уже объявлен выше (строка 6329), не дублируем

                return {
                    archetype,
                    metrics: {
                        wealth: netWorth.toFixed(2), // ИСПРАВЛЕНИЕ: Используем netWorth напрямую (уже рассчитан правильно)
                        daysAlive, // ИСПРАВЛЕНИЕ: Используем daysAlive (уже рассчитан правильно)
                        first_tx_ts: validFirstTxTs,
                        txCount,
                        utxoCount,
                        activityScore,
                        scoreBreakdown: {
                            activityPoints,
                            wealthPoints,
                            timePoints,
                            badgesPoints,
                            baseScore,
                            multiplier,
                            scoreAfterMultiplier: finalScoreRaw
                        },
                        fennecBalance: fennecTotal.toFixed(2), // ИСПРАВЛЕНИЕ: Используем fennecTotal (уже определен выше)
                        fennecNativeBalance: data.fennec_native_balance || 0, // Количество FENNEC на кошельке (для обратной стороны карточки)
                        fennecWalletBalance: data.fennec_wallet_balance || 0,
                        fennecInSwapBalance: data.fennec_inswap_balance || 0,
                        fbTotal: ((data.nativeBalance || 0) + (data.fbSwapBalance || 0) + lpValueFB).toFixed(2), // ИСПРАВЛЕНИЕ: Используем данные из data
                        nativeBalance: (data.nativeBalance || 0).toFixed(4), // ИСПРАВЛЕНИЕ: Используем данные из data
                        rarity: {
                            // Объект редкости для нового дизайна
                            name: rarityName,
                            class: rarityClass,
                            color: rarityColor
                        },
                        rarityName, // Сохраняем для совместимости
                        rarityColor, // Сохраняем для совместимости
                        activityStatus,
                        activityColor,
                        avgTxPerDay: avgTxPerDay.toFixed(2),
                        inscriptionStats: stats,
                        abandonedUtxoCount: abandonedUtxoCountNum,
                        nativeBalance: data.nativeBalance.toFixed(4),
                        fennecBalance: data.fennecBalance,
                        fbSwapBalance: data.fbSwapBalance || 0,
                        stakedFB: stakedFB || 0,
                        lpValueFB: lpValueFB || 0,
                        lpValueUSD: lpValueUSD || 0, // Сохраняем для совместимости
                        fbTotal: (parseFloat(data.nativeBalance) + (data.fbSwapBalance || 0) + (stakedFB || 0)).toFixed(
                            2
                        ),
                        // ✅ Передаем флаг души
                        hasFennecSoul,
                        hasFennecInLP,
                        fennecLpValueUSD,
                        hasFennecMaxi: hasMaxi,
                        badgeCount // Передаем кол-во для UI
                    }
                };
            }

            // Fetch Fennec ID data (v5 - Exact Counts from API)
            async function fetchAuditData(abortSignal = null) {
                if (!userAddress) {
                    // ИСПРАВЛЕНИЕ: Вместо ошибки, предлагаем подключить кошелек
                    const shouldConnect = confirm('Please connect your wallet first. Would you like to connect now?');
                    if (shouldConnect) {
                        await window.connectWallet();
                        if (!userAddress) {
                            throw new Error('Wallet connection cancelled');
                        }
                    } else {
                        throw new Error('Connect wallet first');
                    }
                }
                console.log('🔍 Scanning Fennec ID (v5 - Exact Counts)...');

                try {
                    // ИСПРАВЛЕНИЕ: Проверяем, не отменен ли запрос
                    if (abortSignal?.aborted) {
                        const abortError = new Error('Request aborted');
                        abortError.name = 'AbortError';
                        throw abortError;
                    }
                    // Call the updated Worker endpoint
                    // ИСПРАВЛЕНИЕ: Добавляем pubkey для запросов к InSwap
                    const pubkey = userPubkey || '';
                    // ИСПРАВЛЕНИЕ: Убрана подпись пользователя - не требуется для API запросов
                    const url = pubkey
                        ? `${BACKEND_URL}?action=fractal_audit&address=${userAddress}&pubkey=${pubkey}`
                        : `${BACKEND_URL}?action=fractal_audit&address=${userAddress}`;
                    // ИСПРАВЛЕНИЕ: Передаем abortSignal в fetch для возможности отмены запроса
                    const workerRes = await fetch(url, { signal: abortSignal, cache: 'force-cache' })
                        .then(r => {
                            if (abortSignal?.aborted) {
                                const abortError = new Error('Request aborted');
                                abortError.name = 'AbortError';
                                throw abortError;
                            }
                            return r.json();
                        })
                        .catch(e => {
                            if (abortSignal?.aborted || e.name === 'AbortError') {
                                const abortError = new Error('Request aborted');
                                abortError.name = 'AbortError';
                                throw abortError;
                            }
                            return {};
                        });

                    if (workerRes && typeof workerRes === 'object') {
                        if (workerRes.error) {
                            throw new Error(String(workerRes.error || 'Oracle error'));
                        }
                        if (workerRes.code !== undefined && Number(workerRes.code) !== 0) {
                            throw new Error(
                                String(workerRes.msg || workerRes.message || workerRes.error || 'Oracle error')
                            );
                        }
                    }

                    const apiData =
                        workerRes && typeof workerRes === 'object'
                            ? workerRes.data && typeof workerRes.data === 'object'
                                ? workerRes.data
                                : workerRes
                            : {};

                    try {
                        const svRaw = apiData && apiData.schema_version;
                        if (svRaw !== undefined) {
                            const sv = Number(svRaw);
                            if (!Number.isFinite(sv)) throw new Error('invalid schema_version');
                            if (sv !== 1) throw new Error(`unsupported schema_version: ${sv}`);
                        }
                    } catch (e) {
                        throw new Error('Oracle schema mismatch');
                    }

                    // ИСПРАВЛЕНИЕ: Сохраняем данные для использования в минте
                    window.lastAuditApiData = apiData;

                    const fennecWalletFromWorker = parseFloat(apiData.fennec_wallet_balance || 0);
                    const fennecInSwapFromWorker = parseFloat(apiData.fennec_inswap_balance || 0);

                    // Prices (from Worker, calculated correctly via Pools)
                    const prices = apiData.prices || { btc: 98000, fb: 4.5, fennec_in_fb: 0 };

                    // Stats
                    const utxoCount = apiData.utxo_count || 0;
                    const txCount = apiData.tx_count || 0;
                    const nativeBalance = apiData.native_balance || 0;

                    // Age
                    // ИСПРАВЛЕНИЕ: Без fallback - возвращаем ошибку если timestamp невалидный
                    let daysAlive = 0; // 0 = ошибка
                    const now = Math.floor(Date.now() / 1000);
                    const MIN_VALID = 1700000000; // Ноябрь 2023

                    // ИСПРАВЛЕНИЕ: НЕ используем fallback - только реальные данные
                    let firstTxTs = apiData.first_tx_ts || 0;

                    // ИСПРАВЛЕНИЕ: Проверяем, не в миллисекундах ли timestamp
                    if (firstTxTs > 1000000000000) {
                        firstTxTs = Math.floor(firstTxTs / 1000);
                        console.log(`⚠️ Converted timestamp from milliseconds: ${firstTxTs}`);
                    }

                    if (firstTxTs > 0) {
                        // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Строгая валидация - отклоняем timestamp в будущем
                        const currentDate = new Date();
                        const currentYear = currentDate.getFullYear();
                        const currentMonth = currentDate.getMonth();
                        const currentDay = currentDate.getDate();

                        const tsDate = new Date(firstTxTs * 1000);
                        const tsYear = tsDate.getFullYear();
                        const tsMonth = tsDate.getMonth();
                        const tsDay = tsDate.getDate();

                        const isFutureYear = tsYear > currentYear;
                        const isFutureMonth = tsYear === currentYear && tsMonth > currentMonth;
                        const isFutureDay = tsYear === currentYear && tsMonth === currentMonth && tsDay > currentDay;
                        const isFuture = isFutureYear || isFutureMonth || isFutureDay || firstTxTs > now;

                        if (firstTxTs >= MIN_VALID && firstTxTs <= now && !isFuture) {
                            daysAlive = Math.floor((now - firstTxTs) / 86400);
                            if (daysAlive < 1) daysAlive = 1;
                        } else if (isFuture) {
                            // Timestamp в будущем - отклоняем
                            console.error(
                                `❌ Rejected future timestamp: ${firstTxTs} (date: ${new Date(firstTxTs * 1000).toISOString()}, year: ${tsYear}, month: ${tsMonth + 1}, day: ${tsDay}). Current: ${currentYear}-${currentMonth + 1}-${currentDay}, now: ${now}, firstTxTs > now: ${firstTxTs > now}`
                            );
                            firstTxTs = 0;
                            daysAlive = 0;
                        } else {
                            // Timestamp неправильный по другим причинам - возвращаем 0
                            console.error(
                                `❌ Invalid first_tx_ts: ${firstTxTs} (date: ${new Date(firstTxTs * 1000).toISOString()}). Valid range: ${MIN_VALID} - ${now}`
                            );
                            firstTxTs = 0;
                            daysAlive = 0;
                        }
                    } else {
                        // Нет timestamp - возвращаем 0
                        daysAlive = 0;
                    }

                    // ИСПРАВЛЕНИЕ: Запрашиваем стейкинг с фронтенда (из браузера), так как API требует подпись
                    // Headers для стейкинга (имитация браузера)
                    const stakingHeaders = {
                        'User-Agent':
                            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36',
                        Accept: 'application/json, text/plain, */*',
                        'x-appid': '1adcd7969603261753f1812c9461cd36',
                        'x-front-version': '2125',
                        Referer: 'https://fractal.unisat.io/farming',
                        Origin: 'https://fractal.unisat.io'
                    };

                    // ИСПРАВЛЕНИЕ: Убран frontend fetch для staking - вызывает CORS ошибку
                    // Используем только данные из worker (stakingData)
                    // ИСПРАВЛЕНИЕ: Используем уже загруженные данные из checkBalance() для ускорения
                    // Если данные есть в глобальных переменных, используем их, иначе делаем запрос
                    let fennecBalRes = null;
                    let sFbBalRes = null;

                    // Проверяем, есть ли уже загруженные данные (из checkBalance)
                    if (userBalances && (userBalances.FENNEC > 0 || walletBalances.FENNEC > 0)) {
                        // Используем данные из памяти
                        fennecBalRes = {
                            data: { balance: { swap: userBalances.FENNEC || 0, available: walletBalances.FENNEC || 0 } }
                        };
                        console.log('✅ Using cached FENNEC balance:', fennecBalRes);
                    } else {
                        // Загружаем только если данных нет
                        fennecBalRes = await fetch(
                            `${BACKEND_URL}?action=balance&address=${userAddress}&tick=${T_FENNEC}`
                        )
                            .then(r => r.json())
                            .catch(() => ({}));
                    }

                    if (userBalances && userBalances.sFB > 0) {
                        // Используем данные из памяти
                        sFbBalRes = {
                            data: { balance: { swap: userBalances.sFB || 0, available: walletBalances.sFB || 0 } }
                        };
                        console.log('✅ Using cached sFB balance:', sFbBalRes);
                    } else {
                        // Загружаем только если данных нет
                        sFbBalRes = await fetch(`${BACKEND_URL}?action=balance&address=${userAddress}&tick=${T_SFB}`)
                            .then(r => r.json())
                            .catch(() => ({}));
                    }

                    // Staking берем только из worker (не делаем frontend fetch из-за CORS)
                    const stakingRes = null;

                    // Расширенная обработка балансов InSwap (проверяем разные форматы ответа)
                    let fennecSwapBal = fennecInSwapFromWorker;
                    let fennecWalletBal = fennecWalletFromWorker;
                    let fbSwapBal = 0;

                    // FENNEC баланс
                    if (fennecBalRes?.data) {
                        const balData = fennecBalRes.data;
                        // Вариант 1: { balance: { available: X, swap: Y } }
                        if (balData.balance) {
                            if (fennecWalletBal === 0) {
                                fennecWalletBal = parseFloat(balData.balance.available || 0);
                            }
                            if (fennecSwapBal === 0) {
                                fennecSwapBal = parseFloat(balData.balance.swap || balData.balance.total || 0);
                            }
                        }
                        // Вариант 2: { available: X, swap: Y } напрямую
                        else if (balData.available !== undefined || balData.swap !== undefined) {
                            if (fennecWalletBal === 0) {
                                fennecWalletBal = parseFloat(balData.available || 0);
                            }
                            if (fennecSwapBal === 0) {
                                fennecSwapBal = parseFloat(balData.swap || 0);
                            }
                        }
                        // Вариант 3: { balance: X } (число напрямую)
                        else if (typeof balData.balance === 'number') {
                            if (fennecSwapBal === 0) {
                                fennecSwapBal = balData.balance;
                            }
                        }
                    }

                    // FB баланс (ИСПРАВЛЕНИЕ: Учитываем и кошелек, и InSwap)
                    let fbWalletBal = 0; // Баланс на кошельке
                    if (sFbBalRes?.data) {
                        const balData = sFbBalRes.data;
                        // Вариант 1: { balance: { available: X, swap: Y } }
                        if (balData.balance) {
                            fbSwapBal = parseFloat(
                                balData.balance.swap || balData.balance.available || balData.balance.total || 0
                            );
                            // Баланс на кошельке (не в swap)
                            fbWalletBal = parseFloat(balData.balance.available || 0) - fbSwapBal;
                            if (fbWalletBal < 0) fbWalletBal = 0;
                        }
                        // Вариант 2: { available: X, swap: Y } напрямую
                        else if (balData.available !== undefined || balData.swap !== undefined) {
                            fbSwapBal = parseFloat(balData.swap || 0);
                            fbWalletBal = parseFloat(balData.available || 0) - fbSwapBal;
                            if (fbWalletBal < 0) fbWalletBal = 0;
                        }
                        // Вариант 3: { balance: X } (число напрямую)
                        else if (typeof balData.balance === 'number') {
                            fbSwapBal = balData.balance;
                        }
                    }

                    // Debug логирование (временно)
                    console.log('📊 InSwap Balances Debug:', {
                        fennecRes: fennecBalRes,
                        sFbRes: sFbBalRes,
                        fennecSwapBal,
                        fbSwapBal
                    });

                    // ИСПРАВЛЕНИЕ ОТ GEMINI: WEALTH CALCULATION (REAL DATA SUM)
                    // Net Worth = Кошелек + InSwap + Стейкинг + LP

                    // 1. FENNEC: Кошелек (native) + InSwap (swap)
                    // ИСПРАВЛЕНИЕ: fennecSwapBal уже объявлен выше (строка 5199), используем его
                    const fennecNativeBal = parseFloat(apiData.fennec_native_balance || 0);
                    const fennecTotalBal = fennecNativeBal > 0 ? fennecNativeBal : fennecWalletBal + fennecSwapBal;

                    // 2. FB: Кошелек (native) + InSwap (swap) + Staking (native)
                    // ИСПРАВЛЕНИЕ: fbSwapBal уже объявлен выше (строка 5200), используем его
                    const fbNativeBal = nativeBalance;
                    // fbSwapBal уже определен выше из sFbBalRes

                    // ИСПРАВЛЕНИЕ: Стейкинг отключен (временно) - убран из расчетов
                    let fbStakedBal = 0; // Всегда 0, так как стейкинг отключен

                    // --- WEALTH CALCULATION (NO STAKING) ---
                    const fbTotalBal = fbNativeBal + fbSwapBal; // Без стейкинга

                    // 3. LP (Liquidity Pools) - ИСПРАВЛЕНИЕ: Используем данные из API, если они есть
                    let lpValueFB = parseFloat(apiData.lp_value_fb || 0);
                    let lpValueUSD = parseFloat(apiData.lp_value_usd || 0);

                    // ИСПРАВЛЕНИЕ: Если LP не загрузились из my_pool_list, но есть в all_balance, используем их
                    // Это fallback для случаев, когда my_pool_list возвращает null
                    if (lpValueFB === 0 && lpValueUSD === 0) {
                        // Попытка получить LP из других источников (если есть в debug или других полях)
                        // Пока используем значения из API, которые должны быть рассчитаны в worker
                        console.warn(
                            '⚠️ LP values are 0, but should be calculated in worker from all_balance or my_pool_list'
                        );
                    }

                    // 4. Расчет в USD
                    const fbPrice = prices.fb || 0;

                    // FB Value (ВКЛЮЧАЯ LP - LP обязателен в net worth)
                    const fbValueUSD = (fbTotalBal + lpValueFB) * fbPrice;

                    // ИСПРАВЛЕНИЕ: Цена FENNEC - берем из терминала (poolReserves) если доступна
                    let fennecPriceInFB = parseFloat(apiData.prices?.fennec_in_fb || 0);
                    if (fennecPriceInFB === 0 && poolReserves && poolReserves.FENNEC > 0 && poolReserves.sFB > 0) {
                        // Рассчитываем цену из резервов пула терминала
                        fennecPriceInFB = poolReserves.sFB / poolReserves.FENNEC;
                        console.log('✅ Using FENNEC price from terminal reserves:', fennecPriceInFB);
                    }
                    // ИСПРАВЛЕНИЕ: Убран fallback 0.0005 - показываем реальную цену или 0
                    // Если цена 0, это означает что данные не загрузились - не используем фейковые значения
                    if (fennecPriceInFB === 0) {
                        console.warn('⚠️ FENNEC price is 0 - data not loaded');
                    }

                    // ИСПРАВЛЕНИЕ: Логика расчета Net Worth согласно требованиям:
                    // Net Worth = all_tokens_value_usd + lp_value_usd + токены с кошелька, которых нет в InSwap
                    let allTokensValueUSD = parseFloat(apiData.all_tokens_value_usd || 0);
                    // ИСПРАВЛЕНИЕ: lpValueUSD уже объявлен выше (строка 6537), используем существующую переменную
                    // const lpValueUSD = parseFloat(apiData.lp_value_usd || 0); // УДАЛЕНО: дублирование объявления

                    // ИСПРАВЛЕНИЕ: Токены с кошелька, которых нет в InSwap, уже добавлены в worker.js в all_tokens_value_usd
                    // Они включены в all_tokens_value_usd, если имеют цену

                    // 5. ИТОГ: Net Worth = all_tokens_value_usd + lp_value_usd
                    const netWorthUSD = allTokensValueUSD + lpValueUSD;

                    console.log('💰 NET WORTH DEBUG:', {
                        fbNative: fbNativeBal,
                        fbSwap: fbSwapBal,
                        fbStaked: fbStakedBal,
                        fbTotal: fbTotalBal,
                        fbPrice: prices.fb,
                        fennecNative: fennecNativeBal,
                        fennecSwap: fennecSwapBal,
                        fennecTotal: fennecTotalBal,
                        fennecPriceInFB: fennecPriceInFB,
                        lpValueFB: lpValueFB,
                        lpValueUSD: lpValueUSD,
                        allTokensValueUSD: allTokensValueUSD, // sBTC, wangcai, FENNEC и т.д. (все токены из InSwap)
                        fbValueUSD: fbValueUSD,
                        netWorth: netWorthUSD // = fbValueUSD + allTokensValueUSD (FENNEC включен в allTokensValueUSD)
                    });

                    // Counts (Now EXACT from Worker)
                    const runesCount = apiData.runes_count || 0; // Теперь это точное число UTXO (1465)
                    const brc20Count = apiData.brc20_count || 0;
                    const ordinalsCount = apiData.ordinals_count || 0; // Total Inscriptions
                    const lpCount = apiData.lp_count || 0;

                    // ИСПРАВЛЕНИЕ: BRC-20 count - учитываем и InSwap балансы
                    // Если есть BRC-20 токены в InSwap, которые не учтены в brc20Count, добавляем их
                    let brc20CountFinal = brc20Count;
                    // Проверяем есть ли BRC-20 токены в InSwap балансах (через all_balance или отдельные запросы)
                    // Пока используем brc20Count из API, но можно расширить логику

                    // ИСПРАВЛЕНИЕ: Убеждаемся, что значения - числа
                    const finalRunesCount = Number(runesCount) || 0;
                    const finalBrc20Count = Number(brc20CountFinal) || 0;

                    // Debug logging
                    console.log(
                        `📊 Stats preparation: runesCount=${runesCount} (final=${finalRunesCount}), brc20Count=${brc20Count} (final=${finalBrc20Count})`
                    );

                    // Формируем данные для передачи
                    const auditInput = {
                        nativeBalance: nativeBalance,
                        fennecBalance: fennecTotalBal.toFixed(2),
                        fennec_native_balance: fennecNativeBal, // ИСПРАВЛЕНИЕ: Добавляем нативный баланс FENNEC
                        fennec_wallet_balance: fennecWalletBal,
                        fennec_inswap_balance: fennecSwapBal,
                        fbSwapBalance: fbSwapBal,
                        stakedFB: fbStakedBal, // Стейкинг
                        lpValueFB: lpValueFB, // LP в FB
                        lpValueUSD: lpValueUSD, // ИСПРАВЛЕНИЕ: LP в долларах
                        inswapValueUSD: allTokensValueUSD,
                        netWorth: netWorthUSD,
                        utxoCount,
                        txCount,
                        first_tx_ts: firstTxTs || apiData.first_tx_ts || 0, // ИСПРАВЛЕНИЕ: Используем исправленный timestamp
                        abandoned_utxo_count:
                            typeof apiData.abandoned_utxo_count === 'number' &&
                            Number.isFinite(apiData.abandoned_utxo_count)
                                ? apiData.abandoned_utxo_count
                                : null,
                        has_fennec_in_lp: apiData.has_fennec_in_lp || false, // ИСПРАВЛЕНИЕ: Передаем флаг наличия LP с FENNEC
                        fennec_lp_value_usd: apiData.fennec_lp_value_usd || 0,
                        stats: {
                            total: finalRunesCount + finalBrc20Count + ordinalsCount,
                            runes: finalRunesCount,
                            brc20: finalBrc20Count,
                            ordinals: ordinalsCount,
                            lp: lpCount
                        },
                        prices: {
                            ...prices,
                            fennec_in_fb: fennecPriceInFB // ИСПРАВЛЕНИЕ: Используем цену из терминала
                        }
                    };

                    // Debug logging для проверки передачи
                    console.log(`📦 auditInput.stats:`, JSON.stringify(auditInput.stats));
                    console.log(
                        `💰 FENNEC price:`,
                        fennecPriceInFB,
                        `(from terminal: ${poolReserves && poolReserves.FENNEC > 0 ? 'yes' : 'no'})`
                    );

                    return auditInput;
                } catch (e) {
                    if (e.name === 'AbortError') {
                        console.log('Audit fetch aborted');
                        throw e; // пробрасываем, чтобы runAudit корректно обработал отмену
                    }
                    console.error('Audit Fatal:', e);
                    throw e;
                }
            }

            // Initialize Audit UI
            let initAuditLoading = false;
            async function initAudit() {
                if (auditLoading || initAuditLoading) return;
                const container = document.getElementById('auditContainer');
                if (!container) return;

                // Если карточка уже отрисована или идет загрузка данных, не сбрасываем UI
                if (container.querySelector('#fennecIdIframe') || container.querySelector('.card-scene')) {
                    console.log('ℹ️ Audit UI already present, skipping initAudit');
                    return;
                }

                initAuditLoading = true;

                try {
                    let currentAddr = window.userAddress || userAddress || null;
                    if (currentAddr && typeof window.refreshFennecIdStatus === 'function') {
                        await window.refreshFennecIdStatus(true);
                    }
                    currentAddr = window.userAddress || userAddress || null;
                    const existingCard = !!(window.__fennecIdStatus && window.__fennecIdStatus.hasId);

                    const getLastMintedCardForAddress = addr => {
                        try {
                            const a = String(addr || '').trim();
                            if (!a) return null;
                            const all = JSON.parse(localStorage.getItem(fennecMintedCardsKey()) || '[]');
                            if (!Array.isArray(all) || all.length === 0) return null;
                            const filtered = all
                                .filter(x => x && typeof x === 'object' && String(x.address || '').trim() === a)
                                .sort((x, y) => (Number(y.timestamp || 0) || 0) - (Number(x.timestamp || 0) || 0));
                            return filtered[0] || null;
                        } catch (_) {
                            return null;
                        }
                    };

                    const lastMint = currentAddr ? getLastMintedCardForAddress(currentAddr) : null;
                    window.__lastMintedCard = lastMint;

                    console.log('🎮 Rendering UI, existingCard:', !!existingCard);
                    if (existingCard) {
                        const addrLine = currentAddr
                            ? `Wallet connected: <span class="text-fennec font-mono text-xs">${currentAddr.substring(0, 10)}...${currentAddr.slice(-6)}</span>`
                            : `Wallet not connected`;

                        const existingId = String(
                            (window.__fennecIdStatus && window.__fennecIdStatus.inscriptionId) || ''
                        ).trim();

                        container.innerHTML = `
                            <div class="w-full max-w-2xl">
                                <div class="text-center">
                                    <div class="mb-4 flex justify-center"><img src="img/FENNECID.png" class="w-24 h-24 object-contain drop-shadow-[0_0_20px_rgba(255,107,53,0.5)]"></div>
                                    <p class="text-gray-400 text-sm mb-4">${addrLine}</p>

                                    <div class="w-full flex justify-center mb-4">
                                        <div id="fennecIdIframeContainer" class="w-[340px] h-[520px] rounded-2xl border border-white/10 bg-black/30 overflow-hidden shadow-[0_0_30px_rgba(255,107,53,0.12)]">
                                            <!-- Iframe will be inserted here via JS -->
                                        </div>
                                    </div>
                                    <div id="fennecIdEmbedStatus" class="text-[11px] text-gray-500 mb-4"></div>

                                    <button onclick="window.burnAndRemintAuditCard(event)" id="fidUpdateBtn"
                                            class="mt-3 w-full max-w-md mx-auto px-6 py-4 bg-white/5 border border-white/10 rounded-xl text-white font-black shadow-[0_0_30px_rgba(255,107,53,0.15)] hover:border-fennec/40 hover:bg-fennec/10 transition-all text-lg uppercase tracking-wider">
                                        <span id="fidUpdateBtnText">BURN & REMINT</span>
                                    </button>
                                </div>
                            </div>
                        `;
                        try {
                            await loadExistingCardIntoIframe(existingId);
                        } catch (_) {}
                    } else {
                        const addrLine = currentAddr
                            ? `Wallet connected: <span class="text-fennec font-mono text-xs">${currentAddr.substring(0, 10)}...${currentAddr.slice(-6)}</span>`
                            : `Wallet not connected`;

                        container.innerHTML = `
                            <div class="w-full max-w-2xl">
                                <div class="text-center">
                                    <div class="mb-4 flex justify-center"><img src="img/FENNECID.png" class="w-24 h-24 object-contain drop-shadow-[0_0_20px_rgba(255,107,53,0.5)]"></div>
                                    <h3 class="text-xl font-bold text-white mb-2">Discover Your Identity</h3>
                                    <p class="text-gray-400 text-sm mb-6">${addrLine}</p>
                                    <button onclick="runAudit();" id="getYourIdBtn"
                                            class="w-full max-w-md mx-auto px-6 py-4 bg-gradient-to-r from-fennec to-orange-600 hover:from-orange-500 hover:to-fennec text-black font-black rounded-xl shadow-[0_0_30px_rgba(255,107,53,0.4)] transition-all text-lg uppercase tracking-wider flex items-center justify-center gap-3">
                                        <i class="fas fa-search" id="getYourIdBtnIcon"></i>
                                        <span id="getYourIdBtnText">GET YOUR ID</span>
                                    </button>
                                </div>
                            </div>
                        `;
                    }

                    if (currentAddr && typeof prefetchFennecAudit === 'function') {
                        setTimeout(() => {
                            try {
                                prefetchFennecAudit(false);
                            } catch (_) {}
                        }, 0);
                    }
                } finally {
                    initAuditLoading = false;
                }
            }

            async function loadExistingCardIntoIframe(inscriptionId) {
                const id = String(inscriptionId || '').trim();
                if (!id) return;

                const iframeContainer = document.getElementById('fennecIdIframeContainer');
                const statusEl = document.getElementById('fennecIdEmbedStatus');
                if (statusEl) statusEl.textContent = 'Loading card…';

                try {
                    const url = `${BACKEND_URL}?action=inscription_content&inscriptionId=${encodeURIComponent(id)}`;
                    const res = await fetch(url, { cache: 'no-store' });
                    const j = res.ok ? await res.json().catch(() => null) : null;
                    const data = j && typeof j === 'object' ? j.data || null : null;
                    const html = String(data?.body || data?.contentBody || data?.content_body || '');

                    if (!html) {
                        if (statusEl) statusEl.textContent = 'Failed to load card HTML.';
                        return;
                    }

                    const identity = parseDnaFromChildHtml(html);
                    if (identity && typeof identity === 'object') {
                        auditIdentity = identity;
                    }

                    const patched = patchChildHtmlForEmbed(html);
                    if (iframeContainer) {
                        // Create iframe dynamically with proper sandbox
                        iframeContainer.innerHTML = '';
                        const iframe = document.createElement('iframe');
                        iframe.id = 'fennecIdIframe';
                        iframe.title = 'Fennec ID';
                        iframe.className = 'w-full h-full border-0';
                        // IMPORTANT: No allow-same-origin here
                        iframe.setAttribute('sandbox', 'allow-scripts allow-popups allow-forms');

                        // Use Blob for unique origin
                        const blob = new Blob([patched], { type: 'text/html' });
                        const blobUrl = URL.createObjectURL(blob);
                        iframe.src = blobUrl;

                        iframeContainer.appendChild(iframe);
                    }
                    if (statusEl) statusEl.textContent = '';
                } catch (e) {
                    console.error('loadExistingCardIntoIframe error:', e);
                    if (statusEl) statusEl.textContent = 'Failed to load card.';
                }
            }

            const parseDnaFromChildHtml = html => {
                try {
                    const s = String(html || '');
                    if (!s) return null;
                    const m = s.match(/<script[^>]*id=["']dna-data["'][^>]*>([\s\S]*?)<\/script>/i);
                    if (!m || !m[1]) return null;
                    const raw = String(m[1] || '').trim();
                    if (!raw) return null;
                    return JSON.parse(raw);
                } catch (_) {
                    return null;
                }
            };

            function calculateFennecIdentity(data) {
                const {
                    netWorth,
                    txCount,
                    utxoCount,
                    first_tx_ts,
                    stats,
                    prices,
                    lpValueFB,
                    lpValueUSD,
                    stakedFB,
                    abandoned_utxo_count
                } = data;

                const now = Math.floor(Date.now() / 1000);
                const MIN_VALID = 1700000000;
                let daysAlive = 0;
                let validFirstTxTs = first_tx_ts || 0;

                if (validFirstTxTs > 1000000000000) {
                    validFirstTxTs = Math.floor(validFirstTxTs / 1000);
                }

                if (validFirstTxTs > 0) {
                    const currentDate = new Date();
                    const tsDate = new Date(validFirstTxTs * 1000);
                    const isFuture = validFirstTxTs > now || tsDate > currentDate;

                    if (validFirstTxTs >= MIN_VALID && !isFuture) {
                        daysAlive = Math.ceil((now - validFirstTxTs) / 86400);
                        if (daysAlive < 1) daysAlive = 1;
                    } else {
                        validFirstTxTs = 0;
                        daysAlive = 0;
                    }
                }

                const LAUNCH_DATE = 1725840000;
                const ONE_DAY = 86400;
                const isGenesis =
                    validFirstTxTs > 0 && validFirstTxTs >= LAUNCH_DATE && validFirstTxTs < LAUNCH_DATE + ONE_DAY;

                const netWorthUSD = Number(netWorth) || 0;
                const providerValueUSD = Number(lpValueUSD) || 0;
                const isLiquidityProvider = providerValueUSD >= 50;
                const isWhale = netWorthUSD >= 500;
                const brc20Count = stats?.brc20 || 0;
                const runesCount = stats?.runes || 0;
                const ordinalsCount = stats?.ordinals || 0;
                const totalInscriptions = brc20Count + runesCount + ordinalsCount;
                const isArtifactHunter = totalInscriptions >= 50;
                const isRuneKeeper = runesCount >= 20;

                const fennecTotal = parseFloat(data.fennecBalance || 0);
                const fennecWalletOnly = Number(data.fennec_wallet_balance || 0);
                const hasFennecInLP = !!data.has_fennec_in_lp;
                const fennecLpValueUSD = Number(data.fennec_lp_value_usd || 0);
                const hasFennecSoul = fennecWalletOnly >= 100 || fennecLpValueUSD >= 1;

                const abandonedUtxoCountNum = Number.isFinite(abandoned_utxo_count) ? abandoned_utxo_count : null;
                const isSandSweeper = abandonedUtxoCountNum !== null && abandonedUtxoCountNum < 100;
                const isMempoolRider = (Number(txCount) || 0) >= 10000;

                let badges = [];
                if (isGenesis)
                    badges.push({
                        name: 'GENESIS',
                        icon: '💎',
                        desc: 'You witnessed the first sunrise over the Fractal dunes.',
                        img: 'img/badge_genesis.png'
                    });
                if (isWhale)
                    badges.push({
                        name: 'WHALE',
                        icon: '🐋',
                        desc: 'When you move, the sands shift beneath you.',
                        img: 'img/badge_whale.png'
                    });
                if (isLiquidityProvider)
                    badges.push({
                        name: 'PROVIDER',
                        icon: '💧',
                        desc: 'The desert is thirsty, but your well runs deep.',
                        img: 'img/badge_provider.png'
                    });
                if (fennecTotal >= 10000 || hasFennecInLP)
                    badges.push({
                        name: 'FENNEC MAXI',
                        icon: '🔥',
                        desc: 'The Spirit of the Fox guides your path.',
                        img: 'img/badge_maxi.png'
                    });
                if (isArtifactHunter)
                    badges.push({
                        name: 'ARTIFACT HUNTER',
                        icon: '🏺',
                        desc: 'Your pockets are heavy with echoes of the chain.',
                        img: 'img/badge_collector.png'
                    });
                if (isRuneKeeper)
                    badges.push({
                        name: 'RUNE KEEPER',
                        icon: '🧿',
                        desc: 'You decipher the glyphs. The stones speak to you.',
                        img: 'img/badge_rune.png'
                    });
                if (isMempoolRider)
                    badges.push({
                        name: 'MEMPOOL RIDER',
                        icon: '⚡',
                        desc: 'Surfing the chaos of the 30-second block waves.',
                        img: 'img/badge_mempool_rider.png'
                    });
                if (isSandSweeper)
                    badges.push({
                        name: 'SAND SWEEPER',
                        icon: '🧹',
                        desc: 'Your UTXO set is clean. No trash left in the dunes.',
                        img: 'img/badge_sweeper.png'
                    });

                let baseKey = 'DRIFTER';
                if (isGenesis && isLiquidityProvider && isWhale) baseKey = 'PRIME';
                else if (providerValueUSD >= 200) baseKey = 'LORD';
                else if (isGenesis) baseKey = 'WALKER';
                else if (isArtifactHunter && isRuneKeeper) baseKey = 'KEEPER';
                else if (txCount > 1000) baseKey = 'ENGINEER';
                else if (netWorthUSD >= 100) baseKey = 'MERCHANT';
                else if (runesCount >= 20) baseKey = 'SHAMAN';

                if (badges.length >= 7) baseKey = 'SINGULARITY';

                let tierLevel = 0;
                if (badges.length >= 6) tierLevel = 3;
                else if (badges.length >= 4) tierLevel = 2;
                else if (badges.length >= 2) tierLevel = 1;

                if (baseKey === 'PRIME' || baseKey === 'SINGULARITY') tierLevel = 3;

                const tierNames = {
                    DRIFTER: ['DESERT RUNNER', 'SAND WANDERER', 'DUNE NOMAD', 'STORM SURFER'],
                    MERCHANT: ['CARAVAN MERCHANT', 'GOLD TRADER', 'OASIS KING', 'DESERT TYCOON'],
                    ENGINEER: ['CODE ENGINEER', 'SYSTEM BUILDER', 'NEURAL ARCHITECT', 'QUANTUM ENGINEER'],
                    SHAMAN: ['RUNE SHAMAN', 'RUNE SEER', 'RUNE PROPHET', 'RUNE DEITY'],
                    KEEPER: ['KEEPER OF LORE', 'CHRONICLER', 'GRAND ARCHIVIST', 'OMNISCIENT'],
                    WALKER: ['FIRST WALKER', 'ANCIENT WALKER', 'PRIMORDIAL', 'TIMELESS ENTITY'],
                    LORD: ['OASIS LORD', 'TERMINAL BARON', 'FRACTAL KING', 'EMPEROR'],
                    PRIME: ['FRACTAL PRIME', 'APEX PRIME', 'OMEGA PRIME', 'PRIME ABSOLUTE'],
                    SINGULARITY: ['THE SINGULARITY', 'THE SINGULARITY', 'THE SINGULARITY', 'THE SINGULARITY']
                };

                const evolutionPath = tierNames[baseKey] || tierNames.DRIFTER;
                const finalTitle = evolutionPath[Math.min(tierLevel, evolutionPath.length - 1)];

                const txCountNum = Number(txCount) || 0;
                const activityPoints = Math.round(
                    30 * (Math.log10(1 + Math.min(txCountNum, 10000)) / Math.log10(1 + 10000))
                );
                const wealthPoints = Math.round(20 * Math.sqrt(Math.min(netWorthUSD, 500) / 500));
                const timePoints = Math.round(15 * (Math.min(daysAlive, 365) / 365));

                const badgeWeights = {
                    GENESIS: 15,
                    WHALE: 10,
                    PROVIDER: 8,
                    'ARTIFACT HUNTER': 3,
                    'RUNE KEEPER': 3,
                    'MEMPOOL RIDER': 7,
                    'SAND SWEEPER': 3,
                    'FENNEC MAXI': 0
                };
                const badgesPointsRaw = badges.reduce((sum, b) => sum + (badgeWeights[b.name] || 0), 0);
                const badgesPoints = Math.min(35, badgesPointsRaw);
                const baseScore = Math.min(100, activityPoints + wealthPoints + timePoints + badgesPoints);
                const hasMaxi = badges.some(b => b.name === 'FENNEC MAXI');
                const activityScore = Math.min(100, Math.round(baseScore * (hasMaxi ? 1.2 : 1)));

                let rarityName = 'CUB',
                    rarityClass = 'card-cub',
                    rarityColor = 'text-gray-500';
                if (activityScore >= 95) {
                    rarityName = 'SPIRIT';
                    rarityClass = 'card-spirit';
                    rarityColor = 'text-spirit';
                } else if (activityScore >= 80) {
                    rarityName = 'ELDER';
                    rarityClass = 'card-elder';
                    rarityColor = 'text-elder';
                } else if (activityScore >= 65) {
                    rarityName = 'ALPHA';
                    rarityClass = 'card-alpha';
                    rarityColor = 'text-alpha';
                } else if (activityScore >= 50) {
                    rarityName = 'HUNTER';
                    rarityClass = 'card-hunter';
                    rarityColor = 'text-hunter';
                } else if (activityScore >= 30) {
                    rarityName = 'SCOUT';
                    rarityClass = 'card-scout';
                    rarityColor = 'text-scout';
                }

                return {
                    archetype: { baseKey, title: finalTitle, tierLevel, badges },
                    metrics: {
                        wealth: netWorthUSD.toFixed(2),
                        daysAlive,
                        first_tx_ts: validFirstTxTs,
                        txCount,
                        utxoCount,
                        activityScore,
                        scoreBreakdown: {
                            activityPoints,
                            wealthPoints,
                            timePoints,
                            badgesPoints,
                            baseScore,
                            multiplier: hasMaxi ? 1.2 : 1
                        },
                        fennecBalance: fennecTotal.toFixed(2),
                        fennecNativeBalance: data.fennec_native_balance || 0,
                        fennecWalletBalance: fennecWalletOnly,
                        fennecInSwapBalance: data.fennec_inswap_balance || 0,
                        fbTotal: (
                            parseFloat(data.nativeBalance || 0) +
                            (data.fbSwapBalance || 0) +
                            (lpValueFB || 0)
                        ).toFixed(2),
                        nativeBalance: parseFloat(data.nativeBalance || 0).toFixed(4),
                        rarity: { name: rarityName, class: rarityClass, color: rarityColor },
                        rarityName,
                        rarityColor,
                        activityStatus: rarityName,
                        activityColor: rarityColor,
                        avgTxPerDay: (daysAlive > 0 ? txCount / daysAlive : 0).toFixed(2),
                        inscriptionStats: stats,
                        abandonedUtxoCount: abandonedUtxoCountNum,
                        fbSwapBalance: data.fbSwapBalance || 0,
                        stakedFB: stakedFB || 0,
                        lpValueFB: lpValueFB || 0,
                        lpValueUSD: providerValueUSD,
                        hasFennecSoul,
                        hasFennecInLP,
                        fennecLpValueUSD,
                        hasFennecMaxi: hasMaxi,
                        badgeCount: badges.length
                    }
                };
            }

            window.openLastMintedCard = function () {
                try {
                    const m = window.__lastMintedCard;
                    if (!m || typeof m !== 'object') return;
                    const htmlCode = m.htmlCode || '';
                    if (htmlCode) {
                        const patched = patchChildHtmlForEmbed(htmlCode);
                        const blob = new Blob([patched], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        window.open(url, '_blank');
                        setTimeout(() => {
                            try {
                                URL.revokeObjectURL(url);
                            } catch (e) {}
                        }, 60000);
                        return;
                    }
                    const insc = String(m.inscriptionId || m.inscription_id || '').trim();
                    if (insc) {
                        window.open(`https://uniscan.cc/fractal/content/${insc}`, '_blank');
                    }
                } catch (e) {}
            };

            // Run the audit
            async function runAudit(forceRefresh = false) {
                if (auditLoading) {
                    console.log('⏳ Audit already running');
                    return;
                }

                // Проверяем подключение кошелька
                if (!userAddress && !window.userAddress) {
                    if (typeof window.connectWallet === 'function') {
                        try {
                            await window.connectWallet();
                        } catch (e) {
                            console.error('Failed to connect wallet:', e);
                            alert('Failed to connect wallet. Please try again.');
                            return;
                        }
                        if (!userAddress && !window.userAddress) return;
                    } else {
                        alert('Please connect your wallet first');
                        return;
                    }
                }

                const container = document.getElementById('auditContainer');
                if (!container) return;

                if (!window.FennecIDLib || typeof window.FennecIDLib.createCard !== 'function') {
                    container.innerHTML = `
                                            <div class="w-full max-w-md bg-red-900/20 border border-red-500/50 p-4 rounded-xl text-red-200">
                                                <p class="font-bold mb-2">Fennec ID library missing</p>
                                                <p class="text-sm mb-4">recursive_inscriptions/fennec_lib_v1.js was not loaded.</p>
                                            </div>
                                        `;
                    return;
                }

                auditLoading = true;
                const requestId = ++currentAuditRequestId;
                if (currentAuditAbortController) currentAuditAbortController.abort();
                currentAuditAbortController = new AbortController();

                try {
                    const addr = (userAddress || window.userAddress || '').trim();

                    // Проверяем кэш
                    if (!forceRefresh) {
                        const cacheKey = `audit_v2_${addr}`;
                        const cached = localStorage.getItem(cacheKey);
                        if (cached) {
                            try {
                                const cachedData = JSON.parse(cached);
                                if (Date.now() - cachedData.timestamp < 5 * 60 * 1000) {
                                    console.log('✅ Using cached audit data');
                                    auditIdentity = cachedData.identity;
                                    renderAudit(cachedData.identity);
                                    return;
                                }
                            } catch (e) {}
                        }
                    }

                    // Показываем лоадер
                    const getBtn = document.getElementById('getYourIdBtn');
                    const getIcon = document.getElementById('getYourIdBtnIcon');
                    const getText = document.getElementById('getYourIdBtnText');

                    if (getBtn) {
                        getBtn.disabled = true;
                        getBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    if (getIcon) {
                        getIcon.className = 'fas fa-spinner fa-spin';
                    }
                    if (getText) {
                        getText.textContent = 'SCANNING...';
                    }

                    container.innerHTML = `
                                            <div class="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 backdrop-blur-md">
                                                <div class="relative flex flex-col items-center justify-center gap-6 p-8">
                                                    <div class="relative mb-4 animate-pulse"><img src="img/FENNECID.png" class="w-48 h-48 object-contain" style="filter: drop-shadow(0 0 40px rgba(255,107,53,0.8)) drop-shadow(0 0 80px rgba(255,107,53,0.4));"></div>
                                                    <div class="relative text-fennec text-3xl font-black mb-2 tracking-wider uppercase" style="animation: pulse 1.5s ease-in-out infinite; text-shadow: 0 0 20px rgba(255,107,53,0.6);">🔍 Scanning Identity</div>
                                                    <div class="relative w-80 h-2 bg-white/10 rounded-full overflow-hidden mb-3">
                                                        <div class="h-full bg-gradient-to-r from-fennec via-orange-400 to-fennec rounded-full" style="width: 100%; animation: shimmer 1.5s ease-in-out infinite;"></div>
                                                    </div>
                                                    <div class="relative text-gray-300 text-sm font-mono animate-pulse">Aligning the dunes...</div>
                                                </div>
                                            </div>
                                        `;

                    console.log(`🔍 Starting audit scan #${requestId}...`);
                    const data = await Promise.race([
                        fetchAuditData(currentAuditAbortController.signal),
                        new Promise((_, reject) => {
                            const tid = setTimeout(() => reject(new Error('Timeout')), 90000);
                            currentAuditAbortController.signal.addEventListener('abort', () => clearTimeout(tid));
                        })
                    ]);

                    if (requestId !== currentAuditRequestId) return;

                    const identity = calculateFennecIdentity(data);
                    auditIdentity = identity;

                    localStorage.setItem(
                        `audit_v2_${addr}`,
                        JSON.stringify({
                            identity: identity,
                            timestamp: Date.now()
                        })
                    );

                    renderAudit(identity);
                    console.log('✅ Audit complete!');
                } catch (e) {
                    if (e.name === 'AbortError' || requestId !== currentAuditRequestId) return;
                    console.error('❌ Audit error:', e);
                    container.innerHTML = `
                                            <div class="w-full max-w-md bg-red-900/20 border border-red-500/50 p-4 rounded-xl text-red-200">
                                                <p class="font-bold mb-2">Loading Error</p>
                                                <p class="text-sm mb-4">${e.message || 'Failed to load data.'}</p>
                                                <button onclick="runAudit(true)" class="w-full px-4 py-3 bg-fennec text-black font-bold rounded hover:bg-orange-600 transition">
                                                    Try Again
                                                </button>
                                            </div>
                                        `;
                } finally {
                    if (requestId === currentAuditRequestId) {
                        auditLoading = false;
                    }
                }
            }

            // Helper: Get progressive animation class
            function getAnimationClass(baseKey, tier) {
                // Tier 0: Спящий (общий для всех)
                if (tier === 0) return 'img-tier-0';

                // Tier 1: Пробуждение (общий)
                if (tier === 1) return 'anim-tier-1';

                // Tier 2: Усиление (Группировка по типу эффекта)
                if (tier === 2) {
                    if (baseKey === 'ENGINEER') return 'anim-tier-2-glitch';
                    if (['MERCHANT', 'LORD'].includes(baseKey)) return 'anim-tier-2-shine';
                    if (['SHAMAN', 'KEEPER', 'PRIME', 'SINGULARITY'].includes(baseKey)) return 'anim-tier-2-magic';
                    return 'anim-tier-2-heat'; // Drifter, Walker
                }

                // Tier 3: Полная мощь (Уникальный класс для каждого архетипа)
                if (tier === 3) {
                    if (baseKey === 'ENGINEER') return 'anim-tier-2-glitch';
                    if (baseKey === 'KEEPER') return 'anim-tier-2-magic';
                    if (baseKey === 'DRIFTER') return 'anim-tier-2-heat';
                    return `anim-${baseKey}`;
                }

                return '';
            }

            function formatAddrForCard(addr) {
                if (!addr) return '';
                if (addr.length <= 12) return addr;
                return `${addr.slice(0, 6)}…${addr.slice(-4)}`;
            }

            function applyParentOverridesToIdentity(identity) {
                try {
                    const raw = localStorage.getItem('fennec_parent_overrides') || '';
                    if (!raw) return identity;
                    const map = JSON.parse(raw);
                    if (!map || typeof map !== 'object') return identity;

                    const baseKey = identity?.archetype?.baseKey;
                    if (!baseKey) return identity;
                    const override = map[baseKey] || map['*'];
                    if (!override || typeof override !== 'object') return identity;

                    const out = {
                        ...identity,
                        archetype: { ...(identity.archetype || {}) },
                        metrics: { ...(identity.metrics || {}) }
                    };
                    if (override.archetype && typeof override.archetype === 'object') {
                        Object.assign(out.archetype, override.archetype);
                    }
                    if (override.metrics && typeof override.metrics === 'object') {
                        Object.assign(out.metrics, override.metrics);
                    }
                    return out;
                } catch (e) {
                    return identity;
                }
            }

            // Render Audit UI (3D CARD DESIGN - NEW CINEMATIC LAYOUT)
            function renderAudit(identity) {
                const container = document.getElementById('auditContainer');
                if (!container) return;

                identity = applyParentOverridesToIdentity(identity);

                const { archetype, metrics } = identity;

                const k = archetype.baseKey || 'DRIFTER';
                const tier = archetype.tierLevel || 0;
                const visualKey = k;
                const vfxKey = visualKey;

                let bgImage = 'img/drifter.png';
                if (k === 'SINGULARITY') bgImage = 'img/singularity.png';
                else if (k === 'PRIME') bgImage = 'img/prime.png';
                else if (k === 'LORD') bgImage = 'img/oasis.png';
                else if (k === 'WALKER') bgImage = 'img/walker.png';
                else if (k === 'KEEPER') bgImage = 'img/keeper.png';
                else if (k === 'SHAMAN') bgImage = 'img/shaman.png';
                else if (k === 'ENGINEER') bgImage = 'img/engineer.png';
                else if (k === 'MERCHANT') bgImage = 'img/merchant.png';
                else bgImage = 'img/drifter.png';

                const imgClass = getAnimationClass(vfxKey, tier);

                // Оверлей добавляем ТОЛЬКО для Tier 3 (максимальный эффект)
                let overlayHtml = '';
                let vfx3dHtml = '';
                let vfxWebglHtml = '';
                if (tier >= 1 && vfxKey === 'ENGINEER') {
                    const vfxOpacity = tier === 1 ? 0.18 : tier === 2 ? 0.34 : 0.64;
                    vfx3dHtml = `<div class="vfx-3d" style="--vfx3d-opacity:${vfxOpacity};"></div>`;
                    const vfxWebglOpacity = tier === 1 ? 0.12 : tier === 2 ? 0.18 : 0.32;
                    vfxWebglHtml = `<div class="vfx-webgl" style="--vfxwebgl-opacity:${vfxWebglOpacity};"><canvas></canvas></div>`;
                }
                if (tier === 3) {
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;"></div>${vfxWebglHtml}${vfx3dHtml}`;
                } else if (tier === 2) {
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;opacity:0.30;"></div>${vfxWebglHtml}${vfx3dHtml}`;
                } else if (tier === 1) {
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;opacity:0.18;"></div>${vfxWebglHtml}${vfx3dHtml}`;
                }

                // 3. ТЕКСТОВЫЕ СТИЛИ
                const titleClass = `text-tier-${tier}`;
                const rankBadgeClass = `rank-badge rank-badge-${tier}`;

                const maxiMultiplier = metrics.hasFennecMaxi ? 1.2 : 1.0;
                const maxiBoostPct = Math.round((maxiMultiplier - 1) * 100);

                const badgesFront = archetype.badges
                    .slice(0, 8)
                    .map(b => {
                        const glow =
                            'drop-shadow(0 0 14px rgba(255,107,53,0.85)) drop-shadow(0 0 22px rgba(255,255,255,0.22)) drop-shadow(0 0 40px rgba(168,85,247,0.16))';
                        const tip = b.desc ? `${b.name} — ${b.desc}` : b.name;
                        const content = b.img
                            ? `<img src="${b.img}" style="width:100%;height:100%;object-fit:contain;filter:${glow}" onerror="this.style.display='none';this.nextElementSibling.style.display='block'"> <span style="display:none;font-size:14px;filter:${glow}">${b.icon}</span>`
                            : `<span style="font-size:12px;filter:${glow}">${b.icon}</span>`;
                        return `<div class="badge-medal" style="width:clamp(26px,6.0vw,32px);height:clamp(26px,6.0vw,32px);" title="${tip}">${content}</div>`;
                    })
                    .join('');

                // 3. ВСЕ ВОЗМОЖНЫЕ БЕЙДЖИ (для отображения недоступных бледными)
                // ИСПРАВЛЕНИЕ: Используем данные из metrics для определения условий
                const inscriptionStatsData = metrics.inscriptionStats || { runes: 0, brc20: 0, ordinals: 0, total: 0 };
                const fennecTotal = parseFloat(metrics.fennecBalance || 0);
                const netWorth = parseFloat(metrics.wealth || 0);
                const daysAlive = metrics.daysAlive || 0;
                const txCount = metrics.txCount || 0;
                const lpValueFB = parseFloat(metrics.lpValueFB || 0);
                const hasFennecInLP = !!metrics.hasFennecInLP || lpValueFB > 0; // Fallback
                const nativeFB = parseFloat(metrics.nativeBalance || 0);

                // Проверяем условия для бейджей
                const LAUNCH_DATE = 1725840000;
                const firstTxTs = metrics.first_tx_ts || 0;
                const isGenesis = firstTxTs > 0 && firstTxTs >= LAUNCH_DATE && firstTxTs < LAUNCH_DATE + 86400;
                const isLiquidityProvider = parseFloat(metrics.lpValueUSD || 0) >= 50;
                const isWhale = netWorth >= 500;
                const isArtifactHunter =
                    (Number(inscriptionStatsData.total || 0) ||
                        Number(inscriptionStatsData.brc20 || 0) +
                            Number(inscriptionStatsData.runes || 0) +
                            Number(inscriptionStatsData.ordinals || 0)) >= 50;
                const isRuneKeeper = (Number(inscriptionStatsData.runes) || 0) >= 20;
                const isMempoolRider = (Number(txCount) || 0) >= 10000;
                const abandonedUtxoCount = Number(metrics.abandonedUtxoCount);
                const isSandSweeper = Number.isFinite(abandonedUtxoCount) && abandonedUtxoCount < 100;

                const allPossibleBadges = [
                    {
                        name: 'GENESIS',
                        icon: '💎',
                        img: 'img/badge_genesis.png',
                        desc: 'You witnessed the first sunrise over the Fractal dunes.',
                        condition: isGenesis
                    },
                    {
                        name: 'WHALE',
                        icon: '🐋',
                        img: 'img/badge_whale.png',
                        desc: 'When you move, the sands shift beneath you.',
                        condition: isWhale
                    },
                    {
                        name: 'PROVIDER',
                        icon: '💧',
                        img: 'img/badge_provider.png',
                        desc: 'The desert is thirsty, but your well runs deep.',
                        condition: isLiquidityProvider
                    },
                    {
                        name: 'FENNEC MAXI',
                        icon: '🔥',
                        img: 'img/badge_maxi.png',
                        desc: 'The Spirit of the Fox guides your path.',
                        condition: fennecTotal >= 10000 || hasFennecInLP
                    },
                    {
                        name: 'ARTIFACT HUNTER',
                        icon: '🏺',
                        img: 'img/badge_collector.png',
                        desc: 'Your pockets are heavy with echoes of the chain.',
                        condition: isArtifactHunter
                    },
                    {
                        name: 'RUNE KEEPER',
                        icon: '🧿',
                        img: 'img/badge_rune.png',
                        desc: 'You decipher the glyphs. The stones speak to you.',
                        condition: isRuneKeeper
                    },
                    {
                        name: 'MEMPOOL RIDER',
                        icon: '⚡',
                        img: 'img/badge_mempool_rider.png',
                        desc: 'Surfing the chaos of the 30-second block waves.',
                        condition: isMempoolRider
                    },
                    {
                        name: 'SAND SWEEPER',
                        icon: '🧹',
                        img: 'img/badge_sweeper.png',
                        desc: 'Your UTXO set is clean. No trash left in the dunes.',
                        condition: isSandSweeper
                    }
                ];

                // БЕЙДЖИ BACK (Все бейджи, недоступные бледные)
                const earnedBadgeNames = new Set((archetype.badges || []).map(earned => earned.name));
                const earnedBadges = allPossibleBadges.filter(b => earnedBadgeNames.has(b.name));
                const lockedBadges = allPossibleBadges.filter(b => !earnedBadgeNames.has(b.name));

                const badgesBack = [...earnedBadges, ...lockedBadges]
                    .map(b => {
                        const hasBadge = earnedBadgeNames.has(b.name);
                        const iconOpacity = hasBadge ? '1' : '0.22';
                        const nameOpacity = hasBadge ? '1' : '0.78';
                        const descOpacity = hasBadge ? '0.7' : '0.55';
                        const borderOpacity = hasBadge ? '0.18' : '0.10';
                        const bgOpacity = hasBadge ? '0.06' : '0.035';
                        const glow = hasBadge
                            ? 'drop-shadow(0 0 10px rgba(255,107,53,0.28)) drop-shadow(0 0 18px rgba(255,255,255,0.12))'
                            : 'drop-shadow(0 0 6px rgba(255,255,255,0.10))';
                        const iconHtml = b.img
                            ? `<img src="${b.img}" class="w-full h-full object-contain" style="filter:${glow}" onerror="this.style.display='none';this.nextElementSibling.style.display='block'"><span style="display:none;filter:${glow}">${b.icon}</span>`
                            : `<span style="filter:${glow}">${b.icon}</span>`;
                        return `<div title="${b.name} — ${b.desc}" style="display:flex;align-items:flex-start;gap:10px;background:rgba(255,255,255,${bgOpacity});border:1px solid rgba(255,255,255,${borderOpacity});padding:10px 12px;border-radius:14px;width:100%;min-width:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.25);">
                                                                <div style="width:clamp(32px,6.8vw,40px);height:clamp(32px,6.8vw,40px);display:flex;align-items:center;justify-content:center;flex-shrink:0;opacity:${iconOpacity};border-radius:10px;background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.12);overflow:hidden;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.25);">${iconHtml}</div>
                                                                <div style="text-align:left;min-width:0;flex:1;">
                                                                    <div style="font-size:13px;font-weight:950;color:rgba(255,255,255,${nameOpacity});text-transform:uppercase;letter-spacing:0.10em;line-height:1.1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${b.name}</div>
                                                                    <div style="margin-top:4px;font-size:13px;line-height:1.25;color:rgba(229,231,235,${descOpacity});">${b.desc || ''}</div>
                                                                </div>
                                                            </div>`;
                    })
                    .join('');

                // Progress Bar Calculation (Макс 8 бейджей для 100%)
                const maxBadges = 8;
                const progressPercent = Math.min(100, (archetype.badges.length / maxBadges) * 100);

                // 4. КЛАССЫ ДЛЯ ЭФФЕКТОВ
                const soulClass = metrics.hasFennecSoul ? 'fennec-aura-border' : '';
                const rarityName = metrics.rarity?.name || metrics.rarityName || 'CUB';

                // Маппинг на новые классы для 3D карточки
                const rarityClassMap = {
                    SPIRIT: 'card-spirit',
                    ELDER: 'card-elder',
                    ALPHA: 'card-alpha',
                    HUNTER: 'card-hunter',
                    SCOUT: 'card-scout',
                    CUB: 'card-cub'
                };
                const rarityClass = metrics.rarity?.class || rarityClassMap[rarityName] || 'card-cub';

                // Цвет текста редкости
                let rarityTextClass = 'text-cub';
                if (rarityName === 'SPIRIT') rarityTextClass = 'text-spirit';
                else if (rarityName === 'ELDER') rarityTextClass = 'text-elder';
                else if (rarityName === 'ALPHA') rarityTextClass = 'text-alpha';
                else if (rarityName === 'HUNTER') rarityTextClass = 'text-hunter';
                else if (rarityName === 'SCOUT') rarityTextClass = 'text-scout';
                else rarityTextClass = 'text-cub';

                // Цвет заголовка
                const titleColor =
                    archetype.color && archetype.color.includes('text-transparent') ? archetype.color : 'text-white';

                // ИСПРАВЛЕНИЕ: Определяем borderStyle для карточки
                const isSpirit = rarityName === 'SPIRIT';
                const borderColor = isSpirit
                    ? 'transparent'
                    : rarityName === 'ELDER'
                      ? '#eab308'
                      : rarityName === 'ALPHA'
                        ? '#ef4444'
                        : rarityName === 'HUNTER'
                          ? '#3b82f6'
                          : rarityName === 'SCOUT'
                            ? '#22c55e'
                            : '#555';

                const borderStyle = '';

                // Безопасные значения для данных
                const fbTotal = metrics.fbTotal || '0.00';
                const lastApiData = window.lastAuditApiData || {};
                const inscriptionStatsForDisplay = {
                    runes: Number(metrics.inscriptionStats?.runes ?? lastApiData.runes_count ?? 0) || 0,
                    brc20: Number(metrics.inscriptionStats?.brc20 ?? lastApiData.brc20_count ?? 0) || 0,
                    ordinals: Number(metrics.inscriptionStats?.ordinals ?? lastApiData.ordinals_count ?? 0) || 0,
                    total:
                        Number(metrics.inscriptionStats?.total ?? 0) ||
                        (Number(metrics.inscriptionStats?.brc20 ?? lastApiData.brc20_count ?? 0) || 0) +
                            (Number(metrics.inscriptionStats?.runes ?? lastApiData.runes_count ?? 0) || 0) +
                            (Number(metrics.inscriptionStats?.ordinals ?? lastApiData.ordinals_count ?? 0) || 0)
                };

                try {
                    container.innerHTML = `
                                                            <div class="flex flex-col items-center animate-in fade-in zoom-in duration-500">

                                                                <div class="card-scene group cursor-pointer" onclick="toggleCardFlip(event, this)">
                                                                    <div class="card-object ${rarityClass} ${metrics.hasFennecSoul ? 'fennec-pulse' : ''}" id="card3D" data-tier="${tier}" data-archetype="${visualKey}" data-vfx="${vfxKey}">

                                                                        <!-- FRONT -->
                                                                        <div class="card-face face-front flex flex-col" style="${borderStyle}">
                                                                            <!-- Background Image -->
                                                                            <img src="${bgImage}" class="absolute inset-0 w-full h-full object-cover z-0 ${imgClass}" style="border-radius: 20px; width: 100%; height: 100%; object-position: center top;" onerror="console.error('Failed to load background image:', this.src); this.style.display='none'; this.nextElementSibling.style.display='block';">
                                                                            <div class="absolute inset-0 w-full h-full bg-gradient-to-br from-gray-900 via-gray-800 to-black z-0" style="border-radius: 20px; display:none; width: 100%; height: 100%;"></div>
                                                                            ${overlayHtml}
                                                                            <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-black/60 z-10 rounded-3xl" style="clip-path: inset(0 round 20px);"></div>

                                                                            <!-- Watermark убран по запросу -->

                                                                            <!-- TOP -->
                                                                            <div class="relative z-20 p-5 flex justify-center items-start">
                                                                                <div class="flex gap-1 flex-nowrap justify-center" style="max-width:304px">${badgesFront}</div>
                                                                                    </div>

                                                                            <!-- BOTTOM (Pushed Down) -->
                                                                            <div class="relative z-20 mt-auto px-5 pb-6">
                                                                                <div class="text-center">
                                                                                    ${archetype.tierLabel || archetype.tier ? `<div class="${rankBadgeClass} mb-2">${archetype.tierLabel || archetype.tier}</div>` : ''}
                                                                                    <h2 class="text-3xl font-black uppercase italic leading-none drop-shadow-lg mb-4 ${titleClass} text-center">${archetype.title}</h2>

                                                                                    <div class="mb-5"></div>
                                                                                </div>

                                                                                <div class="h-px w-full bg-gradient-to-r from-white/30 to-transparent mb-3"></div>

                                                                                <div class="flex items-center justify-between gap-2 mb-2" style="text-shadow: 0 2px 10px rgba(0,0,0,0.75);">
                                                                                    ${metrics.hasFennecSoul ? '<div class="text-[9px] font-bold text-fennec flex items-center gap-1" style="filter:drop-shadow(0 0 10px rgba(255,107,53,0.75))"><i class="fas fa-fire"></i> SOUL</div>' : '<div></div>'}
                                                                                    <div class="text-right">
                                                                                        <div class="text-[8px] text-white/70 font-mono tracking-widest mb-0.5">EVOLUTION</div>
                                                                                        <div class="text-sm font-black italic tracking-widest uppercase ${rarityTextClass} drop-shadow-md">${rarityName}</div>
                                                                                    </div>
                                                                                </div>

                                                                                <div class="text-[10px] text-gray-400 text-center tracking-widest">Tap card for details</div>
                                                                                </div>
                                                                            </div>

                                                                        <!-- BACK -->
                                                                        <div class="card-face face-back flex flex-col" style="${borderStyle}">
                                                                            <div style="position:absolute;inset:0;display:none;pointer-events:none;z-index:0;"></div>
                                                                            <!-- Header with Tabs -->
                                                                            <div class="p-4 border-b border-white/10 bg-white/5 relative z-10">
                                                                                <div class="flex justify-center items-center gap-2 mb-3">
                                                                                    <img src="img/phav.png" class="w-5 h-5 rounded-full opacity-70">
                                                                                    <span class="text-[10px] font-bold text-gray-300 tracking-wide">FENNEC ID SYSTEM</span>
                                                                                </div>

                                                                                <!-- Tabs -->
                                                                                <div class="flex gap-2 mb-3">
                                                                                    <button class="card-tab-btn active flex-1 py-2 px-3 rounded-lg border border-white/10 bg-fennec/20 text-fennec text-[9px] font-bold uppercase tracking-wider transition" data-tab="achievements" onclick="event.stopPropagation(); const root=this.closest('.face-back'); root.querySelectorAll('.card-tab-btn').forEach(b=>{b.classList.remove('active','bg-fennec/20','text-fennec'); b.classList.add('bg-white/5','text-gray-400');}); this.classList.remove('bg-white/5','text-gray-400'); this.classList.add('active','bg-fennec/20','text-fennec'); root.querySelectorAll('.card-tab-content').forEach(c=>c.classList.add('hidden')); root.querySelector('.card-tab-achievements').classList.remove('hidden');">
                                                                                        BADGES
                                                                                    </button>
                                                                                    <button class="card-tab-btn flex-1 py-2 px-3 rounded-lg border border-white/10 bg-white/5 text-gray-400 text-[9px] font-bold uppercase tracking-wider transition" data-tab="technical" onclick="event.stopPropagation(); const root=this.closest('.face-back'); root.querySelectorAll('.card-tab-btn').forEach(b=>{b.classList.remove('active','bg-fennec/20','text-fennec'); b.classList.add('bg-white/5','text-gray-400');}); this.classList.remove('bg-white/5','text-gray-400'); this.classList.add('active','bg-fennec/20','text-fennec'); root.querySelectorAll('.card-tab-content').forEach(c=>c.classList.add('hidden')); root.querySelector('.card-tab-technical').classList.remove('hidden');">
                                                                                        STATS
                                                                                    </button>
                                                                                </div>
                                                                                </div>

                                                                            <!-- Tab Content: Achievements -->
                                                                            <div class="card-tab-content card-tab-achievements flex-1 custom-scroll p-4 relative z-10" style="direction: ltr; overflow-y: auto;">
                                                                                <div style="display:flex;flex-direction:column;gap:10px;align-content:start">
                                                                                    ${badgesBack}
                                                                                </div>
                                                                                    </div>

                                                                            <!-- Tab Content: Technical -->
                                                                            <div class="card-tab-content card-tab-technical hidden flex-1 custom-scroll p-4 relative z-10" style="direction: ltr; overflow-y: auto;">
                                                                                <div class="space-y-3">
                                                                                    <div class="bg-white/5 rounded-lg p-3 border border-fennec/30 shadow-[0_0_18px_rgba(255,107,53,0.12)]">
                                                                                        <div class="text-[16px] text-fennec font-black uppercase tracking-widest mb-3 text-center">SCORE BREAKDOWN</div>
                                                                                        <div class="space-y-2">
                                                                                            ${(() => {
                                                                                                const sb =
                                                                                                    metrics.scoreBreakdown ||
                                                                                                    {};
                                                                                                const clamp = (v, m) =>
                                                                                                    Math.max(
                                                                                                        0,
                                                                                                        Math.min(
                                                                                                            m,
                                                                                                            Math.round(
                                                                                                                Number(
                                                                                                                    v
                                                                                                                ) || 0
                                                                                                            )
                                                                                                        )
                                                                                                    );
                                                                                                const rows = [
                                                                                                    {
                                                                                                        label: 'Activity',
                                                                                                        value: clamp(
                                                                                                            sb.activityPoints,
                                                                                                            30
                                                                                                        ),
                                                                                                        max: 30
                                                                                                    },
                                                                                                    {
                                                                                                        label: 'Wealth',
                                                                                                        value: clamp(
                                                                                                            sb.wealthPoints,
                                                                                                            20
                                                                                                        ),
                                                                                                        max: 20
                                                                                                    },
                                                                                                    {
                                                                                                        label: 'Time',
                                                                                                        value: clamp(
                                                                                                            sb.timePoints,
                                                                                                            15
                                                                                                        ),
                                                                                                        max: 15
                                                                                                    },
                                                                                                    {
                                                                                                        label: 'Badges',
                                                                                                        value: clamp(
                                                                                                            sb.badgesPoints,
                                                                                                            35
                                                                                                        ),
                                                                                                        max: 35
                                                                                                    },
                                                                                                    {
                                                                                                        label: 'Score',
                                                                                                        value: clamp(
                                                                                                            sb.baseScore,
                                                                                                            100
                                                                                                        ),
                                                                                                        max: 100
                                                                                                    }
                                                                                                ];
                                                                                                return rows
                                                                                                    .map(r => {
                                                                                                        const pct =
                                                                                                            Math.max(
                                                                                                                0,
                                                                                                                Math.min(
                                                                                                                    100,
                                                                                                                    (r.value /
                                                                                                                        r.max) *
                                                                                                                        100
                                                                                                                )
                                                                                                            );
                                                                                                        const pctText = `${Math.round(pct)}%`;
                                                                                                        return `
                                                                                                    <div>
                                                                                                        <div class="flex justify-between items-center mb-1">
                                                                                                            <span class="text-[15px] font-extrabold text-white/85">${r.label}</span>
                                                                                                            <span class="text-[15px] font-black text-white">${pctText}</span>
                                                                                                        </div>
                                                                                                        <div class="h-3.5 w-full rounded-full bg-black/40 border border-white/10 overflow-hidden">
                                                                                                            <div class="h-full rounded-full bg-gradient-to-r from-fennec via-orange-400 to-yellow-200" style="width:${pct}%;"></div>
                                                                                                        </div>
                                                                                                    </div>`;
                                                                                                    })
                                                                                                    .join('');
                                                                                            })()}
                                                                                            <div class="flex items-center justify-between mt-2">
                                                                                                <div class="text-[14px] text-gray-300 font-extrabold">MAXI BOOST</div>
                                                                                                <div class="flex items-center gap-2 text-right">
                                                                                                    <span class="text-[14px] font-black ${metrics.hasFennecMaxi ? 'text-white' : 'text-gray-500'}">${metrics.hasFennecMaxi ? 'ACTIVE' : 'OFF'}</span>
                                                                                                    <span class="w-2 h-2 rounded-full ${metrics.hasFennecMaxi ? 'bg-fennec' : 'bg-gray-500'} inline-block shadow-[0_0_6px_currentColor]"></span>
                                                                                                </div>
                                                                                            </div>
                                                                                            <div class="flex justify-between items-center">
                                                                                                <span class="text-[14px] text-gray-300 font-extrabold">Final Score</span>
                                                                                                <span class="text-[16px] font-black text-fennec">${metrics.activityScore || 0}%</span>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>

                                                                                    <div class="bg-white/5 rounded-lg p-3 border border-white/10 text-center">
                                                                                        <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-1">NET WORTH</div>
                                                                                        <div class="text-2xl font-black text-white">$${metrics.wealth || '0.00'}</div>
                                                                                    </div>

                                                                                    <div class="grid grid-cols-2 gap-2">
                                                                                        <div class="bg-white/5 rounded-lg p-2.5 border border-white/10 text-center">
                                                                                            <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-1">TXS</div>
                                                                                            <div class="text-sm font-bold text-white">${metrics.txCount || 0}</div>
                                                                                        </div>
                                                                                        <div class="bg-white/5 rounded-lg p-2.5 border border-white/10 text-center">
                                                                                            <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-1">ON-CHAIN AGE</div>
                                                                                            <div class="text-sm font-bold text-white">${metrics.daysAlive} <span class="text-[10px] font-normal text-gray-500">DAYS</span></div>
                                                                                        </div>
                                                                                        <div class="bg-white/5 rounded-lg p-2.5 border border-white/10 text-center">
                                                                                            <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-1">USELESS UTXO</div>
                                                                                            <div class="text-sm font-bold text-white">${metrics.abandonedUtxoCount === null || metrics.abandonedUtxoCount === undefined ? '—' : metrics.abandonedUtxoCount}</div>
                                                                                        </div>
                                                                                        <div class="bg-white/5 rounded-lg p-2.5 border border-white/10 text-center">
                                                                                            <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-1">UTXOS</div>
                                                                                            <div class="text-sm font-bold text-white">${metrics.utxoCount || 0}</div>
                                                                                        </div>
                                                                                    </div>

                                                                                    <div class="bg-white/5 rounded-lg p-3 border border-white/10">
                                                                                        <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-2 text-center">ASSETS</div>
                                                                                        <div class="bg-black/20 rounded-lg p-2.5 border border-white/5 text-center mb-3">
                                                                                            <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-1">LP VALUE</div>
                                                                                            <div class="text-sm font-bold text-white">$${parseFloat(metrics.lpValueUSD || 0).toFixed(2)}</div>
                                                                                        </div>
                                                                                        <div class="grid grid-cols-2 gap-3">
                                                                                            <div class="bg-black/20 rounded-lg p-2.5 border border-white/5">
                                                                                                <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-2 text-center">FB</div>
                                                                                                <div class="flex flex-col gap-2">
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">Wallet</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.nativeBalance || 0).toFixed(4)}</span></div>
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">InSwap</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.fbSwapBalance || 0).toFixed(4)}</span></div>
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">Total</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.fbTotal || 0).toFixed(2)}</span></div>
                                                                                                </div>
                                                                                            </div>
                                                                                            <div class="bg-black/20 rounded-lg p-2.5 border border-white/5">
                                                                                                <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-2 text-center">FENNEC</div>
                                                                                                <div class="flex flex-col gap-2">
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">Wallet</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.fennecWalletBalance || 0).toFixed(2)}</span></div>
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">InSwap</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.fennecInSwapBalance || 0).toFixed(2)}</span></div>
                                                                                                    <div class="flex justify-between items-center"><span class="text-[9px] text-gray-400">Total</span><span class="text-[10px] font-bold text-white">${parseFloat(metrics.fennecBalance || 0).toFixed(2)}</span></div>
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>

                                                                                    <div class="bg-white/5 rounded-lg p-3 border border-white/10">
                                                                                        <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-2 text-center">VAULT</div>
                                                                                        <div class="grid grid-cols-3 gap-2">
                                                                                            <div class="bg-black/20 rounded-lg p-2.5 border border-white/5 text-center">
                                                                                                <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-1">Runes</div>
                                                                                                <div class="text-sm font-bold text-white">${inscriptionStatsForDisplay.runes || 0}</div>
                                                                                            </div>
                                                                                            <div class="bg-black/20 rounded-lg p-2.5 border border-white/5 text-center">
                                                                                                <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-1">BRC-20</div>
                                                                                                <div class="text-sm font-bold text-white">${inscriptionStatsForDisplay.brc20 || 0}</div>
                                                                                            </div>
                                                                                            <div class="bg-black/20 rounded-lg p-2.5 border border-white/5 text-center">
                                                                                                <div class="text-[8px] text-gray-500 uppercase tracking-wider mb-1">Inscriptions</div>
                                                                                                <div class="text-sm font-bold text-white">${inscriptionStatsForDisplay.ordinals || 0}</div>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        </div>

                                                                    </div>
                                                                </div>

                                                                <!-- PARENT INSCRIPTION (OPTIONAL) -->


                                                                <!-- MINT BUTTON -->
                                                                <button onclick="mintAuditCard(event)" id="mintBtn" class="mt-6 w-full max-w-[320px] py-4 bg-gradient-to-r from-fennec to-orange-600 hover:brightness-110 text-black font-black text-xl rounded-xl shadow-[0_0_30px_rgba(255,107,53,0.3)] transition uppercase flex items-center justify-center gap-2 transform active:scale-95 group">
                                                                    <i class="fas fa-cube group-hover:rotate-12 transition"></i> <span id="mintBtnText">1 FB</span>
                                                                </button>

                                                                <button onclick="window.checkDiscountEligibility()" id="checkDiscountBtn" class="mt-3 w-full max-w-[320px] py-2 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition uppercase tracking-wider">
                                                                    CHECK DISCOUNT ELIGIBILITY
                                                                </button>

                                                                <div id="discountWhy" class="mt-2 w-full max-w-[320px] text-[10px] text-gray-500 text-center font-mono"></div>

                                                                <div class="mt-3 w-full max-w-[320px] bg-white/5 border border-white/10 rounded-lg p-3">
                                                                    <div class="text-[8px] text-gray-400 uppercase tracking-wider mb-2 text-center">MINT REFS</div>
                                                                    <input id="mintChildLibRef" placeholder="fennec-lib (inscription id)" class="w-full mb-2 bg-black/30 border border-white/10 rounded-lg px-3 py-2 text-[11px] text-white outline-none focus:border-fennec/50 transition" />
                                                                    <input id="mintChildConfigRef" placeholder="fennec-config (inscription id)" class="w-full mb-2 bg-black/30 border border-white/10 rounded-lg px-3 py-2 text-[11px] text-white outline-none focus:border-fennec/50 transition" />
                                                                    <input id="mintChildManifestRef" placeholder="fennec-manifest (optional)" class="w-full mb-2 bg-black/30 border border-white/10 rounded-lg px-3 py-2 text-[11px] text-white outline-none focus:border-fennec/50 transition" />
                                                                    <button onclick="window.saveMintChildRefs()" class="w-full py-2 bg-white/5 border border-white/10 rounded-lg text-[10px] text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition uppercase tracking-wider">SAVE</button>
                                                                    <button onclick="window.useFallbackMintChildRefs()" class="mt-2 w-full py-2 bg-white/5 border border-white/10 rounded-lg text-[10px] text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition uppercase tracking-wider">USE FALLBACK IDS</button>
                                                                    <button onclick="window.clearMintChildRefs()" class="mt-2 w-full py-2 bg-white/5 border border-white/10 rounded-lg text-[10px] text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition uppercase tracking-wider">CLEAR REFS</button>
                                                                    <button onclick="window.inscribeFennecCorePack()" class="mt-2 w-full py-2 bg-fennec/15 text-fennec border border-fennec/30 rounded-lg text-[10px] font-black hover:bg-fennec/25 transition uppercase tracking-wider">INSCRIBE CORE PACK</button>
                                                                    <button onclick="window.inscribeFennecManifestOnly()" class="mt-2 w-full py-2 bg-fennec/10 text-fennec border border-fennec/30 rounded-lg text-[10px] font-black hover:bg-fennec/20 transition uppercase tracking-wider">INSCRIBE MANIFEST</button>
                                                                    <input id="mintAssetsPickDir" type="file" webkitdirectory directory multiple class="mt-2 w-full text-[11px] text-gray-300" />
                                                                    <button onclick="window.inscribeFennecAssetsAndConfig()" class="mt-2 w-full py-2 bg-fennec/10 text-fennec border border-fennec/30 rounded-lg text-[10px] font-black hover:bg-fennec/20 transition uppercase tracking-wider">INSCRIBE ASSETS + CONFIG</button>
                                                                    <div id="mintRefsStatus" class="mt-2 text-[10px] text-gray-500 text-center font-mono"></div>
                                                                </div>

                                                                <button onclick="window.refreshAudit()" id="refreshAuditBtn" class="mt-3 text-xs text-gray-500 hover:text-white transition flex items-center gap-1 opacity-70">
                                                                    <i class="fas fa-sync-alt" id="refreshAuditIcon"></i> <span id="refreshAuditText">Refresh Metadata</span>
                                                                </button>

                                                            </div>
                                                        `;

                    // Запуск эффекта наклона

                    init3DTilt();

                    try {
                        const libEl = document.getElementById('mintChildLibRef');
                        const cfgEl = document.getElementById('mintChildConfigRef');
                        const manEl = document.getElementById('mintChildManifestRef');
                        const assetsEl = document.getElementById('mintAssetsPickDir');
                        const statusEl = document.getElementById('mintRefsStatus');
                        if (libEl) libEl.value = String(localStorage.getItem('fennec_mint_child_lib') || '').trim();
                        if (cfgEl) cfgEl.value = String(localStorage.getItem('fennec_mint_child_config') || '').trim();
                        if (manEl)
                            manEl.value = String(localStorage.getItem('fennec_mint_child_manifest') || '').trim();
                        if (statusEl) statusEl.textContent = '';
                        if (assetsEl) {
                            assetsEl.onchange = function (e) {
                                try {
                                    const files = e && e.target && e.target.files ? Array.from(e.target.files) : [];
                                    window.__fennecMintAssetsFiles = files;
                                    if (statusEl)
                                        statusEl.textContent = files.length
                                            ? `Assets selected: ${files.length} files`
                                            : '';
                                } catch (err) {}
                            };
                        }
                    } catch (e) {}

                    const mintBtnText = document.getElementById('mintBtnText');
                    if (mintBtnText) {
                        window.__discountCheckPassed = false;
                        mintBtnText.innerHTML = '1 FB';
                    }
                } catch (e) {
                    console.error('renderAudit error:', e);
                }
            }
            function toggleCardFlip(event, sceneEl) {
                const object = sceneEl?.querySelector('.card-object');
                if (!object) return;

                if (object.__flipAnimating) return;

                const willFlip = !object.classList.contains('is-flipped');

                if (object.__tiltState && object.__tiltState.raf) {
                    cancelAnimationFrame(object.__tiltState.raf);
                    object.__tiltState.raf = 0;
                }

                object.__flipAnimating = true;
                const onFlipEnd = e => {
                    if (e && e.propertyName && e.propertyName !== 'transform') return;
                    object.__flipAnimating = false;
                    object.removeEventListener('transitionend', onFlipEnd);
                    if (!object.classList.contains('is-flipped') && object.__tiltStart) {
                        object.__tiltStart();
                    }
                };
                object.addEventListener('transitionend', onFlipEnd);
                setTimeout(() => {
                    if (object.__flipAnimating) {
                        object.__flipAnimating = false;
                        object.removeEventListener('transitionend', onFlipEnd);
                        if (!object.classList.contains('is-flipped') && object.__tiltStart) {
                            object.__tiltStart();
                        }
                    }
                }, 1200);

                // ВАЖНО: 3D-tilt пишет inline style transform.
                // Inline transform перекрывает CSS transform из .card-object.is-flipped, из-за этого back может не открываться.
                // Делаем сброс наклона мгновенным (без transition), а сам flip — по CSS transition, чтобы скорость туда/обратно была одинаковая.
                object.style.removeProperty('transition');
                object.style.setProperty('--tiltX', '0deg');
                object.style.setProperty('--tiltY', '0deg');

                requestAnimationFrame(() => {
                    object.classList.toggle('is-flipped');
                });
            }

            function initVfxWebgl(object) {
                if (!object || object.__vfxWebgl) return;
                const canvas = object.querySelector('.vfx-webgl canvas');
                const wrap = canvas ? canvas.parentElement : null;
                if (!canvas || !wrap) return;

                const gl =
                    canvas.getContext('webgl', { alpha: true, premultipliedAlpha: true, antialias: true }) ||
                    canvas.getContext('experimental-webgl');
                if (!gl) {
                    wrap.style.opacity = '0';
                    return;
                }

                const vertSrc = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.0,1.0); }`;
                const fragSrc = `precision highp float;
                                            varying vec2 vUv;
                                            uniform vec2 uResolution;
                                            uniform vec2 uPointer;
                                            uniform vec2 uTilt;
                                            uniform float uTime;
                                            uniform vec3 uTint1;
                                            uniform vec3 uTint2;
                                            uniform float uStrength;

                                            float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
                                            float noise(vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hash(i); float b=hash(i+vec2(1.0,0.0)); float c=hash(i+vec2(0.0,1.0)); float d=hash(i+vec2(1.0,1.0)); vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
                                            float fbm(vec2 p){ float v=0.0; float a=0.5; for(int i=0;i<4;i++){ v += a*noise(p); p*=2.0; a*=0.5; } return v; }

                                            void main(){
                                                vec2 uv=vUv;
                                                vec2 p=uPointer;
                                                vec2 d=uv-p;
                                                float dist=length(d);
                                                vec2 e=vec2(1.0)/max(uResolution, vec2(1.0));

                                                float h0 = fbm(uv*7.0 + vec2(uTime*0.05, -uTime*0.04));
                                                float hx1 = fbm((uv+vec2(e.x,0.0))*7.0 + vec2(uTime*0.05, -uTime*0.04));
                                                float hx2 = fbm((uv-vec2(e.x,0.0))*7.0 + vec2(uTime*0.05, -uTime*0.04));
                                                float hy1 = fbm((uv+vec2(0.0,e.y))*7.0 + vec2(uTime*0.05, -uTime*0.04));
                                                float hy2 = fbm((uv-vec2(0.0,e.y))*7.0 + vec2(uTime*0.05, -uTime*0.04));
                                                vec2 g = vec2(hx1-hx2, hy1-hy2);
                                                vec3 n = normalize(vec3(-g*16.0, 1.0));

                                                vec3 v = vec3(0.0, 0.0, 1.0);
                                                vec3 l = normalize(vec3(-d*2.7 + uTilt*0.55, 0.65));
                                                float ndl = max(dot(n,l), 0.0);
                                                vec3 h = normalize(l+v);
                                                float spec = pow(max(dot(n,h), 0.0), 36.0);
                                                float fres = pow(1.0 - max(dot(n,v), 0.0), 4.0);

                                                float bands = sin((uv.x*6.0 + uv.y*4.0 + h0*1.4)*6.283 + uTime*0.85 + uTilt.x*0.6);
                                                float t = 0.5 + 0.5*bands;
                                                vec3 tint = mix(uTint1, uTint2, t);

                                                float grain = hash(uv * (uResolution*0.12) + vec2(uTime*0.9, -uTime*0.7));
                                                grain = pow(grain, 14.0) * (0.26 + 1.85*spec);

                                                float streak = exp(-abs(d.x*1.45 + d.y*0.22 + uTilt.y*0.12)*18.0) * exp(-dist*dist*9.0);
                                                float edge = smoothstep(0.0, 0.05, min(min(uv.x, 1.0-uv.x), min(uv.y, 1.0-uv.y)));

                                                float a = uStrength * edge * (spec*1.10 + ndl*0.10 + fres*0.30 + streak*0.22 + grain*0.62);
                                                a = clamp(a, 0.0, 1.0);

                                                vec3 col = tint*(spec*1.25 + fres*0.25 + ndl*0.12) + vec3(1.0)*spec*0.52 + tint*grain*0.9;
                                                col *= (0.55 + 0.45*smoothstep(0.42, 0.0, dist));
                                                gl_FragColor = vec4(col, a);
                                            }`;

                function compile(type, src) {
                    const sh = gl.createShader(type);
                    gl.shaderSource(sh, src);
                    gl.compileShader(sh);
                    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
                        gl.deleteShader(sh);
                        return null;
                    }
                    return sh;
                }

                const vs = compile(gl.VERTEX_SHADER, vertSrc);
                const fs = compile(gl.FRAGMENT_SHADER, fragSrc);
                if (!vs || !fs) {
                    wrap.style.opacity = '0';
                    return;
                }

                const prog = gl.createProgram();
                gl.attachShader(prog, vs);
                gl.attachShader(prog, fs);
                gl.linkProgram(prog);
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                    wrap.style.opacity = '0';
                    return;
                }

                const buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);

                const aPos = gl.getAttribLocation(prog, 'aPos');
                const uResolution = gl.getUniformLocation(prog, 'uResolution');
                const uPointer = gl.getUniformLocation(prog, 'uPointer');
                const uTilt = gl.getUniformLocation(prog, 'uTilt');
                const uTime = gl.getUniformLocation(prog, 'uTime');
                const uTint1 = gl.getUniformLocation(prog, 'uTint1');
                const uTint2 = gl.getUniformLocation(prog, 'uTint2');
                const uStrength = gl.getUniformLocation(prog, 'uStrength');

                const archetype =
                    object.dataset && (object.dataset.vfx || object.dataset.archetype)
                        ? object.dataset.vfx || object.dataset.archetype
                        : '';
                const tier = object.dataset && object.dataset.tier ? Number(object.dataset.tier) || 0 : 0;

                let tint1 = [1, 1, 1];
                let tint2 = [1, 1, 1];
                let mult = 1;
                if (archetype === 'MERCHANT') {
                    tint1 = [1.0, 0.82, 0.15];
                    tint2 = [1.0, 1.0, 1.0];
                    mult = 0.8;
                } else if (archetype === 'KEEPER') {
                    tint1 = [0.98, 0.57, 0.24];
                    tint2 = [1.0, 1.0, 1.0];
                    mult = 0.6;
                } else if (archetype === 'SHAMAN') {
                    tint1 = [0.66, 0.33, 0.97];
                    tint2 = [0.23, 0.51, 0.96];
                } else if (archetype === 'LORD') {
                    tint1 = [0.02, 0.71, 0.83];
                    tint2 = [1.0, 1.0, 1.0];
                } else if (archetype === 'ENGINEER') {
                    tint1 = [0.0, 1.0, 0.67];
                    tint2 = [1.0, 0.0, 0.31];
                    mult = tier === 3 ? 1.26 : 1;
                } else if (archetype === 'WALKER') {
                    tint1 = [0.23, 0.51, 0.96];
                    tint2 = [1.0, 1.0, 1.0];
                } else if (archetype === 'DRIFTER') {
                    tint1 = [1.0, 0.63, 0.0];
                    tint2 = [1.0, 1.0, 1.0];
                } else if (archetype === 'SINGULARITY') {
                    tint1 = [1.0, 1.0, 1.0];
                    tint2 = [0.66, 0.33, 0.97];
                }

                const tierStrength = tier === 1 ? 0.55 : tier === 2 ? 0.78 : 1.0;
                const strength = tierStrength * mult;

                const state = {
                    gl,
                    prog,
                    buf,
                    aPos,
                    uResolution,
                    uPointer,
                    uTilt,
                    uTime,
                    uTint1,
                    uTint2,
                    uStrength,
                    pointer: [0.5, 0.5],
                    tilt: [0, 0],
                    start: performance.now(),
                    lastSize: [0, 0],
                    dpr: Math.min(2, window.devicePixelRatio || 1),
                    tint1,
                    tint2,
                    strength
                };

                object.__vfxWebgl = state;

                state.cssSize = [0, 0];
                const updateSize = () => {
                    const cw = canvas.clientWidth || (wrap ? wrap.clientWidth : 0);
                    const ch = canvas.clientHeight || (wrap ? wrap.clientHeight : 0);
                    state.cssSize[0] = cw;
                    state.cssSize[1] = ch;
                };
                updateSize();
                if (typeof ResizeObserver !== 'undefined') {
                    state.ro = new ResizeObserver(updateSize);
                    try {
                        state.ro.observe(canvas);
                    } catch (e) {}
                }

                function render() {
                    if (!canvas.isConnected) {
                        state.raf = 0;
                        if (state.ro) {
                            try {
                                state.ro.disconnect();
                            } catch (e) {}
                        }
                        return;
                    }
                    const cw = state.cssSize[0] || canvas.clientWidth || 1;
                    const ch = state.cssSize[1] || canvas.clientHeight || 1;
                    const w = Math.max(1, Math.round(cw * state.dpr));
                    const h = Math.max(1, Math.round(ch * state.dpr));
                    if (w !== state.lastSize[0] || h !== state.lastSize[1]) {
                        canvas.width = w;
                        canvas.height = h;
                        state.lastSize[0] = w;
                        state.lastSize[1] = h;
                        gl.viewport(0, 0, w, h);
                    }

                    gl.useProgram(prog);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                    gl.enableVertexAttribArray(aPos);
                    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

                    gl.uniform2f(uResolution, canvas.width, canvas.height);
                    gl.uniform2f(uPointer, state.pointer[0], state.pointer[1]);
                    gl.uniform2f(uTilt, state.tilt[0], state.tilt[1]);
                    gl.uniform1f(uTime, (performance.now() - state.start) / 1000);
                    gl.uniform3f(uTint1, state.tint1[0], state.tint1[1], state.tint1[2]);
                    gl.uniform3f(uTint2, state.tint2[0], state.tint2[1], state.tint2[2]);
                    gl.uniform1f(uStrength, state.strength);

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLES, 0, 3);

                    state.raf = requestAnimationFrame(render);
                }

                state.raf = requestAnimationFrame(render);
            }

            function updateVfxWebgl(object, xNorm, yNorm, tiltX, tiltY) {
                const s = object && object.__vfxWebgl;
                if (!s) return;
                s.pointer[0] = Math.max(0, Math.min(1, xNorm));
                s.pointer[1] = Math.max(0, Math.min(1, yNorm));
                s.tilt[0] = Math.max(-1, Math.min(1, tiltX));
                s.tilt[1] = Math.max(-1, Math.min(1, tiltY));
            }

            // Функция инициализации 3D наклона карточки
            function init3DTilt() {
                const card = document.querySelector('.card-scene');
                const object = document.getElementById('card3D');

                if (!card || !object) return;

                if (window.__fennecTiltCleanup) {
                    try {
                        window.__fennecTiltCleanup();
                    } catch (e) {}
                    window.__fennecTiltCleanup = null;
                }

                initVfxWebgl(object);

                const tier = object.dataset && object.dataset.tier ? Number(object.dataset.tier) || 0 : 0;
                const tiltStrength = tier === 0 ? 4 : tier === 1 ? 7 : tier === 2 ? 10 : 13;
                const idleAmp = tier === 0 ? 2 : tier === 1 ? 3 : tier === 2 ? 4.5 : 6;

                const state = {
                    hover: false,
                    lastMove: 0,
                    targetMxp: 50,
                    targetMyp: 50,
                    mxp: 50,
                    myp: 50,
                    raf: 0,
                    start: performance.now()
                };

                object.__tiltState = state;

                let rect = null;
                let rectAt = 0;
                let movePending = false;
                let lastMoveEvt = null;
                const readRect = () => {
                    rect = card.getBoundingClientRect();
                    rectAt = performance.now();
                };

                function applyPose(mxp, myp) {
                    if (object.__flipAnimating) return;
                    if (object.classList.contains('is-flipped')) return;

                    const nx = (mxp - 50) / 50;
                    const ny = (myp - 50) / 50;
                    object.style.setProperty('--mxp', `${mxp.toFixed(2)}%`);
                    object.style.setProperty('--myp', `${myp.toFixed(2)}%`);
                    object.style.setProperty('--px', `${(nx * 12).toFixed(2)}px`);
                    object.style.setProperty('--py', `${(ny * 12).toFixed(2)}px`);
                    object.style.setProperty('--npx', `${(nx * 5).toFixed(2)}px`);
                    object.style.setProperty('--npy', `${(ny * 5).toFixed(2)}px`);

                    const rx = (-ny * tiltStrength).toFixed(2);
                    const ry = (nx * tiltStrength).toFixed(2);
                    object.style.setProperty('--tiltX', `${rx}deg`);
                    object.style.setProperty('--tiltY', `${ry}deg`);

                    updateVfxWebgl(object, mxp / 100, 1 - myp / 100, nx, -ny);
                }

                function stopRaf() {
                    if (state.raf) {
                        cancelAnimationFrame(state.raf);
                        state.raf = 0;
                    }
                }

                function tick() {
                    if (!state.hover) {
                        state.raf = 0;
                        return;
                    }
                    if (object.__flipAnimating) {
                        state.raf = 0;
                        return;
                    }
                    if (object.classList.contains('is-flipped')) {
                        state.raf = 0;
                        return;
                    }

                    const now = performance.now();
                    const t = (now - state.start) / 1000;
                    const idle = now - state.lastMove > 4000;

                    const desiredMxp = idle ? 50 + Math.sin(t * 0.55) * idleAmp : state.targetMxp;
                    const desiredMyp = idle ? 50 + Math.cos(t * 0.43) * (idleAmp * 0.85) : state.targetMyp;
                    const lerp = idle ? 0.06 : 0.18;
                    state.mxp += (desiredMxp - state.mxp) * lerp;
                    state.myp += (desiredMyp - state.myp) * lerp;

                    applyPose(state.mxp, state.myp);

                    state.raf = requestAnimationFrame(tick);
                }

                object.__tiltStart = () => {
                    if (!state.hover) return;
                    if (state.raf) return;
                    if (object.__flipAnimating) return;
                    if (object.classList.contains('is-flipped')) return;
                    state.raf = requestAnimationFrame(tick);
                };

                const onMouseMove = e => {
                    if (object.__flipAnimating) return;
                    if (object.classList.contains('is-flipped')) return;
                    lastMoveEvt = e;
                    if (movePending) return;
                    movePending = true;
                    requestAnimationFrame(() => {
                        movePending = false;
                        const ev = lastMoveEvt;
                        if (!ev) return;
                        const now = performance.now();
                        if (!rect || now - rectAt > 250) readRect();
                        if (!rect || !rect.width || !rect.height) return;
                        const x = ev.clientX - rect.left;
                        const y = ev.clientY - rect.top;
                        state.targetMxp = Math.max(0, Math.min(100, (x / rect.width) * 100));
                        state.targetMyp = Math.max(0, Math.min(100, (y / rect.height) * 100));
                        state.lastMove = now;
                        if (!state.raf) object.__tiltStart();
                    });
                };

                const onMouseEnter = () => {
                    state.hover = true;
                    state.lastMove = performance.now();
                    readRect();
                    object.style.transition = 'transform 90ms linear';
                    object.__tiltStart();
                };

                const onMouseLeave = () => {
                    state.hover = false;
                    stopRaf();
                    object.style.removeProperty('transition');
                    object.style.setProperty('--tiltX', '0deg');
                    object.style.setProperty('--tiltY', '0deg');
                };

                card.addEventListener('mousemove', onMouseMove);
                card.addEventListener('mouseenter', onMouseEnter);
                card.addEventListener('mouseleave', onMouseLeave);

                window.__fennecTiltCleanup = () => {
                    stopRaf();
                    card.removeEventListener('mousemove', onMouseMove);
                    card.removeEventListener('mouseenter', onMouseEnter);
                    card.removeEventListener('mouseleave', onMouseLeave);
                    if (object.__vfxWebgl) {
                        if (object.__vfxWebgl.ro) {
                            try {
                                object.__vfxWebgl.ro.disconnect();
                            } catch (e) {}
                        }
                        if (object.__vfxWebgl.raf) {
                            cancelAnimationFrame(object.__vfxWebgl.raf);
                        }
                    }
                    object.__vfxWebgl = null;
                };
            }

            // Share Audit
            function shareAudit() {
                if (!auditIdentity) return;
                const text = `I am ${auditIdentity.archetype.title} (${auditIdentity.archetype.tier}) on Fennec Swap!\n\nNet Worth: $${auditIdentity.metrics.wealth}\nAge: ${auditIdentity.metrics.daysAlive} Days\nActivity: ${auditIdentity.metrics.txCount} Transactions\n\n${auditIdentity.archetype.desc}`;

                if (navigator.share) {
                    navigator.share({ text, title: 'Fennec Grand Audit' });
                } else {
                    navigator.clipboard.writeText(text).then(() => {
                        alert('Copied to clipboard!');
                    });
                }
            }

            // ИСПРАВЛЕНИЕ: Отдельное обновление аудита (не сбрасывает карточку без желания пользователя)
            let lastAuditRefreshTime = 0;
            const MIN_AUDIT_REFRESH_INTERVAL = 60000; // 60 секунд между обновлениями аудита
            let auditRefreshTimerInterval = null;

            window.refreshAudit = async function () {
                const now = Date.now();
                const timeSinceLastRefresh = now - lastAuditRefreshTime;

                // Проверяем, прошло ли достаточно времени
                if (timeSinceLastRefresh < MIN_AUDIT_REFRESH_INTERVAL) {
                    const remainingSeconds = Math.ceil((MIN_AUDIT_REFRESH_INTERVAL - timeSinceLastRefresh) / 1000);
                    showNotification(`Please wait ${remainingSeconds}s before refreshing ID again`, 'warning', 2000);
                    return;
                }

                if (!userAddress && !window.userAddress) {
                    showNotification('Connect wallet first', 'warning', 2000);
                    return;
                }

                if (auditLoading) {
                    showNotification('Audit is already loading, please wait', 'warning', 2000);
                    return;
                }

                // Обновляем время последнего обновления
                lastAuditRefreshTime = now;

                // Обновляем UI кнопки
                const refreshAuditBtn = document.getElementById('refreshAuditBtn');
                const refreshAuditIcon = document.getElementById('refreshAuditIcon');
                const refreshAuditText = document.getElementById('refreshAuditText');

                if (refreshAuditBtn) {
                    refreshAuditBtn.disabled = true;
                }
                if (refreshAuditIcon) {
                    refreshAuditIcon.classList.add('fa-spin');
                }
                if (refreshAuditText) {
                    refreshAuditText.textContent = 'UPDATING...';
                }

                try {
                    console.log('🔄 Manual audit refresh started...');
                    await runAudit(true);
                    showNotification('Audit refreshed successfully', 'success', 2000);
                    console.log('✅ Manual audit refresh completed');

                    // Запускаем таймер обратного отсчета
                    startAuditRefreshTimer();
                } catch (e) {
                    console.error('❌ Manual audit refresh error:', e);
                    showNotification('Audit refresh failed: ' + (e.message || 'Unknown error'), 'error', 3000);
                } finally {
                    // Восстанавливаем UI кнопки (но оставляем disabled до окончания таймера)
                    if (refreshAuditIcon) {
                        refreshAuditIcon.classList.remove('fa-spin');
                    }
                    if (refreshAuditText) {
                        refreshAuditText.textContent = 'Refresh Metadata';
                    }
                }
            };

            // Таймер обратного отсчета для кнопки обновления аудита
            function startAuditRefreshTimer() {
                if (auditRefreshTimerInterval) {
                    clearInterval(auditRefreshTimerInterval);
                }

                const refreshAuditTimer = document.getElementById('refreshAuditTimer');
                const refreshAuditBtn = document.getElementById('refreshAuditBtn');

                if (!refreshAuditBtn) return;

                let remainingSeconds = MIN_AUDIT_REFRESH_INTERVAL / 1000;
                refreshAuditBtn.disabled = true;

                if (!refreshAuditTimer) {
                    setTimeout(() => {
                        refreshAuditBtn.disabled = false;
                    }, MIN_AUDIT_REFRESH_INTERVAL);
                    return;
                }

                refreshAuditTimer.classList.remove('hidden');
                refreshAuditTimer.textContent = `(${remainingSeconds}s)`;

                auditRefreshTimerInterval = setInterval(() => {
                    remainingSeconds--;
                    if (remainingSeconds <= 0) {
                        clearInterval(auditRefreshTimerInterval);
                        auditRefreshTimerInterval = null;
                        refreshAuditTimer.classList.add('hidden');
                        refreshAuditBtn.disabled = false;
                    } else {
                        refreshAuditTimer.textContent = `(${remainingSeconds}s)`;
                    }
                }, 1000);
            }

            function generateRecursiveChildHTML(identity, opts) {
                const o = opts && typeof opts === 'object' ? opts : {};
                const libRef = String(o.libRef || MINT_CHILD_FENNEC_LIB || FALLBACK_CHILD_LIB || '').trim();
                const configRef = String(o.configRef || MINT_CHILD_FENNEC_CONFIG || FALLBACK_CHILD_CONFIG || '').trim();
                const manifestRef = String(
                    o.manifestRef || MINT_CHILD_FENNEC_MANIFEST || FALLBACK_MANIFEST_REF || DEFAULT_MANIFEST_URL || ''
                ).trim();
                const parentRef = String(o.parentRef || '').trim();
                const oracleEndpoint = String(o.oracleEndpoint || BACKEND_URL || '').trim();
                const oracleAction = String(o.oracleAction || 'fractal_audit').trim();
                const pubkey = String(o.pubkey || userPubkey || '').trim();

                if (!libRef && !manifestRef) {
                    throw new Error(
                        "Missing mint ref: set localStorage fennec_mint_child_lib (or fennec_mint_child_manifest). Example: localStorage.setItem('fennec_mint_child_lib', '<inscription_id_or_url>')"
                    );
                }
                if (!configRef && !manifestRef) {
                    throw new Error('Missing MINT_CHILD_FENNEC_CONFIG (or MINT_CHILD_FENNEC_MANIFEST)');
                }

                const dna = identity && typeof identity === 'object' ? identity : {};
                const dnaJson = JSON.stringify(dna).replace(/</g, '\\u003c');
                const closeScriptTag = '</scr' + 'ipt>';

                const metaManifest = manifestRef
                    ? `<meta name="fennec-manifest" content="${manifestRef.replace(/"/g, '&quot;')}" />`
                    : '<meta name="fennec-manifest" content="" />';
                const metaParent = parentRef
                    ? `<meta name="fennec-parent" content="${parentRef.replace(/"/g, '&quot;')}" />`
                    : '<meta name="fennec-parent" content="" />';
                const metaOracleEndpoint = oracleEndpoint
                    ? `<meta name="fennec-oracle-endpoint" content="${oracleEndpoint.replace(/"/g, '&quot;')}" />`
                    : '';
                const metaOracleAction = oracleAction
                    ? `<meta name="fennec-oracle-action" content="${oracleAction.replace(/"/g, '&quot;')}" />`
                    : '';
                const metaPubkey = pubkey
                    ? `<meta name="fennec-pubkey" content="${pubkey.replace(/"/g, '&quot;')}" />`
                    : '';

                const html = `<!doctype html>
                                            <html lang="en">
                                              <head>
                                                <meta charset="UTF-8" />
                                                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                                                <meta name="fennec-lib" content="${libRef.replace(/"/g, '&quot;')}" />
                                                <meta name="fennec-config" content="${configRef.replace(/"/g, '&quot;')}" />
                                                ${metaManifest}

        var shouldIgnoreBootError = function (ev) {
          try {
            var m = '';
            var s = '';
            if (ev && typeof ev === 'object') {
              m = String(ev.message || (ev.reason && (ev.reason.message || ev.reason)) || '').toLowerCase();
              s = String(ev.filename || (ev.error && ev.error.fileName) || '').toLowerCase();
            } else {
              m = String(ev || '').toLowerCase();
            }

            if (m.indexOf('metamask') !== -1) return true;
            if (m.indexOf('cannot redefine property: ethereum') !== -1) return true;
            if (m.indexOf('failed to connect to metamask') !== -1) return true;
            if (m.indexOf('ethereum') !== -1 && m.indexOf('defineproperty') !== -1) return true;
            if (m.indexOf('content security policy') !== -1) return true;
            if (m.indexOf('refused to connect') !== -1) return true;
            if (m.indexOf('sandboxed') !== -1 && (m.indexOf('localstorage') !== -1 || m.indexOf('sessionstorage') !== -1)) return true;
            if (m.indexOf('postmessage') !== -1 && m.indexOf("origin ('null')") !== -1) return true;
            if (m.indexOf('accessing a cross-origin frame') !== -1) return true;
            if (m.indexOf('securityerror') !== -1 && m.indexOf('document') !== -1) return true;

            if (s.indexOf('evmask') !== -1) return true;
            if (s.indexOf('inpage.js') !== -1) return true;
            if (s.indexOf('contentscript') !== -1) return true;
            if (s.indexOf('hostname_check') !== -1) return true;
            if (s.indexOf('requests.') !== -1 && s.indexOf('.js') !== -1) return true;
          } catch (_) {}
          return false;
        };

        var NL = String.fromCharCode(10);
                                                      var makeShim = function () {
                                                        var mem = {};
                                                        var api = {
                                                          getItem: function (k) {
                                                            try {
                                                              var kk = String(k);
                                                              return Object.prototype.hasOwnProperty.call(mem, kk) ? String(mem[kk]) : null;
                                                            } catch (_) {
                                                              return null;
                                                            }
                                                          },
                                                          setItem: function (k, v) {
                                                            try {
                                                              mem[String(k)] = String(v);
                                                            } catch (_) {}
                                                          },
                                                          removeItem: function (k) {
                                                            try {
                                                              delete mem[String(k)];
                                                            } catch (_) {}
                                                          },
                                                          clear: function () {
                                                            try {
                                                              mem = {};
                                                            } catch (_) {}
                                                          },
                                                          key: function (i) {
                                                            try {
                                                              var keys = Object.keys(mem);
                                                              return typeof keys[i] === 'string' ? keys[i] : null;
                                                            } catch (_) {
                                                              return null;
                                                            }
                                                          }
                                                        };
                                                        try {
                                                          Object.defineProperty(api, 'length', {
                                                            get: function () {
                                                              try {
                                                                return Object.keys(mem).length;
                                                              } catch (_) {
                                                                return 0;
                                                              }
                                                            }
                                                          });
                                                        } catch (_) {}
                                                        return api;
                                                      };

                                                      var ok = false;
                                                      try {
                                                        var ls = window.localStorage;
                                                        if (ls) {
                                                          var t = '__fennec_ls__' + String(Math.random());
                                                          ls.setItem(t, '1');
                                                          ls.removeItem(t);
                                                          ok = true;
                                                        }
                                                      } catch (_) {
                                                        ok = false;
                                                      }

                                                      if (!ok) {
                                                        try {
                                                          Object.defineProperty(window, 'localStorage', {
                                                            value: makeShim(),
                                                            configurable: true
                                                          });
                                                        } catch (_) {
                                                          try {
                                                            window.localStorage = makeShim();
                                                          } catch (_) {}
                                                        }
                                                      }

                                                      try {
                                                        var ss = window.sessionStorage;
                                                        if (ss) {
                                                          var t2 = '__fennec_ss__' + String(Math.random());
                                                          ss.setItem(t2, '1');
                                                          ss.removeItem(t2);
                                                        }
                                                      } catch (_) {
                                                        try {
                                                          Object.defineProperty(window, 'sessionStorage', {
                                                            value: makeShim(),
                                                            configurable: true
                                                          });
                                                        } catch (_) {
                                                          try {
                                                            window.sessionStorage = makeShim();
                                                          } catch (_) {}
                                                        }
                                                      }
                                                    };

                                                    ensureStorageShim();

                                                    var renderBoot = function (text) {
                                                      try {
                                                        var root = document.getElementById('fennec-root') || document.body;
                                                        var msg = document.getElementById('__fennec_boot_msg');
                                                        if (!msg) {
                                                          msg = document.createElement('div');
                                                          msg.id = '__fennec_boot_msg';
                                                          msg.setAttribute(
                                                            'style',
                                                            'min-height:100vh;display:flex;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:rgba(255,255,255,0.88);background:#060607;padding:24px;box-sizing:border-box;text-align:left;white-space:pre-wrap;line-height:1.35;'
                                                          );
                                                          root.appendChild(msg);
                                                        }
                                                        msg.textContent = String(text || '');
                                                      } catch (e) {}
                                                    };

                                                    var safeErrText = function (err) {
                                                      try {
                                                        if (!err) return '';
                                                        if (typeof err === 'string') return err;
                                                        if (err && typeof err.message === 'string' && err.message) return err.message;
                                                        return String(err);
                                                      } catch (_) {
                                                        return 'Unknown error';
                                                      }
                                                    };

                                                    var shouldIgnoreBootError = function (ev) {
                                                      try {
                                                        var m = '';
                                                        var s = '';
                                                        if (ev && typeof ev === 'object') {
                                                          m = String(ev.message || (ev.reason && (ev.reason.message || ev.reason)) || '').toLowerCase();
                                                          s = String(ev.filename || (ev.error && ev.error.fileName) || '').toLowerCase();
                                                        } else {
                                                          m = String(ev || '').toLowerCase();
                                                        }

                                                        if (m.indexOf('metamask') !== -1) return true;
                                                        if (m.indexOf('cannot redefine property: ethereum') !== -1) return true;
                                                        if (m.indexOf('failed to connect to metamask') !== -1) return true;
                                                        if (m.indexOf('ethereum') !== -1 && m.indexOf('defineproperty') !== -1) return true;
                                                        if (m.indexOf('content security policy') !== -1) return true;
                                                        if (m.indexOf('refused to connect') !== -1) return true;
                                                        if (m.indexOf('sandboxed') !== -1 && (m.indexOf('localstorage') !== -1 || m.indexOf('sessionstorage') !== -1)) return true;
                                                        if (m.indexOf('postmessage') !== -1 && m.indexOf("origin ('null')") !== -1) return true;
                                                        if (m.indexOf('accessing a cross-origin frame') !== -1) return true;
                                                        if (m.indexOf('securityerror') !== -1 && m.indexOf('document') !== -1) return true;

                                                        if (s.indexOf('evmask') !== -1) return true;
                                                        if (s.indexOf('inpage.js') !== -1) return true;
                                                        if (s.indexOf('contentscript') !== -1) return true;
                                                        if (s.indexOf('hostname_check') !== -1) return true;
                                                        if (s.indexOf('requests.') !== -1 && s.indexOf('.js') !== -1) return true;
                                                      } catch (_) {}
                                                      return false;
                                                    };

                                                    var NL = String.fromCharCode(10);

                                                    try {
                                                      window.addEventListener(
                                                        'error',
                                                        function (ev) {
                                                          try {
                                                            if (shouldIgnoreBootError(ev)) return;
                                                            var msg = (ev && (ev.message || (ev.error && ev.error.message))) || 'Script error';
                                                            renderBoot('Fennec ID crashed:' + NL + String(msg || ''));
                                                          } catch (_) {}
                                                        },
                                                        true
                                                      );
                                                    } catch (_) {}

                                                    try {
                                                      window.addEventListener(
                                                        'unhandledrejection',
                                                        function (ev) {
                                                          try {
                                                            if (shouldIgnoreBootError(ev)) return;
                                                            renderBoot('Fennec ID crashed (promise):' + NL + safeErrText(ev && ev.reason));
                                                          } catch (_) {}
                                                        },
                                                        true
                                                      );
                                                    } catch (_) {}

                                                    renderBoot('Loading Fennec ID…');

                                                    var inferContentBase = function () {
                                                      var m = String(getMeta('fennec-content-base') || '').trim();
                                                      if (m) return m;
                                                      try {
                                                        var h = (window.location && window.location.hostname ? String(window.location.hostname) : '').toLowerCase();
                                                        var o = window.location && typeof window.location.origin === 'string' ? String(window.location.origin) : '';
                                                        var p = window.location && window.location.pathname ? String(window.location.pathname) : '';
                                                        if (!o || o === 'null') return 'https://uniscan.cc/fractal/content/';

                                                        // UniSat static hosts may serve inscription content under /content/ (not /fractal/content/)
                                                        if (h.indexOf('fractal-static.unisat.') === 0 && p.indexOf('/fractal/content/') !== -1) {
                                                          return o + '/content/';
                                                        }

                                                        if (p.indexOf('/fractal/content/') !== -1) return o + '/fractal/content/';
                                                        if (p.indexOf('/content/') !== -1) return o + '/content/';

                                                        if (h === 'uniscan.cc' || h.slice(-10) === '.uniscan.cc') return o + '/fractal/content/';
                                                      } catch (e) {}
                                                      return '';
                                                    };

                                                    var contentBase = inferContentBase();
                                                    if (contentBase) setMeta('fennec-content-base', contentBase);

                                                    var looksLikeInscriptionId = function (ref) {
                                                      try {
                                                        var s = String(ref || '').trim();
                                                        if (!s) return false;
                                                        if (s.indexOf('/') !== -1 || s.indexOf(':') !== -1 || s.indexOf('?') !== -1 || s.indexOf('#') !== -1)
                                                          return false;
                                                        if (s.length < 16) return false;
                                                        return /i\d+$/i.test(s);
                                                      } catch (_) {
                                                        return false;
                                                      }
                                                    };

                                                    var proxyUrlForId = function (id) {
                                                      try {
                                                        var h = (window.location && window.location.hostname ? String(window.location.hostname) : '').toLowerCase();
                                                        // Disable proxy on UniScan/Unisat to avoid CSP blocks
                                                        if (h.indexOf('uniscan') !== -1 || h.indexOf('unisat') !== -1) return '';

                                                        var ep = String(getMeta('fennec-oracle-endpoint') || '').trim();
                                                        if (!ep) return '';
                                                        var sep = ep.indexOf('?') === -1 ? '?' : '&';
                                                        return ep + sep + 'action=inscription_content&raw=1&inscriptionId=' + encodeURIComponent(String(id || ''));
                                                      } catch (_) {
                                                        return '';
                                                      }
                                                    };

                                                    var resolveRefToUrl = function (ref) {
                                                      var s = String(ref || '').trim();
                                                      if (!s) return '';

                                                      if (looksLikeInscriptionId(s)) {
                                                        var p0 = proxyUrlForId(s);
                                                        if (p0) return p0;
                                                      }

                                                      if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0) {
                                                        try {
                                                          if (
                                                            (s.indexOf('fractal-static.unisat.space') !== -1 ||
                                                              s.indexOf('fractal-static.unisat.io') !== -1) &&
                                                            (s.indexOf('/content/') !== -1 || s.indexOf('/fractal/content/') !== -1) &&
                                                            typeof rewriteContentUrl === 'function'
                                                          ) {
                                                            return rewriteContentUrl(s);
                                                          }
                                                        } catch (_) {}
                                                        return s;
                                                      }

                                                      if (s.indexOf('/') === 0) {
                                                        try {
                                                          if (typeof rewriteContentUrl === 'function') return rewriteContentUrl(s);
                                                        } catch (_) {}
                                                        return s;
                                                      }

                                                      var base = String(getMeta('fennec-content-base') || '').trim();
                                                      if (base) {
                                                        while (base.length && base.charAt(base.length - 1) === '/') base = base.slice(0, -1);
                                                        var u0 = base + '/' + s;
                                                        try {
                                                          if (typeof rewriteContentUrl === 'function') return rewriteContentUrl(u0);
                                                        } catch (_) {}
                                                        return u0;
                                                      }

                                                      var fallback = '/content/' + s;
                                                      try {
                                                        if (typeof rewriteContentUrl === 'function') return rewriteContentUrl(fallback);
                                                      } catch (_) {}
                                                      return fallback;
                                                    };

                                                    var extractContentId = function (url) {
                                                      try {
                                                        var s = String(url || '').trim();
                                                        if (!s) return '';
                                                        var i = s.indexOf('/content/');
                                                        if (i !== -1) {
                                                          var tail = s.slice(i + '/content/'.length);
                                                          if (tail) tail = tail.split(/[?#/]/)[0];
                                                          return tail || '';
                                                        }
                                                        var j = s.indexOf('/fractal/content/');
                                                        if (j !== -1) {
                                                          var tail2 = s.slice(j + '/fractal/content/'.length);
                                                          if (tail2) tail2 = tail2.split(/[?#/]/)[0];
                                                          return tail2 || '';
                                                        }
                                                      } catch (_) {}
                                                      return '';
                                                    };

                                                    var rewriteContentUrl = function (u) {
                                                      try {
                                                        var s = String(u || '').trim();
                                                        if (!s) return u;
                                                        if (s.indexOf('action=inscription_content') !== -1) return s;

                                                        var base = String(getMeta('fennec-content-base') || '').trim();
                                                        while (base.length && base.charAt(base.length - 1) === '/') base = base.slice(0, -1);

                                                        var id = '';
                                                        if (s.indexOf('fractal-static.unisat.space') !== -1) id = extractContentId(s);
                                                        if (!id && s.indexOf('fractal-static.unisat.io') !== -1) id = extractContentId(s);
                                                        if (!id && s.indexOf('uniscan.cc') !== -1) id = extractContentId(s);
                                                        if (!id && s.indexOf('/content/') === 0) id = extractContentId(s);
                                                        if (!id && s.indexOf('/fractal/content/') === 0) id = extractContentId(s);

                                                        if (id) {
                                                          var p = proxyUrlForId(id);
                                                          if (p) return p;
                                                          return (base ? base + '/' : 'https://uniscan.cc/fractal/content/') + id;
                                                        }

                                                        if (looksLikeInscriptionId(s)) {
                                                          var p2 = proxyUrlForId(s);
                                                          if (p2) return p2;
                                                          if (base) return base + '/' + s;
                                                          return 'https://uniscan.cc/fractal/content/' + s;
                                                        }
                                                      } catch (_) {}
                                                      return u;
                                                    };

                                                    try {
                                                      if (window.fetch) {
                                                        var __fennecFetch0 = window.fetch;
                                                        window.fetch = function (input, init) {
                                                          try {
                                                            if (typeof input === 'string') {
                                                              input = rewriteContentUrl(input);
                                                            } else if (input && typeof input.url === 'string') {
                                                              var nu = rewriteContentUrl(input.url);
                                                              if (nu && nu !== input.url) input = new Request(nu, input);
                                                            }
                                                          } catch (_) {}
                                                          return __fennecFetch0(input, init);
                                                        };
                                                      }
                                                    } catch (_) {}

                                                    try {
                                                      if (window.XMLHttpRequest && window.XMLHttpRequest.prototype && window.XMLHttpRequest.prototype.open) {
                                                        var __fennecXhrOpen0 = window.XMLHttpRequest.prototype.open;
                                                        window.XMLHttpRequest.prototype.open = function (method, url) {
                                                          try {
                                                            arguments[1] = rewriteContentUrl(url);
                                                          } catch (_) {}
                                                          return __fennecXhrOpen0.apply(this, arguments);
                                                        };
                                                      }
                                                    } catch (_) {}

                                                    var fetchJsonWithTimeout = function (url, timeoutMs) {
                                                      var ms = typeof timeoutMs === 'number' ? timeoutMs : 4500;
                                                      return new Promise(function (resolve, reject) {
                                                        var done = false;
                                                        var t = setTimeout(function () {
                                                          if (done) return;
                                                          done = true;
                                                          reject(new Error('timeout'));
                                                        }, ms);
                                                        fetch(url, { cache: 'no-store' })
                                                          .then(function (res) {
                                                            if (!res.ok) throw new Error('http ' + res.status);
                                                            return res.json();
                                                          })
                                                          .then(function (json) {
                                                            if (done) return;
                                                            done = true;
                                                            clearTimeout(t);
                                                            resolve(json);
                                                          })
                                                          .catch(function (err) {
                                                            if (done) return;
                                                            done = true;
                                                            clearTimeout(t);
                                                            reject(err);
                                                          });
                                                      });
                                                    };

                                                    var pinnedLib = getMeta('fennec-lib');
                                                    var pinnedConfig = getMeta('fennec-config');
                                                    var manifestRef = getMeta('fennec-manifest');

                                                    var fallbackManifestId = '8593e591de03ecbdd041121ee76256c22e51eaf670bfa0887358c6d3d50ad5ddi0';

                                                    var resolved = {
                                                      lib: pinnedLib,
                                                      config: pinnedConfig
                                                    };

                                                    var applyManifest = function (m) {
                                                      if (!m || typeof m !== 'object') return;
                                                      var latest = m.latest && typeof m.latest === 'object' ? m.latest : m;
                                                      var lib = latest.lib || latest.libId || latest.library || latest.libraryId || latest.fennecLib || '';
                                                      var cfg =
                                                        latest.config ||
                                                        latest.configId ||
                                                        latest.configuration ||
                                                        latest.configurationId ||
                                                        latest.fennecConfig ||
                                                        '';
                                                      if (typeof lib === 'string' && lib.trim()) resolved.lib = lib.trim();
                                                      if (typeof cfg === 'string' && cfg.trim()) resolved.config = cfg.trim();
                                                    };

                                                    var loadLib = function () {
                                                      if (!resolved.lib) {
                                                        renderBoot('Missing fennec-lib meta');
                                                        return;
                                                      }
                                                      if (resolved.config) setMeta('fennec-config', resolved.config);

                                                      var s = document.createElement('script');
                                                      s.src = resolveRefToUrl(resolved.lib);
                                                      s.onload = function () {
                                                        if (typeof window.initFennecID !== 'function') {
                                                          renderBoot('Fennec ID loaded, but initFennecID() not found');
                                                          return;
                                                        }
                                                        try {
                                                          var r = window.initFennecID();
                                                          if (r && typeof r.then === 'function') {
                                                            r.then(function () {
                                                              try {
                                                                var msg = document.getElementById('__fennec_boot_msg');
                                                                if (msg) msg.remove();
                                                              } catch (e) {}
                                                            }).catch(function (e) {
                                                              renderBoot('initFennecID() failed:' + NL + safeErrText(e));
                                                            });
                                                          } else {
                                                            try {
                                                              var msg2 = document.getElementById('__fennec_boot_msg');
                                                              if (msg2) msg2.remove();
                                                            } catch (e2) {}
                                                          }
                                                        } catch (e3) {
                                                          renderBoot('initFennecID() crashed:' + NL + safeErrText(e3));
                                                        }
                                                      };
                                                      s.onerror = function () {
                                                        try {
                                                          if (!window.__fennecLibRetry && resolved && resolved.lib) {
                                                            window.__fennecLibRetry = 1;
                                                            var retryBase = 'https://uniscan.cc/fractal/content/';
                                                            try {
                                                                var h = window.location.hostname.toLowerCase();
                                                                if (h.indexOf('uniscan') !== -1 || h.indexOf('unisat') !== -1) {
                                                                    retryBase = '/fractal/content/';
                                                                }
                                                            } catch (_) {}

                                                            setMeta('fennec-content-base', retryBase);
                                                            var s2 = document.createElement('script');
                                                            s2.src = retryBase + String(resolved.lib || '').trim();
                                                            s2.onload = function () {
                                                              if (typeof window.initFennecID !== 'function') {
                                                                renderBoot('Fennec ID loaded, but initFennecID() not found');
                                                                return;
                                                              }
                                                              try {
                                                                var r2 = window.initFennecID();
                                                                if (r2 && typeof r2.then === 'function') {
                                                                  r2.then(function () {
                                                                    try {
                                                                      var msg = document.getElementById('__fennec_boot_msg');
                                                                      if (msg) msg.remove();
                                                                    } catch (e) {}
                                                                  }).catch(function (e) {
                                                                    renderBoot('initFennecID() failed:' + NL + safeErrText(e));
                                                                  });
                                                                } else {
                                                                  try {
                                                                    var msg2 = document.getElementById('__fennec_boot_msg');
                                                                    if (msg2) msg2.remove();
                                                                  } catch (e2) {}
                                                                }
                                                              } catch (e3) {
                                                                renderBoot('initFennecID() crashed:' + NL + safeErrText(e3));
                                                              }
                                                            };
                                                            s2.onerror = function () {
                                                              renderBoot('Failed to load Fennec ID library' + NL + 'Tried: ' + String(s2.src || ''));
                                                            };
                                                            document.head.appendChild(s2);
                                                            return;
                                                          }
                                                        } catch (e) {}
                                                        renderBoot('Failed to load Fennec ID library' + NL + 'Tried: ' + String(s.src || ''));
                                                      };
                                                      document.head.appendChild(s);
                                                    };

                                                    if (manifestRef && String(manifestRef).trim()) {
                                                      var manifestUrl = resolveRefToUrl(manifestRef);
                                                      fetchJsonWithTimeout(manifestUrl, 4500)
                                                        .then(function (m) {
                                                          applyManifest(m);
                                                          loadLib();
                                                        })
                                                        .catch(function () {
                                                          // Fallback to local/inscription manifest if external fails (e.g. CSP)
                                                          if (fallbackManifestId && fallbackManifestId !== manifestRef && typeof resolveRefToUrl === 'function') {
                                                            var fbUrl = resolveRefToUrl(fallbackManifestId);
                                                            fetchJsonWithTimeout(fbUrl, 4500)
                                                                .then(function (m2) {
                                                                  applyManifest(m2);
                                                                  loadLib();
                                                                })
                                                                .catch(function () {
                                                                  loadLib();
                                                                });
                                                          } else {
                                                            loadLib();
                                                          }
                                                        });
                                                    } else {
                                                      loadLib();
                                                    }
                                                  })();
                                                ${closeScriptTag}
                                              </body>
                                            </html>`;
                return html;
            }

            async function generateInteractiveHTML(identity, bgImageUrl) {
                const getOptimizedBase64 = async (url, opts) => {
                    try {
                        const o = opts && typeof opts === 'object' ? opts : {};
                        let imageUrl = url;
                        if (url.startsWith('img/')) {
                            imageUrl = new URL(url, window.location.origin).href;
                        }
                        const data = await fetch(imageUrl);
                        if (!data.ok) throw new Error(`Failed to fetch: ${data.status}`);
                        const blob = await data.blob();
                        return new Promise(resolve => {
                            const img = new Image();
                            let objUrl = null;
                            const cleanupUrl = () => {
                                if (!objUrl) return;
                                try {
                                    URL.revokeObjectURL(objUrl);
                                } catch (e) {}
                                objUrl = null;
                            };
                            img.onerror = () => {
                                cleanupUrl();
                                resolve(
                                    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA=='
                                );
                            };
                            img.onload = () => {
                                try {
                                    const canvas = document.createElement('canvas');
                                    const isBadge = typeof o.isBadge === 'boolean' ? o.isBadge : /badge/i.test(url);
                                    const maxW = Number(o.maxWidth || 0) || (isBadge ? 56 : 360);
                                    const maxH = Number(o.maxHeight || 0) || (isBadge ? 56 : 560);
                                    let w = img.width,
                                        h = img.height;
                                    if (w > maxW || h > maxH) {
                                        const r = Math.min(maxW / w, maxH / h);
                                        w = Math.floor(w * r);
                                        h = Math.floor(h * r);
                                    }
                                    canvas.width = w;
                                    canvas.height = h;
                                    const ctx = canvas.getContext('2d');
                                    ctx.imageSmoothingEnabled = true;
                                    ctx.imageSmoothingQuality = 'high';
                                    ctx.drawImage(img, 0, 0, w, h);
                                    const mimeType =
                                        typeof o.mimeType === 'string' && o.mimeType
                                            ? o.mimeType
                                            : isBadge
                                              ? 'image/png'
                                              : 'image/jpeg';
                                    const q =
                                        typeof o.quality === 'number'
                                            ? o.quality
                                            : mimeType === 'image/jpeg'
                                              ? 0.7
                                              : undefined;
                                    resolve(
                                        typeof q === 'number'
                                            ? canvas.toDataURL(mimeType, q)
                                            : canvas.toDataURL(mimeType)
                                    );
                                } catch (e) {
                                    resolve(
                                        'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA=='
                                    );
                                } finally {
                                    cleanupUrl();
                                }
                            };
                            objUrl = URL.createObjectURL(blob);
                            img.src = objUrl;
                        });
                    } catch (e) {
                        return 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA==';
                    }
                };

                let bgBase64;
                try {
                    bgBase64 = await getOptimizedBase64(bgImageUrl);
                } catch (e) {
                    bgBase64 =
                        'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA==';
                }

                const { archetype, metrics } = identity;
                const k = archetype.baseKey || 'DRIFTER';
                const tier = archetype.tierLevel || 0;
                const visualKey = k;
                const vfxKey = visualKey;

                let phavData = 'img/phav.png';
                let symData = 'img/FBSYM.png';
                try {
                    phavData = await getOptimizedBase64('img/phav.png', {
                        maxWidth: 64,
                        maxHeight: 64,
                        mimeType: 'image/png',
                        quality: 0.92
                    });
                } catch (e) {}
                try {
                    symData = await getOptimizedBase64('img/FBSYM.png', {
                        maxWidth: 256,
                        maxHeight: 256,
                        mimeType: 'image/png',
                        quality: 0.92
                    });
                } catch (e) {}

                const badgeImgCache = new Map();
                for (const badge of archetype.badges || []) {
                    if (badge.img && !badgeImgCache.has(badge.img)) {
                        try {
                            const opt = await getOptimizedBase64(badge.img);
                            badgeImgCache.set(badge.img, opt);
                            badge.img = opt;
                        } catch (e) {}
                    }
                }

                const rarityName = metrics.rarity?.name || metrics.rarityName || 'CUB';

                const rarityClassMap = {
                    SPIRIT: 'card-spirit',
                    ELDER: 'card-elder',
                    ALPHA: 'card-alpha',
                    HUNTER: 'card-hunter',
                    SCOUT: 'card-scout',
                    CUB: 'card-cub'
                };
                const rarityClass = metrics.rarity?.class || rarityClassMap[rarityName] || 'card-cub';
                let rarityTextClass = 'text-cub';
                if (rarityName === 'SPIRIT') rarityTextClass = 'text-spirit';
                else if (rarityName === 'ELDER') rarityTextClass = 'text-elder';
                else if (rarityName === 'ALPHA') rarityTextClass = 'text-alpha';
                else if (rarityName === 'HUNTER') rarityTextClass = 'text-hunter';
                else if (rarityName === 'SCOUT') rarityTextClass = 'text-scout';

                const isSpirit = rarityName === 'SPIRIT';
                const borderColorForFace = isSpirit
                    ? 'transparent'
                    : rarityName === 'ELDER'
                      ? '#eab308'
                      : rarityName === 'ALPHA'
                        ? '#ef4444'
                        : rarityName === 'HUNTER'
                          ? '#3b82f6'
                          : rarityName === 'SCOUT'
                            ? '#22c55e'
                            : '#555';
                const borderStyleForFace = '';

                const imgClass = getAnimationClass(vfxKey, tier);

                let overlayHtml = '',
                    vfx3dHtml = '',
                    vfxWebglHtml = '';
                if (tier >= 1 && vfxKey === 'ENGINEER') {
                    const vfxOp = tier === 1 ? 0.18 : tier === 2 ? 0.34 : 0.64;
                    vfx3dHtml = `<div class="vfx-3d" style="--vfx3d-opacity:${vfxOp};"></div>`;
                    const vfxWebglOp = tier === 1 ? 0.12 : tier === 2 ? 0.18 : 0.32;
                    vfxWebglHtml = `<div class="vfx-webgl" style="--vfxwebgl-opacity:${vfxWebglOp};"><canvas></canvas></div>`;
                }
                if (tier === 3)
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;"></div>${vfxWebglHtml}${vfx3dHtml}`;
                else if (tier === 2)
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;opacity:0.30;"></div>${vfxWebglHtml}${vfx3dHtml}`;
                else if (tier === 1)
                    overlayHtml = `<div class="overlay-${vfxKey}" style="position:absolute;inset:0;opacity:0.18;"></div>${vfxWebglHtml}${vfx3dHtml}`;

                const titleClass = `text-tier-${tier}`;
                const rankBadgeClass = `rank-badge rank-badge-${tier}`;
                const tierLabelText = archetype.tierLabel || archetype.tier || '';
                const lastApiData = window.lastAuditApiData || {};
                const inscriptionStatsForDisplay = {
                    runes: Number(metrics.inscriptionStats?.runes ?? lastApiData.runes_count ?? 0) || 0,
                    brc20: Number(metrics.inscriptionStats?.brc20 ?? lastApiData.brc20_count ?? 0) || 0,
                    ordinals: Number(metrics.inscriptionStats?.ordinals ?? lastApiData.ordinals_count ?? 0) || 0,
                    total:
                        Number(metrics.inscriptionStats?.total ?? 0) ||
                        (Number(metrics.inscriptionStats?.brc20 ?? lastApiData.brc20_count ?? 0) || 0) +
                            (Number(metrics.inscriptionStats?.runes ?? lastApiData.runes_count ?? 0) || 0) +
                            (Number(metrics.inscriptionStats?.ordinals ?? lastApiData.ordinals_count ?? 0) || 0)
                };

                const badgesFront = archetype.badges
                    .slice(0, 8)
                    .map(b => {
                        const glow =
                            'drop-shadow(0 0 14px rgba(255,107,53,0.85)) drop-shadow(0 0 22px rgba(255,255,255,0.22)) drop-shadow(0 0 40px rgba(168,85,247,0.16))';
                        const tip = b.desc ? `${b.name} — ${b.desc}` : b.name;
                        const content = b.img
                            ? `<img src="${b.img}" style="width:100%;height:100%;object-fit:contain;filter:${glow}" onerror="this.style.display='none';this.nextElementSibling.style.display='block'"><span style="display:none;font-size:12px;filter:${glow}">${b.icon || ''}</span>`
                            : `<span style="font-size:12px;filter:${glow}">${b.icon || ''}</span>`;
                        return `<div class="badge-medal" style="width:clamp(26px,6.0vw,32px);height:clamp(26px,6.0vw,32px);" title="${tip}">${content}</div>`;
                    })
                    .join('');

                const earnedBadgeNames = new Set((archetype.badges || []).map(b => b.name));
                const allPossibleBadges = [
                    {
                        name: 'GENESIS',
                        icon: '💎',
                        img: 'img/badge_genesis.png',
                        desc: 'You witnessed the first sunrise over the Fractal dunes.'
                    },
                    {
                        name: 'WHALE',
                        icon: '🐋',
                        img: 'img/badge_whale.png',
                        desc: 'When you move, the sands shift beneath you.'
                    },
                    {
                        name: 'PROVIDER',
                        icon: '💧',
                        img: 'img/badge_provider.png',
                        desc: 'The desert is thirsty, but your well runs deep.'
                    },
                    {
                        name: 'FENNEC MAXI',
                        icon: '🔥',
                        img: 'img/badge_maxi.png',
                        desc: 'The Spirit of the Fox guides your path.'
                    },
                    {
                        name: 'ARTIFACT HUNTER',
                        icon: '🏺',
                        img: 'img/badge_collector.png',
                        desc: 'Your pockets are heavy with echoes of the chain.'
                    },
                    {
                        name: 'RUNE KEEPER',
                        icon: '🧿',
                        img: 'img/badge_rune.png',
                        desc: 'You decipher the glyphs. The stones speak to you.'
                    },
                    {
                        name: 'MEMPOOL RIDER',
                        icon: '⚡',
                        img: 'img/badge_mempool_rider.png',
                        desc: 'Surfing the chaos of the 30-second block waves.'
                    },
                    {
                        name: 'SAND SWEEPER',
                        icon: '🧹',
                        img: 'img/badge_sweeper.png',
                        desc: 'Your UTXO set is clean. No trash left in the dunes.'
                    }
                ];
                for (const b of allPossibleBadges) {
                    if (!b.img) continue;
                    try {
                        if (badgeImgCache.has(b.img)) {
                            b.img = badgeImgCache.get(b.img);
                            continue;
                        }
                        const opt = await getOptimizedBase64(b.img);
                        badgeImgCache.set(b.img, opt);
                        b.img = opt;
                    } catch (e) {}
                }
                const earnedBadges = allPossibleBadges.filter(b => earnedBadgeNames.has(b.name));
                const lockedBadges = allPossibleBadges.filter(b => !earnedBadgeNames.has(b.name));
                const badgesBack = [...earnedBadges, ...lockedBadges]
                    .map(b => {
                        const has = earnedBadgeNames.has(b.name);
                        const iOp = has ? '1' : '0.22',
                            nOp = has ? '1' : '0.78',
                            dOp = has ? '0.7' : '0.55',
                            bOp = has ? '0.18' : '0.10',
                            bgOp = has ? '0.06' : '0.035';
                        const glow = has
                            ? 'drop-shadow(0 0 10px rgba(255,107,53,0.28)) drop-shadow(0 0 18px rgba(255,255,255,0.12))'
                            : 'drop-shadow(0 0 6px rgba(255,255,255,0.10))';
                        const iHtml = b.img
                            ? `<img src="${b.img}" style="width:100%;height:100%;object-fit:contain;filter:${glow}" onerror="this.style.display='none';this.nextElementSibling.style.display='block'"><span style="display:none;font-size:12px;filter:${glow}">${b.icon || ''}</span>`
                            : `<span style="font-size:12px;filter:${glow}">${b.icon || ''}</span>`;
                        return `<div title="${b.name} — ${b.desc}" style="display:flex;align-items:flex-start;gap:10px;background:rgba(255,255,255,${bgOp});border:1px solid rgba(255,255,255,${bOp});padding:10px 12px;border-radius:14px;width:100%;min-width:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.25)"><div style="width:clamp(32px,6.8vw,40px);height:clamp(32px,6.8vw,40px);display:flex;align-items:center;justify-content:center;flex-shrink:0;opacity:${iOp};border-radius:10px;background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.12);overflow:hidden;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.25)">${iHtml}</div><div style="text-align:left;min-width:0;flex:1"><div style="font-size:13px;font-weight:950;color:rgba(255,255,255,${nOp});text-transform:uppercase;letter-spacing:0.10em;line-height:1.1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${b.name}</div><div style="margin-top:4px;font-size:13px;line-height:1.25;color:rgba(229,231,235,${dOp})">${b.desc || ''}</div></div></div>`;
                    })
                    .join('');

                // ИСПРАВЛЕНИЕ: Полный CSS с радужной рамкой для SPIRIT, пульсацией для SOUL и всеми эффектами
                const spiritBorder =
                    `.bg-img{object-position:center top}.tier-class{background:rgba(0,0,0,0.35);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.10);padding:6px 10px;border-radius:10px;display:inline-block}.anim-WALKER{animation:walker-shift 6s ease-in-out infinite !important}@keyframes walker-shift{0%,100%{filter:contrast(1.15) brightness(1.05) hue-rotate(0deg)}50%{filter:contrast(1.25) brightness(1.15) hue-rotate(12deg)}}` +
                    (isSpirit
                        ? `.card-object.card-spirit{position:relative;overflow:visible}.card-object.card-spirit::before{content:'';position:absolute;inset:-4px;border-radius:20px;padding:4px;background:conic-gradient(from 0deg,#ff0000,#ff7f00,#ffff00,#00ff00,#00ffff,#0000ff,#4b0082,#9400d3,#ff0000);-webkit-mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);-webkit-mask-composite:xor;mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);mask-composite:exclude;z-index:60;pointer-events:none;filter:brightness(1.65) saturate(1.25) hue-rotate(0deg) drop-shadow(0 0 16px rgba(255,255,255,0.35));animation:spiritBorderPulse 6s linear infinite;overflow:visible}.card-object.card-spirit .face{position:relative;z-index:2;box-shadow:0 0 20px rgba(255,0,0,0.5),0 0 30px rgba(255,127,0,0.4),0 0 40px rgba(255,255,0,0.3),0 0 50px rgba(0,255,0,0.3),0 0 40px rgba(0,255,255,0.3),0 0 30px rgba(0,0,255,0.4),0 0 20px rgba(75,0,130,0.5),0 0 10px rgba(148,0,211,0.6)}@keyframes spiritBorderPulse{0%{filter:brightness(1.65) saturate(1.25) hue-rotate(0deg) drop-shadow(0 0 16px rgba(255,255,255,0.35))}100%{filter:brightness(1.65) saturate(1.25) hue-rotate(360deg) drop-shadow(0 0 16px rgba(255,255,255,0.35))}}`
                        : '');
                const pulseAnimation =
                    (metrics.hasFennecSoul
                        ? `@keyframes soulBreath{0%{box-shadow:0 0 15px rgba(255,107,53,0.4),0 0 25px rgba(255,107,53,0.3)}50%{box-shadow:0 0 30px rgba(255,107,53,0.7),0 0 50px rgba(255,107,53,0.5),0 0 70px rgba(255,107,53,0.3)}100%{box-shadow:0 0 15px rgba(255,107,53,0.4),0 0 25px rgba(255,107,53,0.3)}}.fennec-pulse{animation:soulBreath 2s infinite ease-in-out !important;position:relative;z-index:10}`
                        : '') +
                    `.card-object.card-spirit::before{inset:0 !important;border-radius:20px !important;overflow:visible !important;animation:spiritBorderPulse 4.2s linear infinite !important}`;

                const borderColor =
                    metrics.rarityColor && metrics.rarityColor.includes('yellow')
                        ? '#eab308'
                        : metrics.rarityColor && metrics.rarityColor.includes('purple')
                          ? '#a855f7'
                          : '#555';
                const rarityColorText =
                    rarityName === 'SPIRIT'
                        ? '#ff6b35'
                        : rarityName === 'ELDER'
                          ? '#a855f7'
                          : rarityName === 'ALPHA'
                            ? '#ef4444'
                            : rarityName === 'HUNTER'
                              ? '#f59e0b'
                              : rarityName === 'SCOUT'
                                ? '#3b82f6'
                                : '#9ca3af';

                // ИСПРАВЛЕНИЕ: Добавляем CSS анимации для прогрессивной визуальной эволюции
                const imageEvolutionCSS = `.card-face img{transition:all 0.8s cubic-bezier(0.4,0,0.2,1);will-change:transform,filter}.img-tier-0{filter:grayscale(0.5) sepia(0.2) contrast(0.9) brightness(0.9);transform:scale(1)}.anim-tier-1{animation:breathe 6s ease-in-out infinite alternate}@keyframes breathe{0%{filter:grayscale(0.1) contrast(1) brightness(1);transform:scale(1)}100%{filter:grayscale(0) contrast(1.05) brightness(1.05);transform:scale(1.02)}}.anim-tier-2-heat{animation:heat-low 5s infinite alternate}@keyframes heat-low{0%{filter:sepia(0.1) contrast(1.1);transform:scale(1.02)}100%{filter:sepia(0.3) contrast(1.2);transform:scale(1.04)}}.anim-tier-2-shine{animation:shine-low 4s infinite alternate}@keyframes shine-low{0%{filter:brightness(1) saturate(1.1)}100%{filter:brightness(1.2) saturate(1.2)}}.anim-tier-2-glitch{animation:glitch-low 3s infinite}@keyframes glitch-low{0%,95%{filter:contrast(1.1) hue-rotate(0deg);transform:translate(0,0) scale(1.02)}96%{filter:contrast(1.3) hue-rotate(5deg);transform:translate(1px,0) scale(1.02)}100%{filter:contrast(1.1) hue-rotate(0deg);transform:translate(0,0) scale(1.02)}}.anim-tier-2-magic{animation:magic-low 4s infinite alternate}@keyframes magic-low{0%{filter:hue-rotate(0deg) saturate(1.1)}100%{filter:hue-rotate(-10deg) saturate(1.3)}}.anim-DRIFTER{animation:drifter-heat 8s ease-in-out infinite alternate}.overlay-DRIFTER{background:linear-gradient(to bottom,rgba(255,160,0,0.1),transparent 80%);mix-blend-mode:overlay;animation:sand-drift 10s linear infinite;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes drifter-heat{0%{filter:sepia(0.4) contrast(1.1) brightness(1);transform:scale(1)}50%{filter:sepia(0.6) contrast(1) brightness(1.1) blur(0.5px);transform:scale(1.05)}100%{filter:sepia(0.4) contrast(1.1) brightness(1);transform:scale(1)}}@keyframes sand-drift{0%{transform:translateY(0);opacity:0.3}100%{transform:translateY(-20px);opacity:0.6}}.anim-MERCHANT{animation:merchant-shine 5s ease-in-out infinite}.overlay-MERCHANT{background:linear-gradient(120deg,transparent 30%,rgba(255,215,0,0.4) 50%,transparent 70%);background-size:200% 200%;mix-blend-mode:color-dodge;animation:coin-glint 3s infinite linear;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes merchant-shine{0%,100%{filter:contrast(1.1) brightness(1) saturate(1.1);transform:scale(1)}50%{filter:contrast(1.2) brightness(1.3) saturate(1.4) drop-shadow(0 0 15px rgba(255,215,0,0.5));transform:scale(1.02)}}@keyframes coin-glint{0%{background-position:200% 0}100%{background-position:-200% 0}}.anim-ENGINEER{animation:engineer-glitch 4s infinite}.overlay-ENGINEER{background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,255,0,0.1) 3px);background-size:100% 4px;z-index:5;pointer-events:none;mix-blend-mode:hard-light;position:absolute;inset:0}@keyframes engineer-glitch{0%{filter:contrast(1.2);transform:translate(0,0)}92%{filter:contrast(1.2);transform:translate(0,0)}94%{filter:contrast(1.5) hue-rotate(90deg) saturate(2);transform:translate(2px,0)}96%{filter:contrast(1.5) hue-rotate(-90deg) saturate(2);transform:translate(-2px,0)}98%{filter:contrast(1.2);transform:translate(0,0)}100%{filter:contrast(1.2);transform:translate(0,0)}}.anim-SHAMAN{animation:shaman-pulse 6s ease-in-out infinite alternate}.overlay-SHAMAN{background:radial-gradient(circle,transparent 40%,rgba(147,51,234,0.3) 90%);mix-blend-mode:color-dodge;animation:rune-glow 4s ease-in-out infinite alternate;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes shaman-pulse{0%{filter:contrast(1.1) saturate(1.2);transform:scale(1)}100%{filter:contrast(1.3) saturate(1.6) hue-rotate(-10deg) drop-shadow(0 0 20px rgba(168,85,247,0.6));transform:scale(1.05)}}@keyframes rune-glow{0%{opacity:0.3}100%{opacity:0.6}}.anim-KEEPER{animation:keeper-eternal 8s ease-in-out infinite alternate}.overlay-KEEPER{background:radial-gradient(circle,rgba(251,146,60,0.1),transparent 60%);mix-blend-mode:screen;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes keeper-eternal{0%{filter:sepia(0.3) contrast(1.2) brightness(1)}100%{filter:sepia(0.1) contrast(1.3) brightness(1.2) drop-shadow(0 0 15px rgba(251,146,60,0.4))}}.anim-WALKER{animation:walker-shift 0.2s infinite alternate}.overlay-WALKER{background:linear-gradient(45deg,rgba(59,130,246,0.2),transparent);mix-blend-mode:overlay;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes walker-shift{0%{filter:contrast(1.2) brightness(1);opacity:0.95}100%{filter:contrast(1.3) brightness(1.1) hue-rotate(5deg);opacity:1}}.anim-LORD{animation:lord-tide 10s ease-in-out infinite alternate}.overlay-LORD{background:linear-gradient(180deg,transparent,rgba(6,182,212,0.2));mix-blend-mode:overlay;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes lord-tide{0%{transform:scale(1);filter:contrast(1.1) saturate(1.1)}100%{transform:scale(1.08);filter:contrast(1.2) saturate(1.4) drop-shadow(0 10px 20px rgba(6,182,212,0.4))}}.anim-PRIME{animation:prime-radiance 4s ease-in-out infinite alternate}.overlay-PRIME{background:radial-gradient(circle at 50% 0%,rgba(255,255,255,0.4),transparent 70%);mix-blend-mode:soft-light;animation:god-ray 8s linear infinite;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes prime-radiance{0%{filter:brightness(1.1) contrast(1.1)}100%{filter:brightness(1.4) contrast(1.2) drop-shadow(0 0 30px rgba(255,255,255,0.8))}}@keyframes god-ray{0%{transform:rotate(0deg);opacity:0.4}50%{opacity:0.6}100%{transform:rotate(360deg);opacity:0.4}}.anim-SINGULARITY{animation:singularity-chaos 10s linear infinite}.overlay-SINGULARITY{background:conic-gradient(from 0deg,#ff0000,#00ff00,#0000ff,#ff0000);mix-blend-mode:exclusion;opacity:0.2;animation:void-spin 20s linear infinite;pointer-events:none;z-index:5;position:absolute;inset:0}@keyframes singularity-chaos{0%{filter:hue-rotate(0deg) contrast(1.2);transform:scale(1)}50%{filter:hue-rotate(180deg) contrast(1.5);transform:scale(1.05)}100%{filter:hue-rotate(360deg) contrast(1.2);transform:scale(1)}}@keyframes void-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}`;

                const styles = `<style>*{margin:0;padding:0;box-sizing:border-box}body{margin:0;padding:0;display:flex;justify-content:center;align-items:center;min-height:100vh;background:#000;font-family:system-ui,-apple-system,sans-serif;overflow:hidden}.scene{perspective:1000px;width:336px;height:500px;cursor:pointer;margin:0 auto}.card{width:100%;height:100%;position:relative;transform-style:preserve-3d;transition:transform 0.6s cubic-bezier(0.4,0,0.2,1);border-radius:20px;${isSpirit ? 'overflow:visible' : 'overflow:hidden'};transform-origin:center center;will-change:transform}${spiritBorder}${pulseAnimation}.card.flipped{transform:rotateY(180deg);transform-origin:center center}.card-glare{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:20px;background:radial-gradient(circle at 50% 50%,rgba(255,255,255,0.3) 0%,transparent 60%);pointer-events:none;mix-blend-mode:overlay;z-index:50;opacity:0;transition:opacity 0.1s;display:none !important}.badge-medal{transition:transform 160ms ease,filter 160ms ease;transform:translateZ(0);will-change:transform,filter}.badge-medal:hover{transform:translateY(-2px) scale(1.06);filter:drop-shadow(0 0 12px rgba(255,107,53,0.35)) drop-shadow(0 0 22px rgba(255,255,255,0.12))}.text-tier-0{color:#e5e7eb}.text-tier-1{color:#fff;text-shadow:0 0 10px rgba(255,255,255,0.4)}.text-tier-2{background:linear-gradient(to right,#fff,#fb923c);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;filter:drop-shadow(0 0 5px rgba(255,107,53,0.5))}.text-tier-3{background:linear-gradient(to right,#fb923c,#a855f7,#3b82f6);background-size:200% 200%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:shimmerText 3s linear infinite;filter:drop-shadow(0 0 8px rgba(255,255,255,0.5))}@keyframes shimmerText{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}${imageEvolutionCSS}.face{position:absolute;width:100%;height:100%;border-radius:20px;overflow:hidden;background:#050505;backface-visibility:hidden;-webkit-backface-visibility:hidden}.face-front{transform:rotateY(0deg)}.face-back{transform:rotateY(180deg)}.card-face{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:20px;overflow:hidden;background:#000;backface-visibility:hidden;-webkit-backface-visibility:hidden}.card-face.face-front{transform:rotateY(0deg)}.card-face.face-back{transform:rotateY(180deg)}.custom-scroll{overflow-y:auto;scrollbar-width:thin;scrollbar-color:#FF6B35 rgba(255,255,255,0.05)}.custom-scroll::-webkit-scrollbar{width:4px}.custom-scroll::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}.custom-scroll::-webkit-scrollbar-thumb{background-color:#FF6B35;border-radius:10px}.card-tab-btn{border:1px solid rgba(255,255,255,0.10) !important}.card-tab-btn.active{border-color:rgba(255,107,53,0.45) !important}.overlay{position:absolute;inset:0;border-radius:20px;clip-path:inset(0 round 20px);pointer-events:none;z-index:10;background:linear-gradient(to top,rgba(0,0,0,1) 0%,rgba(0,0,0,0) 55%,rgba(0,0,0,0.6) 100%)}.badge-medal img{max-width:100%;max-height:100%}</style>`;

                const frontHTML = `<div class="card-face face-front flex flex-col" style="${borderStyleForFace}">
                                                            <img src="${bgBase64}" class="absolute inset-0 w-full h-full object-cover z-0 ${imgClass}" style="border-radius:20px;width:100%;height:100%;object-position:center top" onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
                                                            <div class="absolute inset-0 w-full h-full bg-gradient-to-br from-gray-900 via-gray-800 to-black z-0" style="border-radius:20px;display:none;width:100%;height:100%"></div>
                                                            ${overlayHtml}
                                                            <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-black/60 z-10 rounded-3xl" style="clip-path:inset(0 round 20px)"></div>
                                                            <div class="relative z-20 p-5 flex justify-center items-start">
                                                                <div class="flex gap-1 flex-nowrap justify-center" style="max-width:304px">${badgesFront}</div>
                                                                </div>
                                                            <div class="relative z-20 mt-auto px-5 pb-6">
                                                                <div class="text-center">
                                                                    ${tierLabelText ? `<div class="${rankBadgeClass} mb-2">${tierLabelText}</div>` : ''}
                                                                    <h2 class="text-3xl font-black uppercase italic leading-none drop-shadow-lg mb-4 ${titleClass} text-center">${archetype.title}</h2>
                                                                    <div class="mb-5"></div>
                                                                        </div>
                                                                <div class="h-px w-full bg-gradient-to-r from-white/30 to-transparent mb-3"></div>
                                                                <div class="flex items-center justify-between gap-2 mb-2" style="text-shadow:0 2px 10px rgba(0,0,0,0.75)">
                                                                    ${metrics.hasFennecSoul ? '<div class="text-[9px] font-bold text-fennec flex items-center gap-1" style="filter:drop-shadow(0 0 10px rgba(255,107,53,0.75))">SOUL</div>' : '<div></div>'}
                                                                    <div class="text-right">
                                                                        <div class="text-[8px] text-white/70 font-mono tracking-widest mb-0.5">EVOLUTION</div>
                                                                        <div class="text-sm font-black italic tracking-widest uppercase ${rarityTextClass} drop-shadow-md">${rarityName}</div>
                                                                        </div>
                                                                    </div>
                                                                <div class="text-[10px] text-gray-400 text-center tracking-widest">Tap card for details</div>
                                                                </div>
                                                        </div>`;

                const backHTML = `<div class="card-face face-back flex flex-col" style="${borderStyleForFace}">
                                                            <div style="position:absolute;inset:0;opacity:0.06;background-image:url('${symData}');background-repeat:no-repeat;background-position:center;background-size:70%;pointer-events:none;z-index:0"></div>
                                                            <div class="p-4 border-b border-white/10 bg-white/5 relative z-10">
                                                                <div class="flex justify-center items-center gap-2 mb-3">
                                                                    <img src="${phavData}" class="w-5 h-5 rounded-full opacity-70">
                                                                    <span class="text-[10px] font-bold text-gray-300 tracking-widest">FENNEC ID SYSTEM</span>
                                                            </div>
                                                                <div class="flex gap-2 mb-3">
                                                                    <button class="card-tab-btn active flex-1 py-2 px-3 rounded-lg border border-white/10 bg-fennec/20 text-fennec text-[9px] font-bold uppercase tracking-wider transition" data-tab="achievements" onclick="event.stopPropagation();const root=this.closest('.face-back');root.querySelectorAll('.card-tab-btn').forEach(b=>{b.classList.remove('active','bg-fennec/20','text-fennec');b.classList.add('bg-white/5','text-gray-400')});this.classList.remove('bg-white/5','text-gray-400');this.classList.add('active','bg-fennec/20','text-fennec');root.querySelectorAll('.card-tab-content').forEach(c=>c.classList.add('hidden'));root.querySelector('.card-tab-achievements').classList.remove('hidden')">
                                                                        BADGES
                                                                    </button>
                                                                    <button class="card-tab-btn flex-1 py-2 px-3 rounded-lg border border-white/10 bg-white/5 text-gray-400 text-[9px] font-bold uppercase tracking-wider transition" data-tab="technical" onclick="event.stopPropagation();const root=this.closest('.face-back');root.querySelectorAll('.card-tab-btn').forEach(b=>{b.classList.remove('active','bg-fennec/20','text-fennec');b.classList.add('bg-white/5','text-gray-400')});this.classList.remove('bg-white/5','text-gray-400');this.classList.add('active','bg-fennec/20','text-fennec');root.querySelectorAll('.card-tab-content').forEach(c=>c.classList.add('hidden'));root.querySelector('.card-tab-technical').classList.remove('hidden')">
                                                                        STATS
                                                                    </button>
                                                        </div>
                                                            </div>
                                                            <div class="card-tab-content card-tab-achievements flex-1 custom-scroll p-4 relative z-10" style="direction:ltr;overflow-y:auto">
                                                                <div style="display:flex;flex-direction:column;gap:10px;align-content:start">
                                                                    ${badgesBack}
                                                                </div>
                                                            </div>
                                                            <div class="card-tab-content card-tab-technical hidden flex-1 custom-scroll p-4 relative z-10" style="direction:ltr;overflow-y:auto">
                                                                <div style="display:flex;flex-direction:column;gap:12px">
                                                                    <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,107,53,0.28);border-radius:12px;padding:12px;box-shadow:0 0 18px rgba(255,107,53,0.12)">
                                                                        <div style="font-size:16px;color:#FF6B35;font-weight:950;letter-spacing:0.14em;text-transform:uppercase;margin-bottom:12px;text-align:center">SCORE BREAKDOWN</div>
                                                                        <div style="display:flex;flex-direction:column;gap:10px">
                                                                            ${(() => {
                                                                                const sb = metrics.scoreBreakdown || {};
                                                                                const clamp = (v, m) =>
                                                                                    Math.max(
                                                                                        0,
                                                                                        Math.min(
                                                                                            m,
                                                                                            Math.round(Number(v) || 0)
                                                                                        )
                                                                                    );
                                                                                const rows = [
                                                                                    {
                                                                                        label: 'Activity',
                                                                                        value: clamp(
                                                                                            sb.activityPoints,
                                                                                            30
                                                                                        ),
                                                                                        max: 30
                                                                                    },
                                                                                    {
                                                                                        label: 'Wealth',
                                                                                        value: clamp(
                                                                                            sb.wealthPoints,
                                                                                            20
                                                                                        ),
                                                                                        max: 20
                                                                                    },
                                                                                    {
                                                                                        label: 'Time',
                                                                                        value: clamp(sb.timePoints, 15),
                                                                                        max: 15
                                                                                    },
                                                                                    {
                                                                                        label: 'Badges',
                                                                                        value: clamp(
                                                                                            sb.badgesPoints,
                                                                                            35
                                                                                        ),
                                                                                        max: 35
                                                                                    },
                                                                                    {
                                                                                        label: 'Score',
                                                                                        value: clamp(sb.baseScore, 100),
                                                                                        max: 100
                                                                                    }
                                                                                ];
                                                                                return rows
                                                                                    .map(r => {
                                                                                        const pct = Math.max(
                                                                                            0,
                                                                                            Math.min(
                                                                                                100,
                                                                                                (r.value / r.max) * 100
                                                                                            )
                                                                                        );
                                                                                        const pctText = `${Math.round(pct)}%`;
                                                                                        return `
                                                                                    <div>
                                                                                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
                                                                                            <span style="font-size:15px;font-weight:900;color:rgba(255,255,255,0.88)">${r.label}</span>
                                                                                            <span style="font-size:15px;font-weight:950;color:#fff">${pctText}</span>
                                                                                        </div>
                                                                                        <div style="height:12px;border-radius:9999px;background:rgba(0,0,0,0.40);border:1px solid rgba(255,255,255,0.10);overflow:hidden">
                                                                                            <div style="height:100%;width:${pct}%;border-radius:9999px;background:linear-gradient(90deg,#FF6B35,#fb923c,#facc15)"></div>
                                                                                        </div>
                                                                                    </div>`;
                                                                                    })
                                                                                    .join('');
                                                                            })()}
                                                                            <div style="display:flex;align-items:center;justify-content:space-between;margin-top:8px">
                                                                                <div style="font-size:14px;color:rgba(209,213,219,1);font-weight:800">MAXI BOOST</div>
                                                                                <div style="display:flex;align-items:center;gap:8px;text-align:right">
                                                                                    <span style="font-size:14px;font-weight:950;color:${metrics.hasFennecMaxi ? '#ffffff' : 'rgba(107,114,128,1)'}">${metrics.hasFennecMaxi ? 'ACTIVE' : 'OFF'}</span>
                                                                                    <span style="width:8px;height:8px;border-radius:9999px;display:inline-block;background:${metrics.hasFennecMaxi ? '#FF6B35' : 'rgba(107,114,128,1)'};color:${metrics.hasFennecMaxi ? '#FF6B35' : 'rgba(107,114,128,1)'};box-shadow:0 0 6px currentColor"></span>
                                                                                </div>
                                                                            </div>
                                                                            <div style="display:flex;justify-content:space-between;align-items:center">
                                                                                <span style="font-size:14px;color:rgba(209,213,219,1);font-weight:800">Final Score</span>
                                                                                <span style="font-size:16px;font-weight:950;color:#FF6B35">${metrics.activityScore || 0}%</span>
                                                                            </div>
                                                                        </div>
                                                                    </div>

                                                                    <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:12px;text-align:center">
                                                                        <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">NET WORTH</div>
                                                                        <div style="font-size:22px;font-weight:800;color:#ffffff">$${metrics.wealth || '0.00'}</div>
                                                                    </div>

                                                                    <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px">
                                                                        <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:10px;text-align:center">
                                                                            <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">TXS</div>
                                                                            <div style="font-size:14px;font-weight:700;color:#fff">${metrics.txCount || 0}</div>
                                                        </div>
                                                                        <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:10px;text-align:center">
                                                                            <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">ON-CHAIN AGE</div>
                                                                            <div style="font-size:14px;font-weight:700;color:#fff">${metrics.daysAlive} <span style="font-size:10px;font-weight:400;color:rgba(107,114,128,1)">DAYS</span></div>
                                                                        </div>
                                                                        <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:10px;text-align:center">
                                                                            <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">USELESS UTXO</div>
                                                                            <div style="font-size:14px;font-weight:700;color:#fff">${metrics.abandonedUtxoCount === null || metrics.abandonedUtxoCount === undefined ? '—' : metrics.abandonedUtxoCount}</div>
                                                                        </div>
                                                                        <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:10px;text-align:center">
                                                                            <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">UTXOS</div>
                                                                            <div style="font-size:14px;font-weight:700;color:#fff">${metrics.utxoCount || 0}</div>
                                                                        </div>
                                                </div>

                                                                    <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:12px">
                                                                        <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:10px;text-align:center">ASSETS</div>
                                                                        <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px;text-align:center;margin-bottom:12px">
                                                                            <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">LP VALUE</div>
                                                                            <div style="font-size:14px;font-weight:700;color:#fff">$${parseFloat(metrics.lpValueUSD || 0).toFixed(2)}</div>
                                                                        </div>
                                                                        <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px">
                                                                            <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px">
                                                                                <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:10px;text-align:center">FB</div>
                                                                                <div style="display:flex;flex-direction:column;gap:6px">
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">Wallet</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.nativeBalance || 0).toFixed(4)}</span></div>
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">InSwap</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.fbSwapBalance || 0).toFixed(4)}</span></div>
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">Total</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.fbTotal || 0).toFixed(2)}</span></div>
                                                                                </div>
                                                                            </div>

                                                                            <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px">
                                                                                <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:10px;text-align:center">FENNEC</div>
                                                                                <div style="display:flex;flex-direction:column;gap:6px">
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">Wallet</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.fennecWalletBalance || 0).toFixed(2)}</span></div>
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">InSwap</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.fennecInSwapBalance || 0).toFixed(2)}</span></div>
                                                                                    <div style="display:flex;justify-content:space-between;align-items:center"><span style="font-size:9px;color:rgba(156,163,175,1)">Total</span><span style="font-size:10px;font-weight:700;color:#fff">${parseFloat(metrics.fennecBalance || 0).toFixed(2)}</span></div>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    </div>

                                                                    <div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.10);border-radius:12px;padding:12px">
                                                                        <div style="font-size:8px;color:rgba(156,163,175,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:10px;text-align:center">VAULT</div>
                                                                        <div style="display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px">
                                                                            <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px;text-align:center">
                                                                                <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">Runes</div>
                                                                                <div style="font-size:14px;font-weight:700;color:#fff">${inscriptionStatsForDisplay.runes || 0}</div>
                                                                            </div>
                                                                            <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px;text-align:center">
                                                                                <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">BRC-20</div>
                                                                                <div style="font-size:14px;font-weight:700;color:#fff">${inscriptionStatsForDisplay.brc20 || 0}</div>
                                                                            </div>
                                                                            <div style="background:rgba(0,0,0,0.20);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:10px;text-align:center">
                                                                                <div style="font-size:8px;color:rgba(107,114,128,1);letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px">Inscriptions</div>
                                                                                <div style="font-size:14px;font-weight:700;color:#fff">${inscriptionStatsForDisplay.ordinals || 0}</div>
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </div>`;

                const imageEvolutionOverrideCSS = `<style>
                                                        .img-tier-0{filter:grayscale(0.20) sepia(0.16) contrast(1.00) brightness(1.00) saturate(1.05);transform:scale(1.01)}
                                                        .anim-tier-1{animation:breathe 10s ease-in-out infinite alternate}
                                                        @keyframes breathe{0%{filter:grayscale(0.08) contrast(1.02) brightness(1.00) saturate(1.04)}100%{filter:grayscale(0) contrast(1.06) brightness(1.06) saturate(1.10)}}
                                                        .anim-tier-2-heat{animation:heat-low 5s infinite alternate}
                                                        @keyframes heat-low{0%{filter:sepia(0.14) contrast(1.10) brightness(1.03) saturate(1.08)}100%{filter:sepia(0.28) contrast(1.16) brightness(1.07) saturate(1.13)}}
                                                        .anim-tier-2-shine{animation:shine-low 4s infinite alternate}
                                                        @keyframes shine-low{0%{filter:brightness(1.06) contrast(1.06) saturate(1.14)}100%{filter:brightness(1.18) contrast(1.10) saturate(1.25)}}
                                                        .anim-tier-2-glitch{animation:glitch-low 3s infinite}
                                                        @keyframes glitch-low{0%,92%{filter:contrast(1.12) brightness(1.03) saturate(1.08);transform:translate3d(0,0,0)}93%{filter:contrast(1.28) brightness(1.06) saturate(1.15) hue-rotate(6deg);transform:translate3d(1px,0,0)}94%{filter:contrast(1.28) brightness(1.06) saturate(1.15) hue-rotate(-6deg);transform:translate3d(-1px,0,0)}100%{filter:contrast(1.12) brightness(1.03) saturate(1.08);transform:translate3d(0,0,0)}}
                                                        .anim-tier-2-magic{animation:magic-low 4s infinite alternate}
                                                        @keyframes magic-low{0%{filter:hue-rotate(0deg) saturate(1.15) contrast(1.06) brightness(1.03)}100%{filter:hue-rotate(-8deg) saturate(1.34) contrast(1.12) brightness(1.12)}}

                                                        .overlay-DRIFTER{background:linear-gradient(to bottom,rgba(255,160,0,0.16),transparent 70%);mix-blend-mode:overlay;border-radius:inherit;overflow:hidden}
                                                        .overlay-DRIFTER::before{content:'';position:absolute;inset:-10%;background:radial-gradient(120% 60% at 10% 82%,rgba(255,255,255,0.16) 0%,transparent 55%),radial-gradient(120% 60% at 90% 70%,rgba(255,160,0,0.14) 0%,transparent 60%),linear-gradient(120deg,transparent 0%,rgba(255,255,255,0.05) 50%,transparent 100%);background-size:140% 140%,140% 140%,240% 240%;background-position:0% 0%,100% 0%,0% 50%;opacity:0.55;mix-blend-mode:overlay;filter:blur(0.2px);animation:sand-drift 8s linear infinite}
                                                        .overlay-DRIFTER::after{content:'';position:absolute;inset:-8%;background:linear-gradient(90deg,rgba(255,255,255,0.14),transparent 35%,rgba(255,255,255,0.10) 65%,transparent);opacity:0.24;mix-blend-mode:screen;filter:blur(1.6px) saturate(1.15);animation:heat-haze 4s ease-in-out infinite}
                                                        @keyframes drifter-heat{0%{filter:sepia(0.28) contrast(1.10) brightness(1.06) saturate(1.10)}50%{filter:sepia(0.48) contrast(1.16) brightness(1.16) saturate(1.18) blur(0.35px) drop-shadow(0 0 14px rgba(255,160,0,0.20))}100%{filter:sepia(0.28) contrast(1.10) brightness(1.06) saturate(1.10)}}
                                                        @keyframes sand-drift{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(-6%,-10%,0)}}
                                                        @keyframes heat-haze{0%{transform:translate3d(-2%,0,0) skewX(-1.2deg)}50%{transform:translate3d(2%,-1%,0) skewX(1.2deg)}100%{transform:translate3d(-2%,0,0) skewX(-1.2deg)}}

                                                        .overlay-MERCHANT{background:radial-gradient(circle at 50% 70%,rgba(255,215,0,0.10),transparent 58%);mix-blend-mode:screen;border-radius:inherit;overflow:hidden}
                                                        .overlay-MERCHANT::before{content:'';position:absolute;inset:-20%;background:linear-gradient(120deg,transparent 40%,rgba(255,215,0,0.55) 50%,transparent 60%);mix-blend-mode:color-dodge;opacity:0.65;animation:coin-glint 2.4s linear infinite;filter:blur(0.6px)}
                                                        .overlay-MERCHANT::after{content:'';position:absolute;inset:-15%;background:radial-gradient(60% 60% at 35% 35%,rgba(255,255,255,0.14),transparent 68%),radial-gradient(70% 70% at 70% 65%,rgba(255,215,0,0.12),transparent 72%),linear-gradient(120deg,rgba(255,255,255,0.05),transparent 60%,rgba(255,215,0,0.04));opacity:0.28;mix-blend-mode:screen;animation:sparkle-drift 6s ease-in-out infinite alternate;filter:blur(0.25px)}
                                                        @keyframes merchant-shine{0%,100%{filter:contrast(1.10) brightness(1.10) saturate(1.18)}50%{filter:contrast(1.18) brightness(1.34) saturate(1.42) drop-shadow(0 0 18px rgba(255,215,0,0.40))}}
                                                        @keyframes coin-glint{0%{transform:translate3d(30%,-20%,0)}100%{transform:translate3d(-30%,20%,0)}}
                                                        @keyframes sparkle-drift{0%{transform:translate3d(-1%,1%,0);opacity:0.20}100%{transform:translate3d(1%,-1%,0);opacity:0.36}}

                                                        .overlay-ENGINEER{background:repeating-linear-gradient(0deg,rgba(0,255,170,0.0),rgba(0,255,170,0.0) 2px,rgba(0,255,170,0.12) 3px),linear-gradient(90deg,rgba(0,0,0,0.0),rgba(0,255,170,0.08),rgba(0,0,0,0.0));background-size:100% 4px,200% 200%;mix-blend-mode:hard-light;border-radius:inherit;overflow:hidden}
                                                        .overlay-ENGINEER::before{content:'';position:absolute;inset:-10%;background:linear-gradient(0deg,transparent 40%,rgba(255,255,255,0.18) 50%,transparent 60%);opacity:0.16;mix-blend-mode:overlay;animation:engineer-scan 2.2s linear infinite;filter:blur(0.6px)}
                                                        .overlay-ENGINEER::after{content:'';position:absolute;inset:0;background:repeating-linear-gradient(90deg,rgba(255,0,80,0.10),rgba(255,0,80,0.10) 1px,transparent 2px,transparent 6px);opacity:0.14;mix-blend-mode:difference;animation:engineer-rgb 3.6s ease-in-out infinite}
                                                        @keyframes engineer-glitch{0%{filter:contrast(1.16) brightness(1.06) saturate(1.10);transform:translate3d(0,0,0)}92%{filter:contrast(1.16) brightness(1.06) saturate(1.10);transform:translate3d(0,0,0)}94%{filter:contrast(1.48) brightness(1.10) saturate(1.35) hue-rotate(90deg);transform:translate3d(2px,0,0)}96%{filter:contrast(1.48) brightness(1.10) saturate(1.35) hue-rotate(-90deg);transform:translate3d(-2px,0,0)}98%{filter:contrast(1.16) brightness(1.06) saturate(1.10);transform:translate3d(0,0,0)}100%{filter:contrast(1.16) brightness(1.06) saturate(1.10);transform:translate3d(0,0,0)}}
                                                        @keyframes engineer-scan{0%{transform:translate3d(0,22%,0)}100%{transform:translate3d(0,-22%,0)}}
                                                        @keyframes engineer-rgb{0%,100%{transform:translate3d(0,0,0)}50%{transform:translate3d(1%,0,0)}}

                                                        .overlay-SHAMAN{background:radial-gradient(circle at 50% 55%,rgba(147,51,234,0.18),transparent 62%);mix-blend-mode:color-dodge;animation:rune-glow 3.8s ease-in-out infinite alternate;border-radius:inherit;overflow:hidden}
                                                        .overlay-SHAMAN::before{content:'';position:absolute;inset:-15%;background:conic-gradient(from 0deg,rgba(147,51,234,0.0),rgba(168,85,247,0.35),rgba(59,130,246,0.0),rgba(168,85,247,0.32),rgba(147,51,234,0.0));opacity:0.35;mix-blend-mode:color-dodge;filter:blur(1.4px);animation:shaman-swirl 7s linear infinite}
                                                        .overlay-SHAMAN::after{content:'';position:absolute;inset:-10%;background:radial-gradient(60% 60% at 35% 40%,rgba(255,255,255,0.12),transparent 70%),radial-gradient(70% 70% at 70% 60%,rgba(168,85,247,0.12),transparent 72%);opacity:0.18;mix-blend-mode:screen;animation:rune-dust 5s ease-in-out infinite alternate}
                                                        @keyframes shaman-pulse{0%{filter:contrast(1.10) brightness(1.06) saturate(1.24)}100%{filter:contrast(1.28) brightness(1.16) saturate(1.72) hue-rotate(-10deg) drop-shadow(0 0 20px rgba(168,85,247,0.55))}}
                                                        @keyframes rune-glow{0%{opacity:0.25}100%{opacity:0.55}}
                                                        @keyframes shaman-swirl{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
                                                        @keyframes rune-dust{0%{transform:translate3d(-1%,1%,0);opacity:0.12}100%{transform:translate3d(1%,-1%,0);opacity:0.22}}

                                                        .overlay-KEEPER{background:radial-gradient(circle at 50% 45%,rgba(251,146,60,0.14),transparent 62%);mix-blend-mode:screen;border-radius:inherit;overflow:hidden}
                                                        .overlay-KEEPER::before{content:'';position:absolute;inset:-20%;background:radial-gradient(70% 60% at 35% 40%,rgba(255,255,255,0.14),transparent 70%),radial-gradient(70% 70% at 70% 65%,rgba(251,146,60,0.14),transparent 74%),linear-gradient(135deg,rgba(255,255,255,0.05),transparent 60%,rgba(251,146,60,0.04));opacity:0.20;mix-blend-mode:screen;animation:ember-drift 6.5s ease-in-out infinite alternate;filter:blur(0.25px)}
                                                        .overlay-KEEPER::after{content:'';position:absolute;inset:-10%;background:radial-gradient(circle at 50% 50%,rgba(255,255,255,0.10),transparent 62%);opacity:0.14;mix-blend-mode:soft-light;animation:halo-breathe 3.8s ease-in-out infinite alternate;filter:blur(2px)}
                                                        @keyframes keeper-eternal{0%{filter:sepia(0.05) contrast(1.08) brightness(1.02) saturate(1.06)}100%{filter:sepia(0.01) contrast(1.14) brightness(1.06) saturate(1.10) drop-shadow(0 0 10px rgba(251,146,60,0.20))}}
                                                        @keyframes ember-drift{0%{transform:translate3d(-1%,2%,0)}100%{transform:translate3d(1%,-2%,0)}}
                                                        @keyframes halo-breathe{0%{opacity:0.14}100%{opacity:0.30}}

                                                        .overlay-WALKER{background:linear-gradient(45deg,rgba(59,130,246,0.22),transparent);mix-blend-mode:overlay;border-radius:inherit;overflow:hidden}
                                                        .overlay-WALKER::before{content:'';position:absolute;inset:-15%;background:radial-gradient(80% 60% at 20% 30%,rgba(255,255,255,0.14) 0%,transparent 60%),radial-gradient(80% 60% at 80% 70%,rgba(255,255,255,0.10) 0%,transparent 62%),radial-gradient(90% 70% at 50% 50%,rgba(255,255,255,0.08) 0%,transparent 66%);opacity:0.22;mix-blend-mode:screen;filter:blur(0.8px);animation:time-rings 5.8s linear infinite}
                                                        .overlay-WALKER::after{content:'';position:absolute;inset:-10%;background:linear-gradient(90deg,rgba(255,255,255,0.10),transparent 35%,rgba(255,255,255,0.06) 65%,transparent);opacity:0.18;mix-blend-mode:screen;filter:blur(1.2px);animation:time-shear 3.6s ease-in-out infinite}
                                                        @keyframes walker-shift{0%,100%{filter:contrast(1.16) brightness(1.08) saturate(1.12) hue-rotate(0deg)}50%{filter:contrast(1.26) brightness(1.16) saturate(1.26) hue-rotate(10deg)}}
                                                        @keyframes time-rings{0%{transform:translate3d(-2%,2%,0)}100%{transform:translate3d(2%,-2%,0)}}
                                                        @keyframes time-shear{0%{transform:translate3d(-2%,0,0) skewX(-1deg)}50%{transform:translate3d(2%,-1%,0) skewX(1deg)}100%{transform:translate3d(-2%,0,0) skewX(-1deg)}}

                                                        .overlay-LORD{background:radial-gradient(circle at 50% 85%,rgba(6,182,212,0.14),transparent 60%);mix-blend-mode:overlay;border-radius:inherit;overflow:hidden}
                                                        .overlay-LORD::before{content:'';position:absolute;inset:-20%;background:radial-gradient(90% 70% at 30% 80%,rgba(255,255,255,0.14) 0%,transparent 62%),radial-gradient(90% 70% at 70% 75%,rgba(255,255,255,0.10) 0%,transparent 64%),conic-gradient(from 180deg at 50% 50%,rgba(255,255,255,0.08),transparent 40%,rgba(255,255,255,0.06),transparent 75%,rgba(255,255,255,0.08));opacity:0.16;mix-blend-mode:screen;filter:blur(1.0px);animation:caustics 9s linear infinite}
                                                        .overlay-LORD::after{content:'';position:absolute;inset:-10%;background:linear-gradient(180deg,rgba(255,255,255,0.12),transparent 55%,rgba(255,255,255,0.08));opacity:0.22;mix-blend-mode:soft-light;filter:blur(1.6px);animation:tide-sheen 4.5s ease-in-out infinite}
                                                        @keyframes lord-tide{0%{filter:contrast(1.12) brightness(1.06) saturate(1.14)}100%{filter:contrast(1.26) brightness(1.16) saturate(1.50) drop-shadow(0 12px 26px rgba(6,182,212,0.45))}}
                                                        @keyframes caustics{0%{transform:translate3d(-2%,1%,0) rotate(0deg)}100%{transform:translate3d(2%,-1%,0) rotate(360deg)}}
                                                        @keyframes tide-sheen{0%{transform:translate3d(0,2%,0);opacity:0.16}50%{transform:translate3d(0,-2%,0);opacity:0.28}100%{transform:translate3d(0,2%,0);opacity:0.16}}

                                                        .overlay-PRIME{background:radial-gradient(circle at 50% 0%,rgba(255,255,255,0.52),transparent 72%);mix-blend-mode:soft-light;animation:god-ray 8s linear infinite;border-radius:inherit;overflow:hidden}
                                                        .overlay-PRIME::before{content:'';position:absolute;inset:-20%;background:conic-gradient(from 0deg,transparent,rgba(255,255,255,0.22),transparent 40%,rgba(255,255,255,0.18),transparent 75%,rgba(255,255,255,0.20),transparent);opacity:0.26;mix-blend-mode:screen;filter:blur(1.2px);animation:prime-halo 10s linear infinite}
                                                        .overlay-PRIME::after{content:'';position:absolute;inset:-15%;background:radial-gradient(70% 60% at 35% 40%,rgba(255,255,255,0.18),transparent 70%),radial-gradient(80% 70% at 70% 65%,rgba(255,255,255,0.10),transparent 74%),linear-gradient(115deg,transparent,rgba(255,255,255,0.10),transparent);opacity:0.20;mix-blend-mode:screen;filter:blur(0.3px);animation:prime-sparks 6.5s ease-in-out infinite alternate}
                                                        @keyframes prime-radiance{0%{filter:brightness(1.18) contrast(1.12) saturate(1.10)}100%{filter:brightness(1.55) contrast(1.22) saturate(1.22) drop-shadow(0 0 36px rgba(255,255,255,0.90))}}
                                                        @keyframes prime-halo{0%{transform:rotate(0deg)}100%{transform:rotate(-360deg)}}
                                                        @keyframes prime-sparks{0%{transform:translate3d(-1%,1%,0);opacity:0.14}100%{transform:translate3d(1%,-1%,0);opacity:0.24}}

                                                        .overlay-SINGULARITY{background:conic-gradient(from 0deg,#ff0000,#00ff00,#0000ff,#ff0000);mix-blend-mode:exclusion;opacity:0.28;animation:void-spin 20s linear infinite;border-radius:inherit;overflow:hidden}
                                                        .overlay-SINGULARITY::before{content:'';position:absolute;inset:-20%;background:radial-gradient(60% 60% at 35% 40%,rgba(255,255,255,0.12),transparent 70%),radial-gradient(70% 70% at 65% 60%,rgba(255,255,255,0.08),transparent 72%),linear-gradient(135deg,rgba(255,255,255,0.05),transparent 60%,rgba(255,255,255,0.03));opacity:0.12;mix-blend-mode:overlay;filter:blur(0.6px);animation:void-grain 3.2s steps(2,end) infinite}
                                                        .overlay-SINGULARITY::after{content:'';position:absolute;inset:-10%;background:radial-gradient(circle at 50% 50%,rgba(255,255,255,0.10),transparent 55%),conic-gradient(from 0deg,rgba(255,255,255,0.00),rgba(255,255,255,0.14),rgba(255,255,255,0.00));opacity:0.18;mix-blend-mode:screen;filter:blur(1.6px);animation:void-pulse 4.8s ease-in-out infinite}
                                                        @keyframes singularity-chaos{0%{filter:hue-rotate(0deg) contrast(1.25) brightness(1.05) saturate(1.10)}50%{filter:hue-rotate(180deg) contrast(1.65) brightness(1.15) saturate(1.30) drop-shadow(0 0 26px rgba(255,255,255,0.22))}100%{filter:hue-rotate(360deg) contrast(1.25) brightness(1.05) saturate(1.10)}}
                                                        @keyframes void-grain{0%{transform:translate3d(-1%,-1%,0)}100%{transform:translate3d(1%,1%,0)}}
                                                        @keyframes void-pulse{0%{transform:rotate(0deg);opacity:0.12}50%{transform:rotate(180deg);opacity:0.26}100%{transform:rotate(360deg);opacity:0.12}}
                                                        </style>`;

                const imageEvolutionRetuneCSS = `<style>
                                                        .face [class^="overlay-"],.face [class*=" overlay-"]{z-index:12!important}
                                                        .vfx-3d{position:absolute;inset:0;border-radius:inherit;pointer-events:none;z-index:13;opacity:var(--vfx3d-opacity,0.24);mix-blend-mode:screen;overflow:hidden}
                                                        .vfx-3d::before{content:'';position:absolute;inset:-25%;background:radial-gradient(circle at var(--mxp,50%) var(--myp,50%),rgba(255,255,255,0.58),transparent 60%),linear-gradient(120deg,rgba(255,255,255,0.00),rgba(255,255,255,0.14),rgba(255,255,255,0.00));filter:blur(9px) saturate(1.06);transform:translate3d(var(--npx,0px),var(--npy,0px),0)}
                                                        .vfx-3d::after{content:'';position:absolute;inset:-20%;background:radial-gradient(circle at var(--mxp,50%) var(--myp,50%),rgba(255,255,255,0.26),transparent 46%),linear-gradient(90deg,rgba(255,255,255,0.10),transparent 40%,rgba(255,255,255,0.06) 60%,transparent);background-size:100% 100%,220% 220%;background-position:0 0,0 0;mix-blend-mode:soft-light;filter:blur(1.6px);opacity:0.60;transform:translate3d(var(--px,0px),var(--py,0px),0);animation:vfx-sheen 7.5s linear infinite}
                                                        @keyframes vfx-sheen{0%{background-position:0 0,0% 50%}100%{background-position:0 0,100% 50%}}
                                                        @keyframes heat-low{0%{filter:sepia(0.08) contrast(1.06) brightness(1.02) saturate(1.04)}100%{filter:sepia(0.16) contrast(1.10) brightness(1.05) saturate(1.06)}}
                                                        @keyframes shine-low{0%{filter:brightness(1.03) contrast(1.04) saturate(1.06)}100%{filter:brightness(1.10) contrast(1.06) saturate(1.12)}}
                                                        @keyframes glitch-low{0%,92%{filter:contrast(1.12) brightness(1.03) saturate(1.08);transform:translate3d(0,0,0)}93%{filter:contrast(1.22) brightness(1.05) saturate(1.12) hue-rotate(3deg);transform:translate3d(1px,0,0)}94%{filter:contrast(1.22) brightness(1.05) saturate(1.12) hue-rotate(-3deg);transform:translate3d(-1px,0,0)}100%{filter:contrast(1.12) brightness(1.03) saturate(1.08);transform:translate3d(0,0,0)}}
                                                        @keyframes magic-low{0%{filter:saturate(1.08) contrast(1.04) brightness(1.02)}100%{filter:saturate(1.16) contrast(1.06) brightness(1.06)}}
                                                        .overlay-DRIFTER::before{opacity:0.78;animation:sand-drift 7s linear infinite}
                                                        .overlay-DRIFTER::after{opacity:0.34;filter:blur(1.6px) saturate(1.10);animation:heat-haze 3.6s ease-in-out infinite}
                                                        @keyframes drifter-heat{0%{filter:sepia(0.12) contrast(1.06) brightness(1.03) saturate(1.05)}50%{filter:sepia(0.22) contrast(1.10) brightness(1.08) saturate(1.08) blur(0.25px) drop-shadow(0 0 12px rgba(255,160,0,0.18))}100%{filter:sepia(0.12) contrast(1.06) brightness(1.03) saturate(1.05)}}
                                                        .overlay-MERCHANT::before{opacity:0.85;animation:coin-glint 2.2s linear infinite}
                                                        .overlay-MERCHANT::after{opacity:0.42;animation:sparkle-drift 5.2s ease-in-out infinite alternate}
                                                        @keyframes merchant-shine{0%,100%{filter:contrast(1.06) brightness(1.06) saturate(1.10)}50%{filter:contrast(1.10) brightness(1.18) saturate(1.18) drop-shadow(0 0 14px rgba(255,215,0,0.32))}}
                                                        .overlay-ENGINEER::before{opacity:0.30;animation:engineer-scan 2.0s linear infinite}
                                                        .overlay-ENGINEER::after{opacity:0.22;animation:engineer-rgb 3.0s ease-in-out infinite}
                                                        @keyframes engineer-glitch{0%,92%{filter:contrast(1.12) brightness(1.04) saturate(1.06);transform:translate3d(0,0,0)}94%{filter:contrast(1.30) brightness(1.07) saturate(1.15) hue-rotate(18deg);transform:translate3d(2px,0,0)}96%{filter:contrast(1.30) brightness(1.07) saturate(1.15) hue-rotate(-18deg);transform:translate3d(-2px,0,0)}98%,100%{filter:contrast(1.12) brightness(1.04) saturate(1.06);transform:translate3d(0,0,0)}}
                                                        @keyframes engineer-glitch-strong{0%,90%{filter:contrast(1.14) brightness(1.05) saturate(1.08);transform:translate3d(0,0,0)}92%{filter:contrast(1.46) brightness(1.10) saturate(1.26) hue-rotate(36deg);transform:translate3d(4px,-1px,0)}94%{filter:contrast(1.46) brightness(1.10) saturate(1.26) hue-rotate(-36deg);transform:translate3d(-4px,1px,0)}96%{filter:contrast(1.32) brightness(1.08) saturate(1.18) hue-rotate(18deg);transform:translate3d(2px,0,0)}98%,100%{filter:contrast(1.14) brightness(1.05) saturate(1.08);transform:translate3d(0,0,0)}}
                                                        .overlay-SHAMAN::before{opacity:0.50;animation:shaman-swirl 6s linear infinite}
                                                        .overlay-SHAMAN::after{opacity:0.28;animation:rune-dust 4.6s ease-in-out infinite alternate}
                                                        @keyframes shaman-pulse{0%{filter:contrast(1.06) brightness(1.04) saturate(1.10)}100%{filter:contrast(1.14) brightness(1.10) saturate(1.22) hue-rotate(-4deg) drop-shadow(0 0 16px rgba(168,85,247,0.40))}}
                                                        .overlay-KEEPER::before{opacity:0.22;animation:ember-drift 5.8s ease-in-out infinite alternate}
                                                        .overlay-KEEPER::after{opacity:0.14;animation:halo-breathe 3.2s ease-in-out infinite alternate}
                                                        @keyframes keeper-eternal{0%{filter:sepia(0.05) contrast(1.08) brightness(1.02) saturate(1.06)}100%{filter:sepia(0.01) contrast(1.14) brightness(1.06) saturate(1.10) drop-shadow(0 0 10px rgba(251,146,60,0.20))}}
                                                        .overlay-WALKER::before{opacity:0.34;animation:time-rings 5.2s linear infinite}
                                                        .overlay-WALKER::after{opacity:0.26;animation:time-shear 3.0s ease-in-out infinite}
                                                        @keyframes walker-shift{0%,100%{filter:contrast(1.10) brightness(1.05) saturate(1.06) hue-rotate(0deg)}50%{filter:contrast(1.18) brightness(1.10) saturate(1.14) hue-rotate(4deg)}}
                                                        .overlay-LORD::before{opacity:0.24;animation:caustics 8s linear infinite}
                                                        .overlay-LORD::after{opacity:0.32;animation:tide-sheen 3.8s ease-in-out infinite}
                                                        @keyframes lord-tide{0%{filter:contrast(1.08) brightness(1.04) saturate(1.08)}100%{filter:contrast(1.16) brightness(1.10) saturate(1.18) drop-shadow(0 10px 22px rgba(6,182,212,0.35))}}
                                                        .overlay-PRIME::before{opacity:0.40;animation:prime-halo 9s linear infinite}
                                                        .overlay-PRIME::after{opacity:0.30;animation:prime-sparks 5.6s ease-in-out infinite alternate}
                                                        @keyframes prime-radiance{0%{filter:brightness(1.10) contrast(1.06) saturate(1.06)}100%{filter:brightness(1.26) contrast(1.12) saturate(1.14) drop-shadow(0 0 28px rgba(255,255,255,0.55))}}
                                                        .overlay-SINGULARITY{background:conic-gradient(from 0deg,rgba(255,0,0,0.85),rgba(0,255,0,0.75),rgba(0,0,255,0.85),rgba(255,0,0,0.85));mix-blend-mode:overlay;opacity:0.18;filter:saturate(0.78) contrast(0.95)}
                                                        .overlay-SINGULARITY::before{opacity:0.22;animation:void-grain 2.8s steps(2,end) infinite}
                                                        .overlay-SINGULARITY::after{opacity:0.28;animation:void-pulse 4.2s ease-in-out infinite}
                                                        @keyframes singularity-chaos{0%{filter:contrast(1.10) brightness(1.03) saturate(1.06)}50%{filter:contrast(1.26) brightness(1.08) saturate(1.12) drop-shadow(0 0 18px rgba(255,255,255,0.18))}100%{filter:contrast(1.10) brightness(1.03) saturate(1.06)}}
                                                        </style>`;

                const mintCoreCardCSS = `<style>
                                                        .card-scene{perspective:1200px;width:336px;height:490px;margin:0 auto;position:relative;z-index:10}
                                                        .card-object{width:100%;height:100%;position:relative;transform-style:preserve-3d;transform-origin:center center;transition:transform 620ms cubic-bezier(0.4,0,0.2,1);--tiltX:0deg;--tiltY:0deg;--flipY:0deg;transform:rotateX(var(--tiltX)) rotateY(calc(var(--tiltY) + var(--flipY)));border-radius:20px;overflow:visible;will-change:transform;box-shadow:0 20px 40px -10px rgba(0,0,0,0.5)}
                                                        .card-object.card-cub{border:3px solid #52525b !important;box-shadow:0 0 25px rgba(82,82,91,0.5), inset 0 0 10px rgba(82,82,91,0.2) !important}
                                                        .card-object.card-scout{border:3px solid #22c55e !important;box-shadow:0 0 30px rgba(34,197,94,0.6), inset 0 0 15px rgba(34,197,94,0.3) !important}
                                                        .card-object.card-hunter{border:3px solid #3b82f6 !important;box-shadow:0 0 35px rgba(59,130,246,0.7), inset 0 0 15px rgba(59,130,246,0.4) !important}
                                                        .card-object.card-alpha{border:3px solid #ef4444 !important;box-shadow:0 0 40px rgba(239,68,68,0.8), inset 0 0 20px rgba(239,68,68,0.5) !important}
                                                        .card-object.card-elder{border:3px solid #eab308 !important;box-shadow:0 0 45px rgba(234,179,8,0.9), inset 0 0 20px rgba(234,179,8,0.6) !important}
                                                        .card-object[data-vfx="ENGINEER"][data-tier="2"] .vfx-3d,.card-object[data-vfx="ENGINEER"][data-tier="3"] .vfx-3d{display:none!important}
                                                        .card-object[data-vfx="ENGINEER"][data-tier="2"] .overlay-ENGINEER{animation:engineer-glitch 3.2s ease-in-out infinite}
                                                        .card-object[data-vfx="ENGINEER"][data-tier="3"] .overlay-ENGINEER{animation:engineer-glitch-strong 3.2s ease-in-out infinite}
                                                        .card-object::after{content:"";position:absolute;inset:0;border-radius:20px;pointer-events:none;z-index:40;opacity:0;mix-blend-mode:overlay;background:linear-gradient(115deg,rgba(255,255,255,0.16),rgba(255,255,255,0.00) 45%,rgba(255,255,255,0.10) 55%,rgba(255,255,255,0.00) 70%),linear-gradient(45deg,rgba(255,255,255,0.014),rgba(255,255,255,0) 55%,rgba(255,255,255,0.010))}
                                                        .card-object:not([data-vfx="ENGINEER"]) .face-front::before{content:"";position:absolute;top:-140%;left:-180%;width:72px;height:420%;border-radius:20px;pointer-events:none;z-index:14;opacity:0;mix-blend-mode:screen;transform:rotate(22deg);will-change:left,opacity;filter:blur(3px);background:linear-gradient(45deg,transparent 28%,rgba(var(--tier-shine-rgb,255,215,0),0.40) 50%,transparent 72%);animation:tierShineSweep var(--tier-shine-dur,9.5s) ease-in-out infinite}
                                                        .card-object[data-tier="0"]{--tier-shine-opacity:0;--tier-shine-dur:999s}
                                                        .card-object[data-tier="1"]{--tier-shine-opacity:0.28;--tier-shine-dur:12s}
                                                        .card-object[data-tier="2"]{--tier-shine-opacity:0.40;--tier-shine-dur:9s}
                                                        .card-object[data-tier="3"]{--tier-shine-opacity:0.52;--tier-shine-dur:7.5s}
                                                        .card-object[data-vfx="MERCHANT"]{--tier-shine-rgb:255,215,0}
                                                        @keyframes tierShineSweep{0%{left:-180%;opacity:0}18%{left:-180%;opacity:0}22%{left:-180%;opacity:var(--tier-shine-opacity,0.22)}82%{left:180%;opacity:var(--tier-shine-opacity,0.22)}86%{left:180%;opacity:0}100%{left:180%;opacity:0}}
                                                        .card-object.card-spirit .card-face{box-shadow:0 0 20px rgba(255,0,0,0.5),0 0 30px rgba(255,127,0,0.4),0 0 40px rgba(255,255,0,0.3),0 0 50px rgba(0,255,0,0.3),0 0 40px rgba(0,255,255,0.3),0 0 30px rgba(0,0,255,0.4),0 0 20px rgba(75,0,130,0.5),0 0 10px rgba(148,0,211,0.6)}
                                                        @keyframes spiritBorderPulse{0%{filter:brightness(1.65) saturate(1.25) hue-rotate(0deg) drop-shadow(0 0 16px rgba(255,255,255,0.35))}50%{filter:brightness(2.05) saturate(1.45) hue-rotate(180deg) drop-shadow(0 0 20px rgba(255,255,255,0.45))}100%{filter:brightness(1.65) saturate(1.25) hue-rotate(360deg) drop-shadow(0 0 16px rgba(255,255,255,0.35))}}
                                                        .card-object.card-spirit::before{transform-origin:center center;animation:spiritBorderPulse 4.2s linear infinite !important}
                                                        @media (max-width: 210px), (max-height: 240px){.card-scene{transform:none}}
                                                        .card-object.is-flipped{--flipY:180deg}
                                                        .card-face{position:absolute;inset:0;-webkit-backface-visibility:hidden;backface-visibility:hidden;border-radius:20px;overflow:hidden;background:#050505;transform:translateZ(0)}
                                                        .card-face.face-front{transform:rotateY(0deg) translateZ(0) !important}
                                                        .card-face img{border-radius:20px;clip-path:inset(0 round 20px)}
                                                        .card-face > div[class*="bg-gradient"],.card-face > div[style*="background"]{border-radius:20px;clip-path:inset(0 round 20px)}
                                                        .card-face.face-back{transform:rotateY(180deg) translateZ(0) !important}
                                                        </style>`;

                const mintVfxCSS = `<style>
                                                        html{width:100%;height:100%;font-size:16px;-webkit-text-size-adjust:none;text-size-adjust:none}
                                                        body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;font-size:16px;background:#000;color:#fff;margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;height:auto;overflow:auto;padding:20px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
                                                        @media (max-width: 420px), (max-height: 420px){body{padding:8px}}
                                                        .mint-stage{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
                                                        .mint-scale{transform-origin:center center;will-change:transform}
                                                        .badge-medal{display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.22);border:1px solid rgba(255,255,255,0.14);box-shadow:inset 0 0 0 1px rgba(0,0,0,0.35);border-radius:10px;overflow:hidden;outline:none;transform:translateZ(0);will-change:transform,filter}
                                                        .badge-medal img{width:100%;height:100%;display:block;object-fit:contain}
                                                        *,::before,::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:currentColor}
                                                        button{font:inherit;color:inherit;background:none;border:0;padding:0;margin:0;cursor:pointer;-webkit-appearance:none;appearance:none}
                                                        .hidden{display:none !important}
                                                        .flex{display:flex}
                                                        .grid{display:grid}
                                                        .flex-col{flex-direction:column}
                                                        .flex-1{flex:1 1 0%}
                                                        .flex-wrap{flex-wrap:wrap}
                                                        .items-center{align-items:center}
                                                        .items-start{align-items:flex-start}
                                                        .justify-center{justify-content:center}
                                                        .justify-between{justify-content:space-between}
                                                        .gap-1{gap:0.25rem}
                                                        .gap-2{gap:0.5rem}
                                                        .gap-3{gap:0.75rem}
                                                        .gap-4{gap:1rem}
                                                        .inline-block{display:inline-block}
                                                        .p-2{padding:0.5rem}
                                                        .p-2\.5{padding:0.625rem}
                                                        .p-3{padding:0.75rem}
                                                        .p-4{padding:1rem}
                                                        .p-5{padding:1.25rem}
                                                        .px-2{padding-left:0.5rem;padding-right:0.5rem}
                                                        .px-3{padding-left:0.75rem;padding-right:0.75rem}
                                                        .px-5{padding-left:1.25rem;padding-right:1.25rem}
                                                        .py-1{padding-top:0.25rem;padding-bottom:0.25rem}
                                                        .py-2{padding-top:0.5rem;padding-bottom:0.5rem}
                                                        .pb-6{padding-bottom:1.5rem}
                                                        .mb-1{margin-bottom:0.25rem}
                                                        .mb-2{margin-bottom:0.5rem}
                                                        .mb-3{margin-bottom:0.75rem}
                                                        .mb-0\\.5{margin-bottom:0.125rem}
                                                        .mb-4{margin-bottom:1rem}
                                                        .mb-5{margin-bottom:1.25rem}
                                                        .mt-auto{margin-top:auto}
                                                        .text-center{text-align:center}
                                                        .text-right{text-align:right}
                                                        .absolute{position:absolute}
                                                        .relative{position:relative}
                                                        .inset-0{top:0;right:0;bottom:0;left:0}
                                                        .w-full{width:100%}
                                                        .h-full{height:100%}
                                                        .w-2{width:0.5rem}
                                                        .h-2{height:0.5rem}
                                                        .w-5{width:1.25rem}
                                                        .h-5{height:1.25rem}
                                                        .h-px{height:1px}
                                                        .object-cover{object-fit:cover}
                                                        .object-contain{object-fit:contain}
                                                        .rounded-lg{border-radius:0.5rem}
                                                        .rounded-3xl{border-radius:1.5rem}
                                                        .rounded{border-radius:0.25rem}
                                                        .rounded-full{border-radius:9999px}
                                                        .border{border-width:1px}
                                                        .border-b{border-bottom-width:1px}
                                                        .z-0{z-index:0}
                                                        .z-10{z-index:10}
                                                        .z-20{z-index:20}
                                                        .uppercase{text-transform:uppercase}
                                                        .tracking-wider{letter-spacing:0.05em}
                                                        .tracking-widest{letter-spacing:0.1em}
                                                        .font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
                                                        .font-bold{font-weight:700}
                                                        .font-black{font-weight:900}
                                                        .italic{font-style:italic}
                                                        .leading-none{line-height:1}
                                                        .text-xs{font-size:0.75rem;line-height:1rem}
                                                        .text-sm{font-size:0.875rem;line-height:1.25rem}
                                                        .text-xl{font-size:1.25rem;line-height:1.75rem}
                                                        .text-2xl{font-size:1.5rem;line-height:2rem}
                                                        .text-3xl{font-size:1.875rem;line-height:2.25rem}
                                                        .text-white{color:#fff}
                                                        .text-white\\/70{color:rgba(255,255,255,0.70)}
                                                        .text-gray-300{color:#d1d5db}
                                                        .text-gray-400{color:#9ca3af}
                                                        .text-gray-500{color:#6b7280}
                                                        .opacity-70{opacity:0.70}
                                                        .grayscale{filter:grayscale(1)}
                                                        .backdrop-blur-md{-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}
                                                        .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4,0,0.2,1);transition-duration:150ms}
                                                        .drop-shadow-md{filter:drop-shadow(0 4px 3px rgba(0,0,0,0.25))}
                                                        .drop-shadow-lg{filter:drop-shadow(0 8px 10px rgba(0,0,0,0.35))}
                                                        .bg-white\\/5{background-color:rgba(255,255,255,0.05)}
                                                        .bg-white\\/10{background-color:rgba(255,255,255,0.10)}
                                                        .bg-black\\/20{background-color:rgba(0,0,0,0.20)}
                                                        .bg-black\\/30{background-color:rgba(0,0,0,0.30)}
                                                        .border-white\\/5{border-color:rgba(255,255,255,0.05)}
                                                        .border-white\\/10{border-color:rgba(255,255,255,0.10)}
                                                        .space-y-2> :not([hidden])~:not([hidden]){margin-top:0.5rem}
                                                        .space-y-3> :not([hidden])~:not([hidden]){margin-top:0.75rem}
                                                        .space-y-1\\.5> :not([hidden])~:not([hidden]){margin-top:0.375rem}
                                                        .grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
                                                        .grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
                                                        .bg-gradient-to-t{background-image:linear-gradient(to top,var(--tw-gradient-stops))}
                                                        .bg-gradient-to-r{background-image:linear-gradient(to right,var(--tw-gradient-stops))}
                                                        .bg-gradient-to-br{background-image:linear-gradient(to bottom right,var(--tw-gradient-stops))}
                                                        .from-black{--tw-gradient-from:#000;--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to,rgba(0,0,0,0))}
                                                        .from-gray-900{--tw-gradient-from:#111827;--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to,rgba(17,24,39,0))}
                                                        .via-transparent{--tw-gradient-stops:var(--tw-gradient-from),transparent,var(--tw-gradient-to,rgba(0,0,0,0))}
                                                        .via-gray-800{--tw-gradient-stops:var(--tw-gradient-from),#1f2937,var(--tw-gradient-to,rgba(31,41,55,0))}
                                                        .to-transparent{--tw-gradient-to:transparent}
                                                        .to-black{--tw-gradient-to:#000}
                                                        .to-black\\/60{--tw-gradient-to:rgba(0,0,0,0.6)}
                                                        .text-fennec{color:#FF6B35}
                                                        .text-spirit{background:linear-gradient(90deg,#ff0000,#ffff00,#00ff00,#00ffff,#0000ff,#ff00ff);background-size:200% auto;-webkit-background-clip:text;background-clip:text;color:transparent;animation:rainbowTextMove 3s linear infinite;font-weight:900}
                                                        @keyframes rainbowTextMove{to{background-position:200% center}}
                                                        .bg-fennec{background-color:#FF6B35}
                                                        .bg-fennec\/5{background-color:rgba(255,107,53,0.05)}
                                                        .bg-fennec\/10{background-color:rgba(255,107,53,0.10)}
                                                        .bg-fennec\/15{background-color:rgba(255,107,53,0.15)}
                                                        .bg-fennec\/20{background-color:rgba(255,107,53,0.20)}
                                                        .bg-fennec\/30{background-color:rgba(255,107,53,0.30)}
                                                        .border-fennec{border-color:#FF6B35}
                                                        .border-fennec\/30{border-color:rgba(255,107,53,0.30)}
                                                        .border-fennec\/50{border-color:rgba(255,107,53,0.50)}
                                                        .text-\\[8px\\]{font-size:8px}
                                                        .text-\\[9px\\]{font-size:9px}
                                                        .text-\\[10px\\]{font-size:10px}
                                                        .custom-scroll{overflow-y:auto;scrollbar-width:thin;scrollbar-color:#FF6B35 rgba(255,255,255,0.05)}
                                                        .custom-scroll::-webkit-scrollbar{width:4px}
                                                        .custom-scroll::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}
                                                        .custom-scroll::-webkit-scrollbar-thumb{background-color:#FF6B35;border-radius:10px}
                                                        .card-tab-btn{border:1px solid rgba(255,255,255,0.10) !important}
                                                        .card-tab-btn.active{border-color:rgba(255,107,53,0.45) !important}
                                                        .overlay{position:absolute;inset:0;border-radius:20px;clip-path:inset(0 round 20px);pointer-events:none;z-index:10;background:linear-gradient(to top,rgba(0,0,0,1) 0%,rgba(0,0,0,0) 55%,rgba(0,0,0,0.6) 100%)}
                                                        .card-glare{display:none}
                                                        .vfx-3d{position:absolute;inset:0;border-radius:inherit;pointer-events:none;z-index:13;display:block;opacity:calc(var(--vfx3d-opacity,0.24)*var(--vfx3d-mult,1));mix-blend-mode:screen;overflow:hidden}
                                                        .vfx-3d::before{content:"";position:absolute;inset:-30%;background:radial-gradient(circle at var(--mxp,50%) var(--myp,50%),rgba(var(--vfx-rgb,255,255,255),0.12),rgba(var(--vfx-rgb,255,255,255),0.06) 30%,transparent 65%),linear-gradient(135deg,transparent,rgba(var(--vfx-rgb2,255,255,255),0.04),transparent);filter:blur(6px) saturate(1.05) brightness(1.02);transform:translate3d(calc(var(--npx,0px)*0.8),calc(var(--npy,0px)*0.8),0);animation:vfx-pulse 4s ease-in-out infinite}
                                                        .vfx-3d::after{content:"";position:absolute;inset:-15%;background:radial-gradient(circle at var(--mxp,50%) var(--myp,50%),rgba(var(--vfx-rgb,255,255,255),0.18),rgba(var(--vfx-rgb2,255,255,255),0.08) 35%,transparent 55%),linear-gradient(90deg,rgba(255,255,255,0.08),transparent 40%,rgba(255,255,255,0.05) 60%,transparent);background-size:100% 100%,280% 280%;background-position:0 0,calc(var(--mxp,50%) * 1%) calc(var(--myp,50%) * 1%);mix-blend-mode:screen;filter:blur(2px);opacity:0.4;transform:translate3d(calc(var(--px,0px)*0.8),calc(var(--py,0px)*0.8),0) scale(1.02);animation:vfx-sheen 6s linear infinite,vfx-shimmer 3s ease-in-out infinite}
                                                        @keyframes vfx-sheen{0%{background-position:0 0,0% 0%,0 0}100%{background-position:0 0,200% 200%,0 0}}
                                                        @keyframes vfx-pulse{0%,100%{opacity:1;filter:blur(14px) saturate(1.6) brightness(1.3)}50%{opacity:0.9;filter:blur(16px) saturate(1.8) brightness(1.45)}}
                                                        @keyframes vfx-shimmer{0%,100%{opacity:0.95}50%{opacity:1.0}}
                                                        .vfx-webgl{position:absolute;inset:0;border-radius:inherit;pointer-events:none;z-index:13;overflow:hidden;display:block;opacity:calc(var(--vfxwebgl-opacity,0.18)*var(--vfxwebgl-mult,1));mix-blend-mode:screen}
                                                        .vfx-webgl canvas{width:100%;height:100%;display:block}
                                                        .card-object:not([data-vfx="ENGINEER"]) .vfx-3d,.card-object:not([data-vfx="ENGINEER"]) .vfx-webgl{display:none !important}
                                                        .overlay-MERCHANT ~ .vfx-webgl{--vfxwebgl-mult:0.80}
                                                        .overlay-KEEPER ~ .vfx-webgl{--vfxwebgl-mult:0.70}
                                                        .card-object[data-tier="3"] .overlay-ENGINEER ~ .vfx-webgl{--vfxwebgl-mult:1.13}
                                                        .card-object[data-tier="3"] .overlay-ENGINEER ~ .vfx-3d{--vfx3d-mult:1.24}
                                                        @keyframes cardHoloSheen{0%{background-position:-80% 50%,0% 50%}100%{background-position:180% 50%,0% 50%}}
                                                        .card-holo-sheen{display:none}
                                                        </style>

                                                        <script>
                                                        (function(){
                                                        function initVfxWebgl(object){
                                                          if(!object||object.__vfxWebgl) return;
                                                          const canvas=object.querySelector('.vfx-webgl canvas');
                                                          const wrap=canvas?canvas.parentElement:null;
                                                          if(!canvas||!wrap) return;
                                                          const gl=canvas.getContext('webgl',{alpha:true,premultipliedAlpha:true,antialias:true})||canvas.getContext('experimental-webgl');
                                                          if(!gl){wrap.style.opacity='0';return;}
                                                          const vertSrc='attribute vec2 aPos; varying vec2 vUv; void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.0,1.0); }';
                                                          const fragSrc=[
                                                          'precision highp float',
                                                          'varying vec2 vUv;',
                                                          'uniform vec2 uResolution;',
                                                          'uniform vec2 uPointer;',
                                                          'uniform vec2 uTilt;',
                                                          'uniform float uTime;',
                                                          'uniform vec3 uTint1;',
                                                          'uniform vec3 uTint2;',
                                                          'uniform float uStrength;',
                                                          'float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }',
                                                          'float noise(vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hash(i); float b=hash(i+vec2(1.0,0.0)); float c=hash(i+vec2(0.0,1.0)); float d=hash(i+vec2(1.0,1.0)); vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }',
                                                          'float fbm(vec2 p){ float v=0.0; float a=0.5; for(int i=0;i<4;i++){ v += a*noise(p); p*=2.0; a*=0.5; } return v; }',
                                                          'void main(){',
                                                          '  vec2 uv=vUv;',
                                                          '  vec2 p=uPointer;',
                                                          '  vec2 d=uv-p;',
                                                          '  float dist=length(d);',
                                                          '  vec2 e=vec2(1.0)/max(uResolution, vec2(1.0));',
                                                          '  float h0 = fbm(uv*7.0 + vec2(uTime*0.05, -uTime*0.04));',
                                                          '  float hx1 = fbm((uv+vec2(e.x,0.0))*7.0 + vec2(uTime*0.05, -uTime*0.04));',
                                                          '  float hx2 = fbm((uv-vec2(e.x,0.0))*7.0 + vec2(uTime*0.05, -uTime*0.04));',
                                                          '  float hy1 = fbm((uv+vec2(0.0,e.y))*7.0 + vec2(uTime*0.05, -uTime*0.04));',
                                                          '  float hy2 = fbm((uv-vec2(0.0,e.y))*7.0 + vec2(uTime*0.05, -uTime*0.04));',
                                                          '  vec2 g = vec2(hx1-hx2, hy1-hy2);',
                                                          '  vec3 n = normalize(vec3(-g*16.0, 1.0));',
                                                          '  vec3 v = vec3(0.0, 0.0, 1.0);',
                                                          '  vec3 l = normalize(vec3(-d*2.7 + uTilt*0.55, 0.65));',
                                                          '  float ndl = max(dot(n,l), 0.0);',
                                                          '  vec3 h = normalize(l+v);',
                                                          '  float spec = pow(max(dot(n,h), 0.0), 36.0);',
                                                          '  float fres = pow(1.0 - max(dot(n,v), 0.0), 4.0);',
                                                          '  float bands = sin((uv.x*6.0 + uv.y*4.0 + h0*1.4)*6.283 + uTime*0.85 + uTilt.x*0.6);',
                                                          '  float t = 0.5 + 0.5*bands;',
                                                          '  vec3 tint = mix(uTint1, uTint2, t);',
                                                          '  float grain = hash(uv * (uResolution*0.12) + vec2(uTime*0.9, -uTime*0.7));',
                                                          '  grain = pow(grain, 14.0) * (0.26 + 1.85*spec);',
                                                          '  float streak = exp(-abs(d.x*1.45 + d.y*0.22 + uTilt.y*0.12)*18.0) * exp(-dist*dist*9.0);',
                                                          '  float edge = smoothstep(0.0, 0.05, min(min(uv.x, 1.0-uv.x), min(uv.y, 1.0-uv.y)));',
                                                          '  float a = uStrength * edge * (spec*1.10 + ndl*0.10 + fres*0.30 + streak*0.22 + grain*0.62);',
                                                          '  a = clamp(a, 0.0, 1.0);',
                                                          '  vec3 col = tint*(spec*1.25 + fres*0.25 + ndl*0.12) + vec3(1.0)*spec*0.52 + tint*grain*0.9;',
                                                          '  col *= (0.55 + 0.45*smoothstep(0.42, 0.0, dist));',
                                                          '  gl_FragColor = vec4(col, a);',
                                                          '}'
                                                          ].join('\n');

                                                          function compile(type, src){
                                                            const sh=gl.createShader(type);
                                                            gl.shaderSource(sh, src);
                                                            gl.compileShader(sh);
                                                            if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){gl.deleteShader(sh);return null;}
                                                            return sh;
                                                          }
                                                          const vs=compile(gl.VERTEX_SHADER, vertSrc);
                                                          const fs=compile(gl.FRAGMENT_SHADER, fragSrc);
                                                          if(!vs||!fs){wrap.style.opacity='0';return;}
                                                          const prog=gl.createProgram();
                                                          gl.attachShader(prog, vs);
                                                          gl.attachShader(prog, fs);
                                                          gl.linkProgram(prog);
                                                          if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){wrap.style.opacity='0';return;}
                                                          const buf=gl.createBuffer();
                                                          gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                                                          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,3,-1,-1,3]), gl.STATIC_DRAW);
                                                          const aPos=gl.getAttribLocation(prog,'aPos');
                                                          const uResolution=gl.getUniformLocation(prog,'uResolution');
                                                          const uPointer=gl.getUniformLocation(prog,'uPointer');
                                                          const uTilt=gl.getUniformLocation(prog,'uTilt');
                                                          const uTime=gl.getUniformLocation(prog,'uTime');
                                                          const uTint1=gl.getUniformLocation(prog,'uTint1');
                                                          const uTint2=gl.getUniformLocation(prog,'uTint2');
                                                          const uStrength=gl.getUniformLocation(prog,'uStrength');

                                                          const archetype=(object.dataset&&(object.dataset.vfx||object.dataset.archetype))?(object.dataset.vfx||object.dataset.archetype):'';
                                                          const tier=(object.dataset&&object.dataset.tier)?Number(object.dataset.tier)||0:0;
                                                          let tint1=[1,1,1], tint2=[1,1,1], mult=1;
                                                          if(archetype==='MERCHANT'){tint1=[1.0,0.82,0.15];tint2=[1.0,1.0,1.0];mult=0.80;}
                                                          else if(archetype==='KEEPER'){tint1=[0.98,0.57,0.24];tint2=[1.0,1.0,1.0];mult=0.60;}
                                                          else if(archetype==='SHAMAN'){tint1=[0.66,0.33,0.97];tint2=[0.23,0.51,0.96];}
                                                          else if(archetype==='LORD'){tint1=[0.02,0.71,0.83];tint2=[1.0,1.0,1.0];}
                                                          else if(archetype==='ENGINEER'){tint1=[0.0,1.0,0.67];tint2=[1.0,0.0,0.31];mult=(tier===3?1.26:1.00);}
                                                          else if(archetype==='WALKER'){tint1=[0.23,0.51,0.96];tint2=[1.0,1.0,1.0];}
                                                          else if(archetype==='DRIFTER'){tint1=[1.0,0.63,0.0];tint2=[1.0,1.0,1.0];}
                                                          else if(archetype==='SINGULARITY'){tint1=[1.0,1.0,1.0];tint2=[0.66,0.33,0.97];}
                                                          const tierStrength=tier===1?0.55:(tier===2?0.78:1.00);
                                                          const strength=tierStrength*mult;
                                                          const state={gl,prog,buf,aPos,uResolution,uPointer,uTilt,uTime,uTint1,uTint2,uStrength,pointer:[0.5,0.5],tilt:[0,0],start:performance.now(),lastSize:[0,0],dpr:Math.min(2,window.devicePixelRatio||1),tint1,tint2,strength};
                                                          object.__vfxWebgl=state;

                                                          state.cssSize=[0,0];
                                                          const updateSize=()=>{const cw=canvas.clientWidth||(wrap?wrap.clientWidth:0);const ch=canvas.clientHeight||(wrap?wrap.clientHeight:0);state.cssSize[0]=cw;state.cssSize[1]=ch;};
                                                          updateSize();
                                                          if(typeof ResizeObserver!=='undefined'){state.ro=new ResizeObserver(updateSize);try{state.ro.observe(canvas);}catch(e){}}

                                                          function render(){
                                                            if(!canvas.isConnected){state.raf=0;if(state.ro){try{state.ro.disconnect();}catch(e){}}return;}
                                                            const cw=state.cssSize[0]||canvas.clientWidth||1;
                                                            const ch=state.cssSize[1]||canvas.clientHeight||1;
                                                            const w=Math.max(1,Math.round(cw*state.dpr));
                                                            const h=Math.max(1,Math.round(ch*state.dpr));
                                                            if(w!==state.lastSize[0]||h!==state.lastSize[1]){canvas.width=w;canvas.height=h;state.lastSize[0]=w;state.lastSize[1]=h;gl.viewport(0,0,w,h);}
                                                            gl.useProgram(prog);
                                                            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                                                            gl.enableVertexAttribArray(aPos);
                                                            gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
                                                            gl.uniform2f(uResolution, canvas.width, canvas.height);
                                                            gl.uniform2f(uPointer, state.pointer[0], state.pointer[1]);
                                                            gl.uniform2f(uTilt, state.tilt[0], state.tilt[1]);
                                                            gl.uniform1f(uTime, (performance.now()-state.start)/1000);
                                                            gl.uniform3f(uTint1, state.tint1[0], state.tint1[1], state.tint1[2]);
                                                            gl.uniform3f(uTint2, state.tint2[0], state.tint2[1], state.tint2[2]);
                                                            gl.uniform1f(uStrength, state.strength);
                                                            gl.clearColor(0,0,0,0);
                                                            gl.clear(gl.COLOR_BUFFER_BIT);
                                                            gl.drawArrays(gl.TRIANGLES,0,3);
                                                            state.raf=requestAnimationFrame(render);
                                                          }
                                                          state.raf=requestAnimationFrame(render);
                                                        }
                                                        function updateVfxWebgl(object,xNorm,yNorm,tiltX,tiltY){
                                                          const s=object&&object.__vfxWebgl;
                                                          if(!s) return;
                                                          s.pointer[0]=Math.max(0,Math.min(1,xNorm));
                                                          s.pointer[1]=Math.max(0,Math.min(1,yNorm));
                                                          s.tilt[0]=Math.max(-1,Math.min(1,tiltX));
                                                          s.tilt[1]=Math.max(-1,Math.min(1,tiltY));
                                                        }
                                                        window.__mintInitVfxWebgl=initVfxWebgl;
                                                        window.__mintUpdateVfxWebgl=updateVfxWebgl;
                                                        })();
                                                        <\/script>`;

                const mint3DScript = `<script>
                                            (function(){
                                            const scene=document.querySelector('.card-scene');
                                            const card=document.getElementById('card3D');
                                            if(!scene||!card)return;
                                            const scaleWrap=document.querySelector('.mint-scale');
                                            function applyViewportScale(){
                                              if(!scaleWrap) return;
                                              const vw=Math.max(1, window.innerWidth||0);
                                              const vh=Math.max(1, window.innerHeight||0);
                                              const cs=getComputedStyle(document.body);
                                              const padX=(parseFloat(cs.paddingLeft)||0)+(parseFloat(cs.paddingRight)||0);
                                              const padY=(parseFloat(cs.paddingTop)||0)+(parseFloat(cs.paddingBottom)||0);
                                              const availW=Math.max(1, vw-padX);
                                              const availH=Math.max(1, vh-padY);
                                              const baseW=scene.offsetWidth||320;
                                              const baseH=scene.offsetHeight||490;
                                              const sContain=Math.min(1, availW/baseW, availH/baseH);
                                              const ar=vw/Math.max(1, vh);
                                              const isSquare=ar>0.82 && ar<1.22;
                                              const sRaw=isSquare ? (sContain*0.98) : sContain;
                                              const s=Math.min(1.25, sRaw);
                                              scaleWrap.style.transform='scale('+s.toFixed(4)+')';
                                            }
                                            applyViewportScale();
                                            window.addEventListener('resize', applyViewportScale);
                                            window.addEventListener('orientationchange', applyViewportScale);
                                            const initVfx=window.__mintInitVfxWebgl;
                                            const updateVfx=window.__mintUpdateVfxWebgl;
                                            if(initVfx) initVfx(card);
                                            const tier=${tier};
                                            const tiltStrength=tier===0?4:tier===1?7:tier===2?10:13;
                                            const idleAmp=tier===0?2:tier===1?3:tier===2?4.5:6;
                                            const state={hover:false,lastMove:0,raf:0,start:performance.now(),mxp:50,myp:50,targetMxp:50,targetMyp:50};

                                            let rect=null;
                                            let rectAt=0;
                                            let movePending=false;
                                            let lastMoveEvt=null;
                                            function readRect(){rect=scene.getBoundingClientRect();rectAt=performance.now();}

                                            function startTick(){
                                              if(!state.hover) return;
                                              if(state.raf) return;
                                              if(card.__flipAnimating) return;
                                              if(card.classList.contains('is-flipped')) return;
                                              state.raf=requestAnimationFrame(tick);
                                            }

                                            function clearTilt(){
                                                card.style.removeProperty('transition');
                                                card.style.setProperty('--tiltX','0deg');
                                                card.style.setProperty('--tiltY','0deg');
                                                card.style.removeProperty('--mxp');
                                                card.style.removeProperty('--myp');
                                                card.style.removeProperty('--px');
                                                card.style.removeProperty('--py');
                                                card.style.removeProperty('--npx');
                                                card.style.removeProperty('--npy');
                                                state.mxp=state.myp=state.targetMxp=state.targetMyp=50;
                                            }

                                            function applyPose(mxp,myp,fromMouse){
                                                if(card.__flipAnimating) return;
                                                if(card.classList.contains('is-flipped')) return;
                                                const nx=(mxp-50)/50;
                                                const ny=(myp-50)/50;
                                                card.style.setProperty('--mxp',mxp.toFixed(2)+'%');
                                                card.style.setProperty('--myp',myp.toFixed(2)+'%');
                                                card.style.setProperty('--px',(nx*11).toFixed(2)+'px');
                                                card.style.setProperty('--py',(ny*11).toFixed(2)+'px');
                                                card.style.setProperty('--npx',(nx*4).toFixed(2)+'px');
                                                card.style.setProperty('--npy',(ny*4).toFixed(2)+'px');
                                                card.style.setProperty('--tiltX',(-ny*tiltStrength).toFixed(2)+'deg');
                                                card.style.setProperty('--tiltY',(nx*tiltStrength).toFixed(2)+'deg');
                                                if(updateVfx) updateVfx(card, mxp/100, 1-(myp/100), nx, -ny);
                                            }

                                            function tick(){
                                                if(!state.hover){state.raf=0;return;}
                                                if(card.__flipAnimating){state.raf=0;return;}
                                                if(card.classList.contains('is-flipped')){state.raf=0;return;}
                                                state.raf=requestAnimationFrame(tick);
                                                const now=performance.now();
                                                const idle=now-state.lastMove>4000;
                                                const t=(now-state.start)/1000;
                                                const desiredMxp=idle?50+Math.sin(t*0.55)*idleAmp:state.targetMxp;
                                                const desiredMyp=idle?50+Math.cos(t*0.43)*(idleAmp*0.85):state.targetMyp;
                                                const lerp=idle?0.06:0.18;
                                                state.mxp+= (desiredMxp-state.mxp)*lerp;
                                                state.myp+= (desiredMyp-state.myp)*lerp;
                                                applyPose(state.mxp,state.myp,!idle);
                                            }

                                            scene.addEventListener('click',function(e){
                                                if(e && e.target && e.target.closest && (e.target.closest('.card-tab-btn'))) return;
                                                if(card.__flipAnimating) return;
                                                card.__flipAnimating=true;
                                                if(state.raf){cancelAnimationFrame(state.raf);state.raf=0;}
                                                clearTilt();
                                                requestAnimationFrame(function(){card.classList.toggle('is-flipped');});
                                                const onEnd=function(ev){
                                                    if(ev&&ev.propertyName&&ev.propertyName!=='transform')return;
                                                    card.__flipAnimating=false;
                                                    card.removeEventListener('transitionend',onEnd);
                                                    if(!card.classList.contains('is-flipped')) startTick();
                                                };
                                                card.addEventListener('transitionend',onEnd);
                                                setTimeout(function(){if(card.__flipAnimating){card.__flipAnimating=false;card.removeEventListener('transitionend',onEnd);}},1200);
                                            });

                                            scene.addEventListener('mousemove',function(e){
                                                if(card.__flipAnimating) return;
                                                if(card.classList.contains('is-flipped')) return;
                                                lastMoveEvt=e;
                                                state.hover=true;
                                                if(!state.raf) startTick();
                                                if(movePending) return;
                                                movePending=true;
                                                requestAnimationFrame(function(){
                                                  movePending=false;
                                                  const ev=lastMoveEvt;
                                                  if(!ev) return;
                                                  const now=performance.now();
                                                  if(!rect||(now-rectAt)>250) readRect();
                                                  if(!rect||!rect.width||!rect.height) return;
                                                  const mxp=Math.max(0,Math.min(100,((ev.clientX-rect.left)/rect.width)*100));
                                                  const myp=Math.max(0,Math.min(100,((ev.clientY-rect.top)/rect.height)*100));
                                                  state.lastMove=now;
                                                  state.targetMxp=mxp;
                                                  state.targetMyp=myp;
                                                });
                                            });

                                            scene.addEventListener('mouseenter',function(){
                                                state.hover=true;
                                                state.lastMove=performance.now();
                                                readRect();
                                                card.style.transition='transform 90ms linear';
                                                startTick();
                                            });

                                            scene.addEventListener('mouseleave',function(){
                                                state.hover=false;
                                                if(state.raf){cancelAnimationFrame(state.raf);state.raf=0;}
                                                clearTilt();
                                            });

                                            })();
                                            <\/script>`;

                const mintVfxScript = '';
                const htmlContent = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="Fennec ID - ${archetype.title}"><meta property="og:description" content="${tierLabelText ? `${tierLabelText} CLASS • ` : ''}${rarityName}"><meta property="og:image" content="${bgBase64}"><title>Fennec ID - ${archetype.title}</title>${styles}${imageEvolutionOverrideCSS}${imageEvolutionRetuneCSS}${mintCoreCardCSS}${mintVfxCSS}<style>.card-glare{display:none!important;opacity:0!important}</style></head><body><div class="mint-stage"><div class="mint-scale"><div class="card-scene"><div class="card-object ${rarityClass} ${metrics.hasFennecSoul ? 'fennec-pulse' : ''}" id="card3D" data-tier="${tier}" data-archetype="${visualKey}" data-vfx="${vfxKey}">${frontHTML}${backHTML}</div></div></div></div>${mintVfxScript}${mint3DScript}</body></html>`;

                return htmlContent;
            }

            async function mintAuditCard(event) {
                if (!auditIdentity) {
                    alert('Please load your Fennec ID first!');
                    return;
                }

                auditIdentity = applyParentOverridesToIdentity(auditIdentity);

                const btn = document.getElementById('mintBtn') || document.getElementById('fidUpdateBtn');
                if (!btn) {
                    if (typeof showNotification === 'function')
                        showNotification('Mint/Evolve button not found', 'error', 2500);
                    return;
                }

                const btnTextEl =
                    document.getElementById('mintBtnText') || document.getElementById('fidUpdateBtnText') || btn;
                const originalText = btnTextEl.innerHTML;
                let restoreHtml = originalText;
                btnTextEl.textContent = 'GENERATING HTML...';
                btn.disabled = true;

                try {
                    const fetchWithTimeout = async (url, options, timeoutMs) => {
                        const controller = new AbortController();
                        const timer = setTimeout(() => controller.abort(), timeoutMs);
                        try {
                            const res = await fetch(url, { ...(options || {}), signal: controller.signal });
                            return res;
                        } finally {
                            clearTimeout(timer);
                        }
                    };

                    // ИСПРАВЛЕНИЕ: Проверяем доступность BACKEND_URL
                    if (typeof BACKEND_URL === 'undefined') {
                        throw new Error('BACKEND_URL is not defined. Please refresh the page.');
                    }

                    // ИСПРАВЛЕНИЕ: Проверяем доступность userAddress
                    if (!userAddress && !window.userAddress) {
                        throw new Error('Wallet not connected. Please connect your wallet first.');
                    }

                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    const currentUserAddress = userAddress || window.userAddress;
                    // 1. ИСПРАВЛЕНИЕ: Определяем фон карточки по званию (как в renderAudit)
                    // ИСПРАВЛЕНИЕ: Определяем фон карточки по baseKey
                    let bgImage = 'img/drifter.png';
                    const k = auditIdentity.archetype.baseKey || 'DRIFTER'; // Fallback

                    if (k === 'SINGULARITY') bgImage = 'img/singularity.png';
                    else if (k === 'PRIME') bgImage = 'img/prime.png';
                    else if (k === 'LORD') bgImage = 'img/oasis.png';
                    else if (k === 'WALKER') bgImage = 'img/walker.png';
                    else if (k === 'KEEPER') bgImage = 'img/keeper.png';
                    else if (k === 'SHAMAN') bgImage = 'img/shaman.png';
                    else if (k === 'ENGINEER') bgImage = 'img/engineer.png';
                    else if (k === 'MERCHANT') bgImage = 'img/merchant.png';
                    else bgImage = 'img/drifter.png';

                    console.log(`🎴 Mint image for "${auditIdentity.archetype.title}" (baseKey: ${k}): ${bgImage}`);

                    // 2. Генерируем HTML код карточки
                    const discountWhyEl = document.getElementById('discountWhy');
                    const fennecWalletOnly =
                        Number(
                            auditIdentity?.metrics?.fennecWalletBalance ??
                                auditIdentity?.metrics?.fennec_wallet_balance ??
                                0
                        ) || 0;
                    const fennecLpValueUSD = Number(auditIdentity?.metrics?.fennecLpValueUSD || 0) || 0;
                    const hasBoxes = !!(
                        auditIdentity?.metrics?.hasFennecBoxes ||
                        auditIdentity?.metrics?.has_fennec_boxes ||
                        auditIdentity?.metrics?.fennecBoxesCount > 0 ||
                        auditIdentity?.metrics?.fennec_boxes_count > 0
                    );
                    const eligibleNow = hasBoxes || fennecWalletOnly >= 100 || fennecLpValueUSD >= 1;
                    if (discountWhyEl && window.__discountCheckPassed !== true && eligibleNow) {
                        discountWhyEl.textContent = 'Discount available: click CHECK DISCOUNT ELIGIBILITY to unlock.';
                    }

                    const mintChildLibRef = String(
                        localStorage.getItem('fennec_mint_child_lib') ||
                            MINT_CHILD_FENNEC_LIB ||
                            FALLBACK_CHILD_LIB ||
                            ''
                    ).trim();
                    const mintChildConfigRef = String(
                        localStorage.getItem('fennec_mint_child_config') ||
                            MINT_CHILD_FENNEC_CONFIG ||
                            FALLBACK_CHILD_CONFIG ||
                            ''
                    ).trim();
                    const mintChildManifestRef = String(
                        localStorage.getItem('fennec_mint_child_manifest') ||
                            MINT_CHILD_FENNEC_MANIFEST ||
                            FALLBACK_MANIFEST_REF ||
                            DEFAULT_MANIFEST_URL ||
                            ''
                    ).trim();

                    let resolvedLibRef = mintChildLibRef;
                    let resolvedConfigRef = mintChildConfigRef;
                    if (mintChildManifestRef && (!resolvedLibRef || !resolvedConfigRef)) {
                        try {
                            const manRes = await fetchWithTimeout(mintChildManifestRef, { cache: 'no-store' }, 4500);
                            if (manRes && manRes.ok) {
                                const m = await manRes.json().catch(() => null);
                                const latest =
                                    m && typeof m === 'object' && m.latest && typeof m.latest === 'object'
                                        ? m.latest
                                        : m;
                                const libCandidate = String(
                                    (latest &&
                                        (latest.lib ||
                                            latest.libId ||
                                            latest.library ||
                                            latest.libraryId ||
                                            latest.fennecLib)) ||
                                        ''
                                ).trim();
                                const cfgCandidate = String(
                                    (latest &&
                                        (latest.config ||
                                            latest.configId ||
                                            latest.configuration ||
                                            latest.configurationId ||
                                            latest.fennecConfig)) ||
                                        ''
                                ).trim();
                                if (!resolvedLibRef && libCandidate) resolvedLibRef = libCandidate;
                                if (!resolvedConfigRef && cfgCandidate) resolvedConfigRef = cfgCandidate;
                            }
                        } catch (e) {}
                    }

                    let htmlCode = generateRecursiveChildHTML(auditIdentity, {
                        libRef: resolvedLibRef,
                        configRef: resolvedConfigRef,
                        manifestRef: mintChildManifestRef,
                        oracleEndpoint: BACKEND_URL,
                        oracleAction: 'fractal_audit',
                        pubkey: userPubkey
                    });

                    // 2.1 Provenance: hash HTML + request server signature
                    const htmlBytes = new TextEncoder().encode(htmlCode);
                    const htmlHashBuf = await crypto.subtle.digest('SHA-256', htmlBytes);
                    const htmlHashHex = Array.from(new Uint8Array(htmlHashBuf))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');

                    const provenanceClaim = {
                        schema: 'fennec.provenance.v1',
                        kind: 'mint',
                        chain: 'fractal-bitcoin',
                        address: currentUserAddress,
                        archetype: {
                            baseKey: auditIdentity?.archetype?.baseKey || '',
                            title: auditIdentity?.archetype?.title || ''
                        },
                        tier: auditIdentity?.archetype?.tierLevel ?? null,
                        html_sha256: htmlHashHex
                    };

                    btnTextEl.textContent = 'SIGNING PROVENANCE...';

                    const provHttpRes = await fetchWithTimeout(
                        `${BACKEND_URL}?action=sign_provenance`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-public-key': userPubkey,
                                'x-address': currentUserAddress
                            },
                            body: JSON.stringify({ payload: provenanceClaim })
                        },
                        25000
                    );

                    if (!provHttpRes.ok) {
                        const errorText = await provHttpRes.text().catch(() => '');
                        throw new Error(
                            `sign_provenance failed: ${provHttpRes.status} ${provHttpRes.statusText}. ${errorText}`
                        );
                    }

                    const provRes = await provHttpRes.json().catch(e => {
                        throw new Error(`Failed to parse sign_provenance response: ${e.message || e.toString()}`);
                    });

                    if (!provRes || provRes.code !== 0 || !provRes.data) {
                        throw new Error(provRes?.error || provRes?.msg || 'Failed to sign provenance');
                    }

                    const provenanceJson = JSON.stringify(provRes.data);
                    const provenanceJsonSafe = provenanceJson.replace(/</g, '\\u003c');

                    // 3. Кодируем HTML в Base64 для отправки
                    const provenanceTag =
                        '<scr' +
                        'ipt type="application/json" id="fennec-provenance">' +
                        provenanceJsonSafe +
                        '</scr' +
                        'ipt>';

                    const htmlCodeWithProvenance = htmlCode.includes('</body>')
                        ? htmlCode.replace('</body>', `${provenanceTag}</body>`)
                        : htmlCode + provenanceTag;

                    const base64Content = btoa(unescape(encodeURIComponent(htmlCodeWithProvenance)));
                    const base64SizeBytes = (base64Content.length * 3) / 4; // Base64 увеличивает размер на ~33%
                    const maxSizeBytes = 365 * 1024; // 365 кБ
                    const sizeKB = (base64SizeBytes / 1024).toFixed(2);

                    console.log(`📦 Card size: ${sizeKB} KB (max: 365 KB)`);

                    // ИСПРАВЛЕНИЕ: Проверяем размер перед отправкой (максимум 365 кБ)
                    if (base64SizeBytes > maxSizeBytes) {
                        throw new Error(
                            `Card too large: ${sizeKB} KB (max: 365 KB). Please try again or contact support.`
                        );
                    }

                    // 4. Отправляем ордер
                    btnTextEl.textContent = `CREATING ORDER... (${sizeKB} KB)`;

                    const YOUR_WALLET = 'bc1pe46pjefdel9jnue8e5459ltycng99er2pfxu7hs5yvhae54y802ssmynjt';
                    const BASE_PRICE_FB = 1; // Базовая цена: 1 FB

                    // ИСПРАВЛЕНИЕ: Проверяем условия для скидки 50%
                    // Скидка активируется ТОЛЬКО после успешного CHECK DISCOUNT
                    const hasDiscount = window.__discountCheckPassed === true && eligibleNow;
                    const hasDiscountFinal = hasDiscount;
                    // ИСПРАВЛЕНИЕ: Базовая цена 1 FB, со скидкой 0.5 FB (50% скидка)
                    // ВРЕМЕННО: Минт бесплатный (SERVICE_FEE = 0), но цены отображаются для будущего включения
                    const SERVICE_FEE = 0; // ВРЕМЕННО БЕСПЛАТНО: hasDiscountFinal ? 50000000 : 100000000; // 50% скидка: 0.5 FB вместо 1 FB
                    const priceText = hasDiscountFinal ? '0.5 FB (50% OFF!)' : '1 FB';

                    // ИСПРАВЛЕНИЕ: Восстанавливаем цену на кнопке после минта/ошибки по фактической eligibility
                    restoreHtml =
                        btn && btn.id === 'fidUpdateBtn'
                            ? originalText
                            : hasDiscountFinal
                              ? '<span style="text-decoration: line-through; opacity: 0.6;">1 FB</span> <span style="font-weight: bold;">0.5 FB (50% OFF!)</span>'
                              : '1 FB';

                    const inscriptionBody = {
                        receiveAddress: currentUserAddress,
                        feeRate: 5,
                        outputValue: 546,
                        files: [
                            {
                                filename: 'fennec_id.html',
                                dataURL: `data:text/html;base64,${base64Content}`
                            }
                        ],
                        devAddress: YOUR_WALLET,
                        devFee: SERVICE_FEE
                    };

                    const res = await fetchWithTimeout(
                        `${BACKEND_URL}?action=create_inscription`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-public-key': userPubkey,
                                'x-address': currentUserAddress
                            },
                            body: JSON.stringify(inscriptionBody)
                        },
                        25000
                    );

                    // ИСПРАВЛЕНИЕ: Проверяем статус ответа перед парсингом JSON
                    if (!res.ok) {
                        const errorText = await res.text().catch(() => 'Unknown error');
                        throw new Error(`API request failed: ${res.status} ${res.statusText}. ${errorText}`);
                    }

                    const json = await res.json().catch(e => {
                        throw new Error(`Failed to parse API response: ${e.message || e.toString()}`);
                    });

                    if (json.code === 0) {
                        // ИСПРАВЛЕНИЕ: Проверяем наличие необходимых данных в ответе
                        if (!json.data) {
                            throw new Error('API response missing data field');
                        }

                        const orderId = json.data.orderId;
                        const payAddress = json.data.payAddress;
                        const totalAmount = json.data.amount;

                        if (!orderId || !payAddress || !totalAmount) {
                            throw new Error(
                                `API response missing required fields. OrderId: ${orderId}, PayAddress: ${payAddress}, Amount: ${totalAmount}`
                            );
                        }

                        // ИСПРАВЛЕНИЕ: Добавляем минт в список pending operations с htmlCode
                        if (typeof addPendingOperation === 'function') {
                            addPendingOperation({
                                type: 'mint',
                                orderId: orderId,
                                address: currentUserAddress,
                                payAddress: payAddress,
                                amount: totalAmount,
                                status: 'pending',
                                timestamp: Date.now(),
                                htmlCode: htmlCodeWithProvenance,
                                html_sha256: htmlHashHex,
                                provenance: provRes.data
                            });
                        }

                        // ИСПРАВЛЕНИЕ: Проверяем доступность UniSat перед отправкой
                        if (typeof window.unisat === 'undefined') {
                            throw new Error('UniSat wallet not found. Please install UniSat wallet extension.');
                        }

                        btnTextEl.textContent = 'OPENING WALLET...';
                        const feeRateOpt = Number(json.data?.feeRate || 0) || 0;
                        if (feeRateOpt > 0) {
                            await window.unisat.sendBitcoin(payAddress, totalAmount, { feeRate: feeRateOpt });
                        } else {
                            await window.unisat.sendBitcoin(payAddress, totalAmount);
                        }

                        // ИСПРАВЛЕНИЕ: Сохраняем информацию о минте для учета и возможности открыть карточку
                        const mintInfo = {
                            orderId: orderId,
                            address: currentUserAddress,
                            timestamp: Date.now(),
                            status: 'pending',
                            htmlCode: htmlCodeWithProvenance,
                            html_sha256: htmlHashHex,
                            provenance: provRes.data
                        };

                        // ИСПРАВЛЕНИЕ: Сохраняем в localStorage для учета всех минтов с уникальным ID
                        const allMints = JSON.parse(localStorage.getItem(fennecMintedCardsKey()) || '[]');
                        mintInfo.id = `mint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; // Уникальный ID
                        allMints.push(mintInfo);
                        localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(allMints));
                        console.log(`✅ Card minted and tracked. ID: ${mintInfo.id}, Order ID: ${orderId}`);

                        // ИСПРАВЛЕНИЕ: Восстанавливаем кнопку после минта
                        btnTextEl.innerHTML = restoreHtml;
                        btn.disabled = false;

                        if (typeof showNotification === 'function') {
                            showNotification(
                                "Payment sent! Your Interactive ID is being minted. Check 'Pending Operations' tab.",
                                'success',
                                4500
                            );
                        } else {
                            alert("Payment sent! Your Interactive ID is being minted. Check 'Pending Operations' tab.");
                        }
                    } else {
                        throw new Error(json.msg || 'Order failed');
                    }
                } catch (e) {
                    console.error('Minting error:', e);
                    // ИСПРАВЛЕНИЕ: Безопасная обработка ошибок - игнорируем объекты Event
                    let errorMessage = 'Unknown error occurred';

                    // Проверяем, что это не объект Event (ошибки загрузки изображений не должны прерывать процесс)
                    if (e instanceof Event) {
                        // Игнорируем события ошибок изображений - они уже обработаны в getOptimizedBase64
                        console.warn('Ignoring image loading event error - already handled');
                        // Не показываем ошибку пользователю для событий загрузки изображений
                        if (btn) {
                            btnTextEl.innerHTML = restoreHtml;
                            btn.disabled = false;
                        }
                        return; // Выходим без показа ошибки
                    } else if (e && typeof e === 'object') {
                        const candidates = [
                            e.message,
                            e.msg,
                            e.error,
                            e?.data?.message,
                            e?.data?.msg,
                            e?.data?.error,
                            e?.details?.message,
                            e?.details?.msg,
                            e?.details?.error
                        ].filter(Boolean);
                        if (candidates.length) {
                            errorMessage = String(candidates[0]);
                        } else if (e.toString && typeof e.toString === 'function') {
                            const str = e.toString();
                            if (str !== '[object Event]' && str !== '[object Object]' && str !== '[object Error]') {
                                errorMessage = str;
                            }
                        } else {
                            try {
                                const json = JSON.stringify(e);
                                if (json && json !== '{}' && json.length < 600) errorMessage = json;
                            } catch (_) {}
                        }
                    } else if (typeof e === 'string') {
                        errorMessage = e;
                    }

                    console.error('Error details:', {
                        message: errorMessage,
                        error: e,
                        errorType: typeof e,
                        isEvent: e instanceof Event,
                        stack: e?.stack
                    });

                    if (typeof showNotification === 'function') {
                        showNotification('Minting failed: ' + errorMessage, 'error', 5000);
                    } else {
                        alert('Minting failed: ' + errorMessage);
                    }
                    // ИСПРАВЛЕНИЕ: Восстанавливаем кнопку при ошибке
                    if (btn) {
                        btnTextEl.innerHTML = restoreHtml;
                        btn.disabled = false;
                    }
                }
            }

            window.burnAndRemintAuditCard = async function (event) {
                const btn = document.getElementById('fidUpdateBtn') || document.getElementById('mintBtn');
                const btnTextEl =
                    document.getElementById('fidUpdateBtnText') || document.getElementById('mintBtnText') || btn;
                const originalText = btnTextEl ? btnTextEl.innerHTML : '';

                try {
                    if (!userAddress && !window.userAddress) return window.connectWallet();
                    if (!window.unisat) {
                        alert('UniSat wallet not found');
                        return;
                    }

                    const currentAddr = String(userAddress || window.userAddress || '').trim();
                    window.__fennecChildDetectCache = window.__fennecChildDetectCache || {};

                    const isFennecChildHtml = html => {
                        const s = String(html || '');
                        if (!s) return false;
                        const hasLib = /<meta\s+name=["']fennec-lib["']\s+content=/i.test(s);
                        const hasCfg = /<meta\s+name=["']fennec-config["']\s+content=/i.test(s);
                        if (hasLib && hasCfg) return true;
                        if (/<title>\s*Fennec\s*ID\s*<\/title>/i.test(s) && /id=["']fennec-root["']/i.test(s))
                            return true;
                        return false;
                    };

                    const fetchInscriptionHtml = async inscriptionId => {
                        const id = String(inscriptionId || '').trim();
                        if (!id) return '';
                        if (
                            window.__fennecChildDetectCache &&
                            window.__fennecChildDetectCache[id] &&
                            window.__fennecChildDetectCache[id].html
                        )
                            return window.__fennecChildDetectCache[id].html;

                        const url = `${BACKEND_URL}?action=inscription_content&inscriptionId=${encodeURIComponent(id)}`;
                        const res = await fetch(url, { cache: 'force-cache' });
                        if (!res.ok) return '';
                        const j = await res.json().catch(() => null);
                        const data = j && typeof j === 'object' ? j.data || null : null;
                        const ct = String(data?.contentType || data?.content_type || '');
                        const html = String(data?.body || data?.contentBody || data?.content_body || '');
                        if (!html) return '';
                        const looksHtml =
                            /<\s*!doctype\s+html/i.test(html) || /<html\b/i.test(html) || /<meta\b/i.test(html);
                        if (
                            !looksHtml &&
                            !String(ct || '')
                                .toLowerCase()
                                .includes('text/')
                        )
                            return '';
                        try {
                            window.__fennecChildDetectCache[id] = window.__fennecChildDetectCache[id] || {};
                            window.__fennecChildDetectCache[id].html = html;
                        } catch (_) {}
                        return html;
                    };

                    let pickedHtml = '';
                    let inscriptionId = '';
                    let cachedWalletInscriptions = null;
                    let cachedWalletInscriptionsTotal = null;
                    try {
                        const stId = String(
                            (window.__fennecIdStatus && window.__fennecIdStatus.inscriptionId) || ''
                        ).trim();
                        if (stId) inscriptionId = stId;
                    } catch (_) {}

                    try {
                        const m0 = window.__lastMintedCard;
                        if (!inscriptionId)
                            inscriptionId = String(m0?.inscriptionId || m0?.inscription_id || '').trim();
                    } catch (_) {}

                    try {
                        if (inscriptionId) {
                            let ok = false;
                            try {
                                if (
                                    window.__fennecChildDetectCache[inscriptionId] &&
                                    'isChild' in window.__fennecChildDetectCache[inscriptionId]
                                ) {
                                    ok = !!window.__fennecChildDetectCache[inscriptionId].isChild;
                                } else {
                                    const html = await fetchInscriptionHtml(inscriptionId);
                                    ok = isFennecChildHtml(html);
                                    window.__fennecChildDetectCache[inscriptionId] =
                                        window.__fennecChildDetectCache[inscriptionId] || {};
                                    window.__fennecChildDetectCache[inscriptionId].isChild = ok;
                                    if (ok) pickedHtml = html;
                                }
                            } catch (_) {}
                            if (!ok) inscriptionId = '';
                        }
                    } catch (_) {
                        inscriptionId = '';
                    }

                    if (!inscriptionId && currentAddr) {
                        try {
                            const inscriptions = await window.unisat.getInscriptions(0, 100);
                            cachedWalletInscriptions = inscriptions;
                            cachedWalletInscriptionsTotal = Number(inscriptions?.total);
                            const list = Array.isArray(inscriptions?.list) ? inscriptions.list : [];
                            const htmlCards = list
                                .filter(
                                    x =>
                                        x &&
                                        (function () {
                                            const ct = String(x.contentType || '').toLowerCase();
                                            return !ct || ct.startsWith('text/');
                                        })() &&
                                        x.inscriptionId &&
                                        x.spent !== true
                                )
                                .sort((a, b) => (Number(b.timestamp || 0) || 0) - (Number(a.timestamp || 0) || 0));

                            const defaultScan = 8;
                            for (const it of htmlCards.slice(0, defaultScan)) {
                                const id = String(it.inscriptionId || '').trim();
                                if (!id) continue;
                                if (
                                    window.__fennecChildDetectCache[id] &&
                                    window.__fennecChildDetectCache[id].isChild === false
                                )
                                    continue;
                                const html = await fetchInscriptionHtml(id);
                                if (isFennecChildHtml(html)) {
                                    inscriptionId = id;
                                    pickedHtml = html;
                                    window.__fennecChildDetectCache[id] = window.__fennecChildDetectCache[id] || {};
                                    window.__fennecChildDetectCache[id].isChild = true;
                                    break;
                                } else {
                                    window.__fennecChildDetectCache[id] = window.__fennecChildDetectCache[id] || {};
                                    window.__fennecChildDetectCache[id].isChild = false;
                                }
                            }

                            if (!inscriptionId) {
                                const scanMore =
                                    localStorage.getItem('fennec_scan_more') === '1' ||
                                    confirm(
                                        `Could not auto-detect your Fennec ID yet. Scan more inscriptions? (may use more API)`
                                    );
                                if (scanMore) {
                                    for (const it of htmlCards.slice(defaultScan, 30)) {
                                        const id = String(it.inscriptionId || '').trim();
                                        if (!id) continue;
                                        if (
                                            window.__fennecChildDetectCache[id] &&
                                            window.__fennecChildDetectCache[id].isChild === false
                                        )
                                            continue;
                                        const html = await fetchInscriptionHtml(id);
                                        if (isFennecChildHtml(html)) {
                                            inscriptionId = id;
                                            pickedHtml = html;
                                            window.__fennecChildDetectCache[id] =
                                                window.__fennecChildDetectCache[id] || {};
                                            window.__fennecChildDetectCache[id].isChild = true;
                                            break;
                                        } else {
                                            window.__fennecChildDetectCache[id] =
                                                window.__fennecChildDetectCache[id] || {};
                                            window.__fennecChildDetectCache[id].isChild = false;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('Failed to scan inscriptions for Fennec child:', e);
                        }
                    }

                    const verifyOwnedInWallet = async id => {
                        const targetId = String(id || '').trim();
                        if (!targetId) return null;

                        const matchInList = list => {
                            const arr = Array.isArray(list) ? list : [];
                            for (const it of arr) {
                                const iid = String(it?.inscriptionId || '').trim();
                                if (!iid || iid !== targetId) continue;
                                if (it?.spent === true) return null;
                                const ownerAddr = String(it?.address || '').trim();
                                if (ownerAddr && currentAddr && ownerAddr !== currentAddr) return null;
                                return it;
                            }
                            return null;
                        };

                        try {
                            const hitCached = matchInList(cachedWalletInscriptions?.list);
                            if (hitCached) return hitCached;
                        } catch (_) {}

                        const PAGE = 100;
                        let cursor = 0;
                        let total =
                            typeof cachedWalletInscriptionsTotal === 'number' &&
                            Number.isFinite(cachedWalletInscriptionsTotal)
                                ? cachedWalletInscriptionsTotal
                                : null;
                        const maxScan = 300;
                        while (cursor < maxScan && (total === null || cursor < total)) {
                            const res = await window.unisat.getInscriptions(cursor, PAGE);
                            if (total === null) {
                                total = typeof res?.total === 'number' && Number.isFinite(res.total) ? res.total : null;
                            }
                            try {
                                cachedWalletInscriptions = res;
                                cachedWalletInscriptionsTotal = total;
                            } catch (_) {}
                            const hit = matchInList(res?.list);
                            if (hit) return hit;
                            cursor += PAGE;
                        }
                        return null;
                    };

                    if (!inscriptionId) {
                        const manual = String(
                            prompt(
                                'Could not find your Fennec ID inscription to burn.\n\nPaste inscriptionId manually (or Cancel):',
                                ''
                            ) || ''
                        ).trim();

                        if (manual) {
                            inscriptionId = manual;
                            try {
                                const html = await fetchInscriptionHtml(inscriptionId);
                                if (!isFennecChildHtml(html)) {
                                    const force = confirm(
                                        'This inscription does not look like a Fennec ID card. Burn anyway?'
                                    );
                                    if (!force) return;
                                } else {
                                    pickedHtml = html;
                                }
                            } catch (e) {
                                alert('Failed to load inscription content for the provided id.');
                                return;
                            }
                        } else {
                            alert('Could not find your Fennec ID inscription to burn.');
                            return;
                        }
                    }

                    try {
                        window.__lastMintedCard = {
                            ...(window.__lastMintedCard || {}),
                            inscriptionId,
                            address: currentAddr,
                            htmlCode: pickedHtml || (window.__lastMintedCard || {}).htmlCode
                        };
                    } catch (_) {}

                    if (!confirm('This will BURN your current Fennec ID inscription and REMINT a new one. Continue?')) {
                        return;
                    }

                    try {
                        const owned = await verifyOwnedInWallet(inscriptionId);
                        if (!owned) {
                            alert(
                                'Safety check failed: this inscriptionId was not found in your wallet as an unspent inscription for the current address.\n\nRefusing to burn.'
                            );
                            return;
                        }
                    } catch (e) {
                        alert(
                            'Safety check failed: could not verify inscription ownership via wallet API.\n\nRefusing to burn.'
                        );
                        return;
                    }

                    const lastBurnAddr = String(localStorage.getItem('fennec_burn_address') || '').trim();
                    const burnAddr = String(prompt('Enter burn address (bech32):', lastBurnAddr) || '').trim();
                    if (!burnAddr) return;
                    if (!burnAddr.startsWith('bc1') && !burnAddr.startsWith('tb1') && !burnAddr.startsWith('bcrt1')) {
                        alert('Invalid burn address');
                        return;
                    }
                    localStorage.setItem('fennec_burn_address', burnAddr);

                    if (btn) btn.disabled = true;
                    if (btnTextEl) btnTextEl.textContent = 'BUILDING TX...';
                    await checkFractalNetwork();

                    const fetchWithTimeout = async (url, options, timeoutMs) => {
                        const controller = new AbortController();
                        const timer = setTimeout(() => controller.abort(), timeoutMs);
                        try {
                            const res = await fetch(url, { ...(options || {}), signal: controller.signal });
                            return res;
                        } finally {
                            clearTimeout(timer);
                        }
                    };

                    if (!auditIdentity) {
                        try {
                            const tryParse = html => {
                                try {
                                    const s = String(html || '');
                                    const m = s.match(/<script[^>]*id=["']dna-data["'][^>]*>([\s\S]*?)<\/script>/i);
                                    if (!m || !m[1]) return null;
                                    const raw = String(m[1] || '').trim();
                                    if (!raw) return null;
                                    return JSON.parse(raw);
                                } catch (_) {
                                    return null;
                                }
                            };
                            let idObj = null;
                            if (pickedHtml) idObj = tryParse(pickedHtml);
                            if (!idObj && inscriptionId) {
                                const h = await fetchInscriptionHtml(inscriptionId);
                                if (h) {
                                    pickedHtml = pickedHtml || h;
                                    idObj = tryParse(h);
                                }
                            }
                            if (idObj && typeof idObj === 'object') auditIdentity = idObj;
                        } catch (_) {}
                    }
                    if (!auditIdentity) {
                        throw new Error('Please load your Fennec ID first!');
                    }
                    auditIdentity = applyParentOverridesToIdentity(auditIdentity);

                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();
                    const currentUserAddress = currentAddr;

                    const mintChildLibRef = String(
                        localStorage.getItem('fennec_mint_child_lib') ||
                            MINT_CHILD_FENNEC_LIB ||
                            FALLBACK_CHILD_LIB ||
                            ''
                    ).trim();
                    const mintChildConfigRef = String(
                        localStorage.getItem('fennec_mint_child_config') ||
                            MINT_CHILD_FENNEC_CONFIG ||
                            FALLBACK_CHILD_CONFIG ||
                            ''
                    ).trim();
                    const mintChildManifestRef = String(
                        localStorage.getItem('fennec_mint_child_manifest') ||
                            MINT_CHILD_FENNEC_MANIFEST ||
                            FALLBACK_MANIFEST_REF ||
                            DEFAULT_MANIFEST_URL ||
                            ''
                    ).trim();

                    let resolvedLibRef = mintChildLibRef;
                    let resolvedConfigRef = mintChildConfigRef;
                    if (mintChildManifestRef && (!resolvedLibRef || !resolvedConfigRef)) {
                        try {
                            const manRes = await fetchWithTimeout(mintChildManifestRef, { cache: 'no-store' }, 4500);
                            if (manRes && manRes.ok) {
                                const m = await manRes.json().catch(() => null);
                                const latest =
                                    m && typeof m === 'object' && m.latest && typeof m.latest === 'object'
                                        ? m.latest
                                        : m;
                                const libCandidate = String(
                                    (latest &&
                                        (latest.lib ||
                                            latest.libId ||
                                            latest.library ||
                                            latest.libraryId ||
                                            latest.fennecLib)) ||
                                        ''
                                ).trim();
                                const cfgCandidate = String(
                                    (latest &&
                                        (latest.config ||
                                            latest.configId ||
                                            latest.configuration ||
                                            latest.configurationId ||
                                            latest.fennecConfig)) ||
                                        ''
                                ).trim();
                                if (!resolvedLibRef && libCandidate) resolvedLibRef = libCandidate;
                                if (!resolvedConfigRef && cfgCandidate) resolvedConfigRef = cfgCandidate;
                            }
                        } catch (e) {}
                    }

                    let htmlCode = generateRecursiveChildHTML(auditIdentity, {
                        libRef: resolvedLibRef,
                        configRef: resolvedConfigRef,
                        manifestRef: mintChildManifestRef,
                        oracleEndpoint: BACKEND_URL,
                        oracleAction: 'fractal_audit',
                        pubkey: userPubkey
                    });

                    const htmlBytes = new TextEncoder().encode(htmlCode);
                    const htmlHashBuf = await crypto.subtle.digest('SHA-256', htmlBytes);
                    const htmlHashHex = Array.from(new Uint8Array(htmlHashBuf))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');

                    const provenanceClaim = {
                        schema: 'fennec.provenance.v1',
                        kind: 'mint',
                        chain: 'fractal-bitcoin',
                        address: currentUserAddress,
                        archetype: {
                            baseKey: auditIdentity?.archetype?.baseKey || '',
                            title: auditIdentity?.archetype?.title || ''
                        },
                        tier: auditIdentity?.archetype?.tierLevel ?? null,
                        html_sha256: htmlHashHex
                    };

                    if (btnTextEl) btnTextEl.textContent = 'SIGNING PROVENANCE...';
                    const provHttpRes = await fetchWithTimeout(
                        `${BACKEND_URL}?action=sign_provenance`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-public-key': userPubkey,
                                'x-address': currentUserAddress
                            },
                            body: JSON.stringify({ payload: provenanceClaim })
                        },
                        25000
                    );
                    if (!provHttpRes.ok) {
                        const errorText = await provHttpRes.text().catch(() => '');
                        throw new Error(
                            `sign_provenance failed: ${provHttpRes.status} ${provHttpRes.statusText}. ${errorText}`
                        );
                    }
                    const provRes = await provHttpRes.json().catch(e => {
                        throw new Error(`Failed to parse sign_provenance response: ${e.message || e.toString()}`);
                    });
                    if (!provRes || provRes.code !== 0 || !provRes.data) {
                        throw new Error(provRes?.error || provRes?.msg || 'Failed to sign provenance');
                    }

                    const provenanceJson = JSON.stringify(provRes.data);
                    const provenanceJsonSafe = provenanceJson.replace(/</g, '\\u003c');
                    const provenanceTag =
                        '<scr' +
                        'ipt type="application/json" id="fennec-provenance">' +
                        provenanceJsonSafe +
                        '</scr' +
                        'ipt>';

                    const htmlCodeWithProvenance = htmlCode.includes('</body>')
                        ? htmlCode.replace('</body>', `${provenanceTag}</body>`)
                        : htmlCode + provenanceTag;

                    const base64Content = btoa(unescape(encodeURIComponent(htmlCodeWithProvenance)));
                    const base64SizeBytes = (base64Content.length * 3) / 4;
                    const maxSizeBytes = 365 * 1024;
                    const sizeKB = (base64SizeBytes / 1024).toFixed(2);
                    if (base64SizeBytes > maxSizeBytes) {
                        throw new Error(`Card too large: ${sizeKB} KB (max: 365 KB).`);
                    }

                    const YOUR_WALLET = 'bc1pe46pjefdel9jnue8e5459ltycng99er2pfxu7hs5yvhae54y802ssmynjt';
                    const SERVICE_FEE = 0;
                    const inscriptionBody = {
                        receiveAddress: currentUserAddress,
                        feeRate: 5,
                        outputValue: 546,
                        files: [
                            {
                                filename: 'fennec_id.html',
                                dataURL: `data:text/html;base64,${base64Content}`
                            }
                        ],
                        devAddress: YOUR_WALLET,
                        devFee: SERVICE_FEE
                    };

                    const burnFeeRate = Number(localStorage.getItem('fennec_burn_fee_rate') || '') || 0;
                    const psbtFeeRate = burnFeeRate > 0 ? burnFeeRate : 5;

                    if (btnTextEl) btnTextEl.textContent = 'CREATING ORDER + PSBT...';
                    const psbtRes = await fetchWithTimeout(
                        `${BACKEND_URL}?action=burn_remint_psbt`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-public-key': userPubkey,
                                'x-address': currentUserAddress
                            },
                            body: JSON.stringify({
                                address: currentUserAddress,
                                pubkey: userPubkey,
                                burnAddress: burnAddr,
                                burnInscriptionId: inscriptionId,
                                feeRate: psbtFeeRate,
                                inscriptionBody
                            })
                        },
                        25000
                    );
                    if (!psbtRes.ok) {
                        const t = await psbtRes.text().catch(() => '');
                        throw new Error(`burn_remint_psbt failed: ${psbtRes.status}. ${t}`);
                    }
                    const psbtJson = await psbtRes.json().catch(e => {
                        throw new Error(`Failed to parse burn_remint_psbt response: ${e.message || e.toString()}`);
                    });
                    if (!psbtJson || psbtJson.code !== 0 || !psbtJson.data?.psbt) {
                        throw new Error(psbtJson?.msg || psbtJson?.error || 'burn_remint_psbt failed');
                    }

                    const orderId = psbtJson.data?.order?.orderId;
                    const payAddress = psbtJson.data?.order?.payAddress;
                    const totalAmount = psbtJson.data?.order?.amount;

                    if (typeof addPendingOperation === 'function' && orderId) {
                        addPendingOperation({
                            type: 'mint',
                            orderId: orderId,
                            address: currentUserAddress,
                            payAddress: payAddress,
                            amount: totalAmount,
                            status: 'pending',
                            timestamp: Date.now(),
                            htmlCode: htmlCodeWithProvenance,
                            html_sha256: htmlHashHex,
                            provenance: provRes.data,
                            burnInscriptionId: inscriptionId,
                            burnTo: burnAddr
                        });
                    }

                    if (btnTextEl) btnTextEl.textContent = 'SIGNING TX...';
                    const signedPsbt = await window.unisat.signPsbt(psbtJson.data.psbt, { autoFinalized: true });

                    if (btnTextEl) btnTextEl.textContent = 'BROADCASTING...';
                    let broadcastTxid = '';
                    if (typeof window.unisat.pushPsbt === 'function') {
                        broadcastTxid = await window.unisat.pushPsbt(signedPsbt);
                    } else {
                        const pushRes = await fetch(`${BACKEND_URL}?action=push_psbt`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-public-key': userPubkey,
                                'x-address': currentUserAddress
                            },
                            body: JSON.stringify({ psbt: signedPsbt })
                        });
                        const pushJson = await pushRes.json().catch(() => null);
                        broadcastTxid = String(pushJson?.data?.txid || pushJson?.data || pushJson?.txid || '').trim();
                    }

                    try {
                        const addr = (userAddress || window.userAddress || '').trim();
                        const all = JSON.parse(localStorage.getItem(fennecMintedCardsKey()) || '[]');
                        if (Array.isArray(all) && all.length) {
                            let changed = false;
                            for (const rec of all) {
                                if (!rec || typeof rec !== 'object') continue;
                                if (String(rec.address || '').trim() !== addr) continue;
                                if (String(rec.inscriptionId || '').trim() !== inscriptionId) continue;
                                if (!rec.burned) {
                                    rec.burned = true;
                                    rec.burnedAt = new Date().toISOString();
                                    rec.burnedTo = burnAddr;
                                    rec.burnedTxid = broadcastTxid || rec.burnedTxid;
                                    changed = true;
                                }
                            }
                            if (changed) localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(all));
                        }
                    } catch (e) {}

                    try {
                        if (window.__lastMintedCard && typeof window.__lastMintedCard === 'object') {
                            window.__lastMintedCard.burned = true;
                            window.__lastMintedCard.burnedTo = burnAddr;
                            window.__lastMintedCard.burnedTxid = broadcastTxid || window.__lastMintedCard.burnedTxid;
                        }
                    } catch (e) {}

                    try {
                        const mintInfo = {
                            orderId: orderId,
                            address: currentUserAddress,
                            timestamp: Date.now(),
                            status: 'pending',
                            htmlCode: htmlCodeWithProvenance,
                            html_sha256: htmlHashHex,
                            provenance: provRes.data,
                            burnedFrom: inscriptionId,
                            burnedTo: burnAddr,
                            burnTxid: broadcastTxid
                        };
                        const allMints = JSON.parse(localStorage.getItem(fennecMintedCardsKey()) || '[]');
                        mintInfo.id = `mint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        allMints.push(mintInfo);
                        localStorage.setItem(fennecMintedCardsKey(), JSON.stringify(allMints));
                    } catch (e) {}

                    try {
                        if (typeof checkPendingMints === 'function') {
                            setTimeout(() => {
                                try {
                                    checkPendingMints();
                                } catch (_) {}
                            }, 5000);
                        }
                    } catch (_) {}

                    if (typeof showNotification === 'function') {
                        showNotification(
                            `Transaction sent${broadcastTxid ? `: ${broadcastTxid}` : ''}. Mint order created. Check Pending Operations.`,
                            'success',
                            5500
                        );
                    } else {
                        alert('Transaction sent! Check Pending Operations.');
                    }

                    try {
                        if (btnTextEl) btnTextEl.innerHTML = originalText || 'BURN & REMINT';
                    } catch (_) {}
                    try {
                        if (btn) btn.disabled = false;
                    } catch (_) {}
                } catch (e) {
                    console.error('burnAndRemintAuditCard failed:', e);
                    alert('Burn & Remint failed: ' + (e?.message || String(e)));
                    try {
                        if (btnTextEl) btnTextEl.innerHTML = originalText || 'BURN & REMINT';
                    } catch (_) {}
                    try {
                        if (btn) btn.disabled = false;
                    } catch (_) {}
                }
            };

            window.saveMintChildRefs = function () {
                try {
                    const libEl = document.getElementById('mintChildLibRef');
                    const cfgEl = document.getElementById('mintChildConfigRef');
                    const manEl = document.getElementById('mintChildManifestRef');
                    const statusEl = document.getElementById('mintRefsStatus');

                    const lib = String(libEl?.value || '').trim();
                    const cfg = String(cfgEl?.value || '').trim();
                    const man = String(manEl?.value || '').trim();

                    if (lib) localStorage.setItem('fennec_mint_child_lib', lib);
                    else localStorage.removeItem('fennec_mint_child_lib');

                    if (cfg) localStorage.setItem('fennec_mint_child_config', cfg);
                    else localStorage.removeItem('fennec_mint_child_config');

                    if (man) localStorage.setItem('fennec_mint_child_manifest', man);
                    else localStorage.removeItem('fennec_mint_child_manifest');

                    const ok = (!!lib || !!man) && (!!cfg || !!man);
                    if (statusEl) {
                        statusEl.textContent = ok
                            ? 'Saved. Mint will use these refs immediately.'
                            : 'Saved. Need (lib or manifest) AND (config or manifest).';
                    }
                } catch (e) {}
            };

            window.useFallbackMintChildRefs = function () {
                try {
                    const lib = String(FALLBACK_CHILD_LIB || '').trim();
                    const cfg = String(
                        FALLBACK_CHILD_CONFIG ||
                            document.getElementById('mintChildConfigRef')?.value ||
                            localStorage.getItem('fennec_mint_child_config') ||
                            ''
                    ).trim();
                    const man = String(FALLBACK_MANIFEST_REF || DEFAULT_MANIFEST_URL || '').trim();

                    if (lib) localStorage.setItem('fennec_mint_child_lib', lib);
                    else localStorage.removeItem('fennec_mint_child_lib');

                    if (cfg) localStorage.setItem('fennec_mint_child_config', cfg);
                    else localStorage.removeItem('fennec_mint_child_config');

                    if (man) localStorage.setItem('fennec_mint_child_manifest', man);
                    else localStorage.removeItem('fennec_mint_child_manifest');

                    try {
                        const libEl = document.getElementById('mintChildLibRef');
                        const cfgEl = document.getElementById('mintChildConfigRef');
                        const manEl = document.getElementById('mintChildManifestRef');
                        if (libEl) libEl.value = lib;
                        if (cfgEl) cfgEl.value = cfg;
                        if (manEl) manEl.value = man;
                    } catch (_) {}

                    try {
                        const statusEl = document.getElementById('mintRefsStatus');
                        if (statusEl) statusEl.textContent = 'Fallback refs applied.';
                    } catch (_) {}
                } catch (_) {}
            };

            window.clearMintChildRefs = function () {
                try {
                    localStorage.removeItem('fennec_mint_child_lib');
                    localStorage.removeItem('fennec_mint_child_config');
                    localStorage.removeItem('fennec_mint_child_manifest');
                    try {
                        const libEl = document.getElementById('mintChildLibRef');
                        const cfgEl = document.getElementById('mintChildConfigRef');
                        const manEl = document.getElementById('mintChildManifestRef');
                        if (libEl) libEl.value = '';
                        if (cfgEl) cfgEl.value = '';
                        if (manEl) manEl.value = '';
                    } catch (_) {}
                    try {
                        const statusEl = document.getElementById('mintRefsStatus');
                        if (statusEl) statusEl.textContent = 'Refs cleared.';
                    } catch (_) {}
                } catch (_) {}
            };

            window.inscribeFennecCorePack = async function () {
                const statusEl = document.getElementById('mintRefsStatus');
                const setStatus = t => {
                    try {
                        if (statusEl) statusEl.textContent = String(t || '');
                    } catch (e) {}
                };

                try {
                    if (!userAddress && !window.userAddress) {
                        setStatus('Connect wallet first.');
                        if (typeof connectWallet === 'function') connectWallet();
                        return;
                    }

                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    const sleep = ms => new Promise(r => setTimeout(r, ms));
                    const toDataUrlFromText = (text, mime) => {
                        const mt = String(mime || 'text/plain');
                        const b64 = btoa(unescape(encodeURIComponent(String(text || ''))));
                        return `data:${mt};base64,${b64}`;
                    };
                    const fetchText = async url => {
                        const res = await fetch(url, { cache: 'no-store' });
                        if (!res.ok) throw new Error(`Fetch failed ${res.status}: ${url}`);
                        return await res.text();
                    };
                    const createOrder = async files => {
                        const createRes = await fetch(`${BACKEND_URL}?action=create_inscription`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                receiveAddress: userAddress || window.userAddress,
                                feeRate: 2,
                                outputValue: 546,
                                files
                            })
                        }).then(r => r.json());
                        if (!createRes || createRes.code !== 0)
                            throw new Error(createRes?.msg || 'Failed to create inscription');
                        return createRes;
                    };
                    const autoPayIfNeeded = async createRes => {
                        const payAddress = createRes?.data?.payAddress;
                        const payAmountSatoshis = createRes?.data?.amount || 0;
                        const paidAmountSatoshis = createRes?.data?.paidAmount || 0;
                        if (payAddress && payAmountSatoshis > 0 && paidAmountSatoshis < payAmountSatoshis) {
                            if (typeof window.unisat?.sendBitcoin === 'function') {
                                await window.unisat.sendBitcoin(payAddress, payAmountSatoshis, {
                                    feeRate: createRes?.data?.feeRate || 2
                                });
                            } else {
                                throw new Error(`Pay ${payAmountSatoshis / 100000000} FB to ${payAddress}`);
                            }
                        }
                    };
                    const waitForOrder = async (orderId, timeoutMs) => {
                        const deadline = Date.now() + (Number(timeoutMs || 0) || 12 * 60 * 1000);
                        while (Date.now() < deadline) {
                            const statusRes = await fetch(
                                `${BACKEND_URL}?action=inscription_status&orderId=${encodeURIComponent(orderId)}`,
                                { cache: 'no-store' }
                            ).then(r => r.json());
                            const d = statusRes && statusRes.data ? statusRes.data : null;
                            const files = d && Array.isArray(d.files) ? d.files : [];
                            const status = String(d?.status || '').toLowerCase();
                            const hasAnyId = files.some(f => f && (f.inscriptionId || f.inscription_id));
                            if (status === 'minted' || hasAnyId) {
                                return { statusRes, files };
                            }
                            if (status === 'closed' || status === 'refunded') {
                                throw new Error('Order closed/refunded');
                            }
                            await sleep(4000);
                        }
                        throw new Error('Timeout waiting for inscription');
                    };
                    const pickFileId = (files, pred, fallbackIndex) => {
                        const f = (files || []).find(x => {
                            const name = String(x?.filename || x?.fileName || '').toLowerCase();
                            return pred(name);
                        });
                        const id = f?.inscriptionId || f?.inscription_id;
                        if (id) return String(id);
                        const fallback = (files || [])[fallbackIndex];
                        return String(fallback?.inscriptionId || fallback?.inscription_id || '').trim();
                    };

                    const downloadTextFile = (text, filename, mimeType) => {
                        const blob = new Blob([String(text || '')], { type: String(mimeType || 'application/json') });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(() => URL.revokeObjectURL(url), 1000);
                    };

                    setStatus('Fetching lib/config…');
                    const libText = await fetchText('/reinscribe_pack/fennec_lib_v1.js').catch(() =>
                        fetchText('/recursive_inscriptions/fennec_lib_v1.js')
                    );
                    const cfgText = await fetchText('/reinscribe_pack/fennec_config_v1.json').catch(() =>
                        fetchText('/recursive_inscriptions/fennec_config_v1.json')
                    );

                    setStatus('Creating order (lib + config)…');
                    const coreCreate = await createOrder([
                        { filename: 'fennec_lib_v1.js', dataURL: toDataUrlFromText(libText, 'application/javascript') },
                        { filename: 'fennec_config_v1.json', dataURL: toDataUrlFromText(cfgText, 'application/json') }
                    ]);

                    const coreOrderId = coreCreate?.data?.orderId || coreCreate?.data?.id;
                    if (!coreOrderId) throw new Error('No orderId returned');

                    setStatus('Paying…');
                    await autoPayIfNeeded(coreCreate);

                    setStatus('Waiting for lib/config inscriptions…');
                    const coreReady = await waitForOrder(coreOrderId);
                    const libId = pickFileId(coreReady.files, n => n.includes('lib') && n.endsWith('.js'), 0);
                    const cfgId = pickFileId(coreReady.files, n => n.includes('config') && n.endsWith('.json'), 1);
                    if (!libId || !cfgId) throw new Error('Missing lib/config inscriptionId');

                    localStorage.setItem('fennec_mint_child_lib', libId);
                    localStorage.setItem('fennec_mint_child_config', cfgId);

                    try {
                        const libEl = document.getElementById('mintChildLibRef');
                        const cfgEl = document.getElementById('mintChildConfigRef');
                        if (libEl) libEl.value = libId;
                        if (cfgEl) cfgEl.value = cfgId;
                    } catch (e) {}

                    const manifestUrl = String(DEFAULT_MANIFEST_URL || '').trim();
                    if (!manifestUrl) {
                        throw new Error('No DEFAULT_MANIFEST_URL (run on your production domain, not localhost).');
                    }

                    const manifestObj = {
                        schema: 'fennec.manifest.v1',
                        version: 1,
                        updated_at: new Date().toISOString(),
                        latest: {
                            lib: libId,
                            config: cfgId
                        }
                    };
                    const manifestJsonPretty = JSON.stringify(manifestObj, null, 2);
                    downloadTextFile(manifestJsonPretty, 'fennec_manifest_live.json', 'application/json');

                    localStorage.setItem('fennec_mint_child_manifest', manifestUrl);
                    try {
                        const manEl = document.getElementById('mintChildManifestRef');
                        if (manEl) manEl.value = manifestUrl;
                    } catch (e) {}

                    setStatus(
                        'Done. Deploy downloaded fennec_manifest_live.json to /recursive_inscriptions/fennec_manifest_live.json, then mint.'
                    );
                } catch (e) {
                    setStatus('ERROR: ' + (e?.message || String(e)));
                }
            };

            window.inscribeFennecManifestOnly = async function () {
                const statusEl = document.getElementById('mintRefsStatus');
                const setStatus = t => {
                    try {
                        if (statusEl) statusEl.textContent = String(t || '');
                    } catch (e) {}
                };

                try {
                    if (!userAddress && !window.userAddress) {
                        setStatus('Connect wallet first.');
                        if (typeof connectWallet === 'function') connectWallet();
                        return;
                    }

                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    const libEl = document.getElementById('mintChildLibRef');
                    const cfgEl = document.getElementById('mintChildConfigRef');
                    const manEl = document.getElementById('mintChildManifestRef');
                    const libId = String(libEl?.value || localStorage.getItem('fennec_mint_child_lib') || '').trim();
                    const cfgId = String(cfgEl?.value || localStorage.getItem('fennec_mint_child_config') || '').trim();
                    if (!libId || !cfgId) throw new Error('Need lib + config refs first.');

                    const toDataUrlFromText = (text, mime) => {
                        const mt = String(mime || 'text/plain');
                        const b64 = btoa(unescape(encodeURIComponent(String(text || ''))));
                        return `data:${mt};base64,${b64}`;
                    };
                    const createOrder = async files => {
                        const createRes = await fetch(`${BACKEND_URL}?action=create_inscription`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                receiveAddress: userAddress || window.userAddress,
                                feeRate: 2,
                                outputValue: 546,
                                files
                            })
                        }).then(r => r.json());
                        if (!createRes || createRes.code !== 0)
                            throw new Error(createRes?.msg || 'Failed to create inscription');
                        return createRes;
                    };
                    const autoPayIfNeeded = async createRes => {
                        const payAddress = createRes?.data?.payAddress;
                        const payAmountSatoshis = createRes?.data?.amount || 0;
                        const paidAmountSatoshis = createRes?.data?.paidAmount || 0;
                        if (payAddress && payAmountSatoshis > 0 && paidAmountSatoshis < payAmountSatoshis) {
                            if (typeof window.unisat?.sendBitcoin === 'function') {
                                await window.unisat.sendBitcoin(payAddress, payAmountSatoshis, {
                                    feeRate: createRes?.data?.feeRate || 2
                                });
                            } else {
                                throw new Error(`Pay ${payAmountSatoshis / 100000000} FB to ${payAddress}`);
                            }
                        }
                    };
                    const sleep = ms => new Promise(r => setTimeout(r, ms));
                    const waitForOrder = async (orderId, timeoutMs) => {
                        const deadline = Date.now() + (Number(timeoutMs || 0) || 12 * 60 * 1000);
                        while (Date.now() < deadline) {
                            const statusRes = await fetch(
                                `${BACKEND_URL}?action=inscription_status&orderId=${encodeURIComponent(orderId)}`,
                                { cache: 'no-store' }
                            ).then(r => r.json());
                            const d = statusRes && statusRes.data ? statusRes.data : null;
                            const files = d && Array.isArray(d.files) ? d.files : [];
                            const status = String(d?.status || '').toLowerCase();
                            const hasAnyId = files.some(f => f && (f.inscriptionId || f.inscription_id));
                            if (status === 'minted' || hasAnyId) {
                                return { statusRes, files };
                            }
                            if (status === 'closed' || status === 'refunded') {
                                throw new Error('Order closed/refunded');
                            }
                            await sleep(4000);
                        }
                        throw new Error('Timeout waiting for inscription');
                    };

                    const manifestObj = {
                        schema: 'fennec.manifest.v1',
                        version: 1,
                        updated_at: new Date().toISOString(),
                        latest: {
                            lib: libId,
                            config: cfgId
                        }
                    };
                    const manifestJsonPretty = JSON.stringify(manifestObj, null, 2);

                    setStatus('Creating order (manifest)…');
                    const createRes = await createOrder([
                        {
                            filename: 'fennec_manifest_live.json',
                            dataURL: toDataUrlFromText(manifestJsonPretty, 'application/json')
                        }
                    ]);
                    const orderId = createRes?.data?.orderId || createRes?.data?.id;
                    if (!orderId) throw new Error('No orderId returned');

                    setStatus('Paying…');
                    await autoPayIfNeeded(createRes);

                    setStatus('Waiting for manifest inscription…');
                    const ready = await waitForOrder(orderId);
                    const files = ready.files || [];
                    const f0 = files[0];
                    const manId = String(f0?.inscriptionId || f0?.inscription_id || '').trim();
                    if (!manId) throw new Error('Missing manifest inscriptionId');

                    localStorage.setItem('fennec_mint_child_manifest', manId);
                    try {
                        if (manEl) manEl.value = manId;
                    } catch (_) {}

                    setStatus('Manifest inscribed and applied.');
                } catch (e) {
                    setStatus('ERROR: ' + (e?.message || String(e)));
                }
            };

            window.inscribeFennecAssetsAndConfig = async function () {
                const statusEl = document.getElementById('mintRefsStatus');
                const setStatus = t => {
                    try {
                        if (statusEl) statusEl.textContent = String(t || '');
                    } catch (e) {}
                };

                try {
                    const filesList = Array.isArray(window.__fennecMintAssetsFiles)
                        ? window.__fennecMintAssetsFiles
                        : [];
                    if (!filesList.length) {
                        throw new Error('No assets selected. Use the folder picker first.');
                    }

                    if (!userAddress && !window.userAddress) {
                        setStatus('Connect wallet first.');
                        if (typeof connectWallet === 'function') connectWallet();
                        return;
                    }

                    await checkFractalNetwork();
                    if (!userPubkey) userPubkey = await window.unisat.getPublicKey();

                    const sleep = ms => new Promise(r => setTimeout(r, ms));
                    const readAsDataUrl = file =>
                        new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(String(reader.result || ''));
                            reader.onerror = () => reject(new Error('Failed to read file: ' + (file?.name || '')));
                            reader.readAsDataURL(file);
                        });
                    const toDataUrlFromText = (text, mime) => {
                        const mt = String(mime || 'text/plain');
                        const b64 = btoa(unescape(encodeURIComponent(String(text || ''))));
                        return `data:${mt};base64,${b64}`;
                    };
                    const fetchText = async url => {
                        const res = await fetch(url, { cache: 'no-store' });
                        if (!res.ok) throw new Error(`Fetch failed ${res.status}: ${url}`);
                        return await res.text();
                    };
                    const createOrder = async files => {
                        const createRes = await fetch(`${BACKEND_URL}?action=create_inscription`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                receiveAddress: userAddress || window.userAddress,
                                feeRate: 2,
                                outputValue: 546,
                                files
                            })
                        }).then(r => r.json());
                        if (!createRes || createRes.code !== 0)
                            throw new Error(createRes?.msg || 'Failed to create inscription');
                        return createRes;
                    };
                    const autoPayIfNeeded = async createRes => {
                        const payAddress = createRes?.data?.payAddress;
                        const payAmountSatoshis = createRes?.data?.amount || 0;
                        const paidAmountSatoshis = createRes?.data?.paidAmount || 0;
                        if (payAddress && payAmountSatoshis > 0 && paidAmountSatoshis < payAmountSatoshis) {
                            if (typeof window.unisat?.sendBitcoin === 'function') {
                                await window.unisat.sendBitcoin(payAddress, payAmountSatoshis, {
                                    feeRate: createRes?.data?.feeRate || 2
                                });
                            } else {
                                throw new Error(`Pay ${payAmountSatoshis / 100000000} FB to ${payAddress}`);
                            }
                        }
                    };
                    const waitForOrder = async (orderId, timeoutMs) => {
                        const deadline = Date.now() + (Number(timeoutMs || 0) || 18 * 60 * 1000);
                        while (Date.now() < deadline) {
                            const statusRes = await fetch(
                                `${BACKEND_URL}?action=inscription_status&orderId=${encodeURIComponent(orderId)}`,
                                { cache: 'no-store' }
                            ).then(r => r.json());
                            const d = statusRes && statusRes.data ? statusRes.data : null;
                            const files = d && Array.isArray(d.files) ? d.files : [];
                            const status = String(d?.status || '').toLowerCase();
                            const readyCount = files.filter(f => f && (f.inscriptionId || f.inscription_id)).length;
                            if (readyCount === files.length && files.length > 0) {
                                return { statusRes, files };
                            }
                            if (status === 'minted' && files.length > 0) {
                                return { statusRes, files };
                            }
                            if (status === 'closed' || status === 'refunded') {
                                throw new Error('Order closed/refunded');
                            }
                            await sleep(4500);
                        }
                        throw new Error('Timeout waiting for inscription');
                    };
                    const downloadTextFile = (text, filename, mimeType) => {
                        const blob = new Blob([String(text || '')], { type: String(mimeType || 'application/json') });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(() => URL.revokeObjectURL(url), 1000);
                    };

                    const lower = s => String(s || '').toLowerCase();
                    const allFiles = filesList.slice();
                    const findByRegex = re => allFiles.find(f => re.test(lower(f?.name || '')));
                    const extOf = name => {
                        const m = String(name || '')
                            .toLowerCase()
                            .match(/\.(png|jpg|jpeg|webp|gif)$/);
                        return m ? m[1] : 'png';
                    };

                    const bgDefs = [
                        {
                            key: 'DRIFTER',
                            prefer: /^bg_drifter_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^drifter\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'WALKER',
                            prefer: /^bg_walker_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^walker\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'KEEPER',
                            prefer: /^bg_keeper_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^keeper\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'ENGINEER',
                            prefer: /^bg_engineer_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^engineer\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'MERCHANT',
                            prefer: /^bg_merchant_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^merchant\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'SHAMAN',
                            prefer: /^bg_shaman_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^shaman\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'LORD',
                            prefer: /^bg_lord_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^oasis\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'PRIME',
                            prefer: /^bg_prime_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^prime\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            key: 'SINGULARITY',
                            prefer: /^bg_singularity_.*\.(png|jpg|jpeg|webp)$/i,
                            fallback: /^singularity\.(png|jpg|jpeg|webp)$/i
                        }
                    ];
                    const badgeDefs = [
                        {
                            cfg: 'GENESIS',
                            prefer: /^badge_genesis_.*\.(png|webp)$/i,
                            fallback: /^badge_genesis\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'WHALE',
                            prefer: /^badge_whale_.*\.(png|webp)$/i,
                            fallback: /^badge_whale\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'PROVIDER',
                            prefer: /^badge_provider_.*\.(png|webp)$/i,
                            fallback: /^badge_provider\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'FENNEC MAXI',
                            prefer: /^badge_fennec_maxi_.*\.(png|webp)$/i,
                            fallback: /^badge_maxi\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'ARTIFACT HUNTER',
                            prefer: /^badge_artifact_hunter_.*\.(png|webp)$/i,
                            fallback: /^badge_collector\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'RUNE KEEPER',
                            prefer: /^badge_rune_keeper_.*\.(png|webp)$/i,
                            fallback: /^badge_rune\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'MEMPOOL RIDER',
                            prefer: /^badge_mempool_rider_.*\.(png|webp)$/i,
                            fallback: /^badge_mempool_rider\.(png|jpg|jpeg|webp)$/i
                        },
                        {
                            cfg: 'SAND SWEEPER',
                            prefer: /^badge_sand_sweeper_.*\.(png|webp)$/i,
                            fallback: /^badge_sweeper\.(png|jpg|jpeg|webp)$/i
                        }
                    ];

                    const assetsToInscribe = [];
                    for (const d of bgDefs) {
                        const f = findByRegex(d.prefer) || findByRegex(d.fallback);
                        if (!f) continue;
                        const ext = extOf(f.name);
                        assetsToInscribe.push({
                            kind: 'bg',
                            key: d.key,
                            file: f,
                            filename: `bg_${d.key.toLowerCase()}.${ext}`
                        });
                    }
                    for (const d of badgeDefs) {
                        const f = findByRegex(d.prefer) || findByRegex(d.fallback);
                        if (!f) continue;
                        const ext = extOf(f.name);
                        assetsToInscribe.push({
                            kind: 'badge',
                            key: d.cfg,
                            file: f,
                            filename: `badge_${d.cfg.toLowerCase().replace(/\s+/g, '_')}.${ext}`
                        });
                    }

                    const logoFile = findByRegex(/^phav\.(png|jpg|jpeg|webp)$/i);
                    if (logoFile) {
                        assetsToInscribe.push({
                            kind: 'misc',
                            key: 'LOGO',
                            file: logoFile,
                            filename: `logo.${extOf(logoFile.name)}`
                        });
                    }
                    const heartFile = findByRegex(/^heart\.(png|jpg|jpeg|webp)$/i);
                    if (heartFile) {
                        assetsToInscribe.push({
                            kind: 'misc',
                            key: 'HEART',
                            file: heartFile,
                            filename: `heart.${extOf(heartFile.name)}`
                        });
                    }
                    const watermarkFile = findByRegex(/^fbsym\.(png|jpg|jpeg|webp)$/i);
                    if (watermarkFile) {
                        assetsToInscribe.push({
                            kind: 'misc',
                            key: 'WATERMARK',
                            file: watermarkFile,
                            filename: `watermark.${extOf(watermarkFile.name)}`
                        });
                    }

                    if (!assetsToInscribe.length) {
                        throw new Error(
                            'No known assets found in selected folder. Use asset_prep output + include phav.png/FBSYM.png if you want misc.'
                        );
                    }

                    const tooBig = assetsToInscribe.find(a => (a.file?.size || 0) > 370 * 1024);
                    if (tooBig) {
                        throw new Error(
                            `File too large (>370KB): ${tooBig.file?.name || ''}. Use asset_prep to compress.`
                        );
                    }

                    setStatus(`Encoding assets (${assetsToInscribe.length})…`);
                    for (const a of assetsToInscribe) {
                        a.dataURL = await readAsDataUrl(a.file);
                    }

                    const chunk = (arr, n) => {
                        const out = [];
                        for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n));
                        return out;
                    };

                    const inscribedIdsByFilename = {};
                    const batches = chunk(assetsToInscribe, 9);
                    let batchNum = 0;
                    for (const b of batches) {
                        batchNum++;
                        setStatus(`Creating assets order ${batchNum}/${batches.length}…`);
                        const createRes = await createOrder(b.map(x => ({ filename: x.filename, dataURL: x.dataURL })));
                        const orderId = createRes?.data?.orderId || createRes?.data?.id;
                        if (!orderId) throw new Error('No assets orderId returned');
                        setStatus(`Paying assets order ${batchNum}/${batches.length}…`);
                        await autoPayIfNeeded(createRes);
                        setStatus(`Waiting assets order ${batchNum}/${batches.length}…`);
                        const ready = await waitForOrder(orderId);
                        for (const f of ready.files || []) {
                            const fn = String(f?.filename || f?.fileName || '');
                            const id = String(f?.inscriptionId || f?.inscription_id || '').trim();
                            if (fn && id) inscribedIdsByFilename[fn] = id;
                        }
                    }

                    const bgMap = {};
                    const badgeMap = {};
                    const miscMap = {};
                    for (const a of assetsToInscribe) {
                        const id = String(inscribedIdsByFilename[a.filename] || '').trim();
                        if (!id) continue;
                        if (a.kind === 'bg') bgMap[a.key] = id;
                        if (a.kind === 'badge') badgeMap[a.key] = id;
                        if (a.kind === 'misc') miscMap[a.key] = id;
                    }

                    setStatus('Building config…');
                    const baseCfgText = await fetchText('/reinscribe_pack/fennec_config_v1.json').catch(() =>
                        fetchText('/recursive_inscriptions/fennec_config_v1.json')
                    );
                    const baseCfg = JSON.parse(baseCfgText);
                    baseCfg.assets = baseCfg.assets || {};
                    baseCfg.assets.backgrounds = baseCfg.assets.backgrounds || {};
                    baseCfg.assets.badges = baseCfg.assets.badges || {};
                    baseCfg.assets.misc = baseCfg.assets.misc || {};

                    for (const [k, v] of Object.entries(bgMap)) baseCfg.assets.backgrounds[k] = v;
                    if (bgMap.DRIFTER) baseCfg.assets.backgrounds['*'] = bgMap.DRIFTER;
                    for (const [k, v] of Object.entries(badgeMap)) baseCfg.assets.badges[k] = v;
                    for (const [k, v] of Object.entries(miscMap)) baseCfg.assets.misc[k] = v;

                    setStatus('Inscribing config…');
                    const cfgCreate = await createOrder([
                        {
                            filename: 'fennec_config_v1.json',
                            dataURL: toDataUrlFromText(JSON.stringify(baseCfg), 'application/json')
                        }
                    ]);
                    const cfgOrderId = cfgCreate?.data?.orderId || cfgCreate?.data?.id;
                    if (!cfgOrderId) throw new Error('No config orderId');
                    setStatus('Paying config…');
                    await autoPayIfNeeded(cfgCreate);
                    setStatus('Waiting config…');
                    const cfgReady = await waitForOrder(cfgOrderId);
                    const cfgFile0 = (cfgReady.files || [])[0] || null;
                    const cfgId = String(cfgFile0?.inscriptionId || cfgFile0?.inscription_id || '').trim();
                    if (!cfgId) throw new Error('Missing config inscriptionId');

                    localStorage.setItem('fennec_mint_child_config', cfgId);
                    try {
                        const cfgEl = document.getElementById('mintChildConfigRef');
                        if (cfgEl) cfgEl.value = cfgId;
                    } catch (e) {}

                    const libId = String(localStorage.getItem('fennec_mint_child_lib') || '').trim();
                    if (!libId) {
                        setStatus('Config ready. Now run INSCRIBE CORE PACK to inscribe lib, then deploy manifest.');
                        return;
                    }

                    const manifestUrl = String(DEFAULT_MANIFEST_URL || '').trim();
                    if (!manifestUrl) throw new Error('No DEFAULT_MANIFEST_URL');

                    const manifestObj = {
                        schema: 'fennec.manifest.v1',
                        version: 1,
                        updated_at: new Date().toISOString(),
                        latest: {
                            lib: libId,
                            config: cfgId
                        }
                    };
                    downloadTextFile(
                        JSON.stringify(manifestObj, null, 2),
                        'fennec_manifest_live.json',
                        'application/json'
                    );
                    localStorage.setItem('fennec_mint_child_manifest', manifestUrl);
                    try {
                        const manEl = document.getElementById('mintChildManifestRef');
                        if (manEl) manEl.value = manifestUrl;
                    } catch (e) {}

                    setStatus('Done. Deploy downloaded fennec_manifest_live.json (overwriting existing), then mint.');
                } catch (e) {
                    setStatus('ERROR: ' + (e?.message || String(e)));
                }
            };

            window.checkDiscountEligibility = function () {
                try {
                    if (!auditIdentity || !auditIdentity.metrics) {
                        return;
                    }
                    const metrics = auditIdentity.metrics;
                    const fennecWalletOnly =
                        Number(metrics.fennecWalletBalance ?? metrics.fennec_wallet_balance ?? 0) || 0;
                    const fennecLpValueUSD = Number(metrics.fennecLpValueUSD || 0) || 0;
                    const hasBoxes = !!(
                        metrics.hasFennecBoxes ||
                        metrics.has_fennec_boxes ||
                        metrics.fennecBoxesCount > 0 ||
                        metrics.fennec_boxes_count > 0
                    );
                    const eligible = hasBoxes || fennecWalletOnly >= 100 || fennecLpValueUSD >= 1;

                    const mintBtnText = document.getElementById('mintBtnText');
                    const why = document.getElementById('discountWhy');
                    if (eligible) {
                        window.__discountCheckPassed = true;
                        if (mintBtnText) {
                            mintBtnText.innerHTML =
                                '<span style="text-decoration: line-through; opacity: 0.6;">1 FB</span> <span style="font-weight: bold;">0.5 FB (50% OFF!)</span>';
                        }
                        if (why) {
                            why.textContent = 'Discount active: 50% OFF unlocked.';
                        }
                    } else {
                        window.__discountCheckPassed = false;
                        if (mintBtnText) {
                            mintBtnText.innerHTML = '1 FB';
                        }
                        if (why) {
                            const needWallet = fennecWalletOnly < 100;
                            const needLp = fennecLpValueUSD < 1;
                            if (needWallet && needLp) {
                                why.textContent = `Discount inactive: need 100+ FENNEC in wallet (now ${fennecWalletOnly}) or $1+ FENNEC LP (now $${fennecLpValueUSD.toFixed(2)}).`;
                            } else if (needWallet) {
                                why.textContent = `Discount inactive: need 100+ FENNEC in wallet (now ${fennecWalletOnly}).`;
                            } else if (needLp) {
                                why.textContent = `Discount inactive: need $1+ FENNEC LP (now $${fennecLpValueUSD.toFixed(2)}).`;
                            } else {
                                why.textContent = 'Discount inactive.';
                            }
                        }
                    }
                } catch (e) {
                    // silent
                }
            };

            // Force Scroll to Top (Final)
            window.onbeforeunload = function () {
                window.scrollTo(0, 0);
            };
            window.onload = function () {
                setTimeout(() => window.scrollTo(0, 0), 10);
                setTimeout(() => window.scrollTo(0, 0), 100);
            };

            // Chat Widget Functions
            function toggleChat() {
                const chatWindow = document.getElementById('chatWindow');
                const chatTrigger = document.getElementById('chatTrigger');
                if (!chatWindow) return;

                if (chatWindow.classList.contains('hidden')) {
                    chatWindow.classList.remove('hidden');
                    setTimeout(() => {
                        chatWindow.style.transform = 'scale(1)';
                        chatWindow.style.opacity = '1';
                    }, 10);
                } else {
                    chatWindow.style.transform = 'scale(0.9)';
                    chatWindow.style.opacity = '0';
                    setTimeout(() => chatWindow.classList.add('hidden'), 300);
                }
            }

            function sendMessage() {
                const input = document.getElementById('chatInput');
                const messages = document.getElementById('chatMessages');
                if (!input || !messages) return;

                const text = input.value.trim();
                if (!text) return;

                const userMsg = document.createElement('div');
                userMsg.className = 'flex gap-2 items-start justify-end';
                userMsg.innerHTML = `<div class="bg-fennec/20 p-3 rounded-lg rounded-tr-none max-w-[80%]">${text}</div>`;
                messages.appendChild(userMsg);

                input.value = '';
                messages.scrollTop = messages.scrollHeight;

                setTimeout(() => {
                    const botMsg = document.createElement('div');
                    botMsg.className = 'flex gap-2 items-start';
                    botMsg.innerHTML = `<div class="w-6 h-6 flex-shrink-0"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-3 rounded-lg rounded-tl-none flex-1">I'm here to help! Visit our docs or ask the community.</div>`;
                    messages.appendChild(botMsg);
                    messages.scrollTop = messages.scrollHeight;
                }, 500);
            }

            function oracleQuick(action) {
                const messages = document.getElementById('chatMessages');
                if (!messages) return;

                let response = 'Let me help you with that!';
                if (action === 'help')
                    response = 'Browse the site using the top navigation. Connect your wallet to access all features.';
                else if (action === 'prices')
                    response = 'Check the Terminal section for live FENNEC price and market data.';
                else if (action === 'swap') response = 'Visit the Terminal to swap FB for FENNEC tokens.';
                else if (action === 'id')
                    response =
                        'Connect your wallet and visit Fennec ID to generate your unique on-chain identity card.';
                else if (action === 'deposit')
                    response = 'Use the Terminal Deposit tab to fund your account with FB or BTC.';
                else if (action === 'withdraw')
                    response = 'Use the Terminal Withdraw tab to move your funds back to your wallet.';
                else if (action === 'clear') {
                    messages.innerHTML =
                        '<div class="flex gap-2 items-start"><div class="w-6 h-6 flex-shrink-0"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-3 rounded-lg rounded-tl-none flex-1">Ask me anything about Fennec.</div></div>';
                    return;
                }

                const botMsg = document.createElement('div');
                botMsg.className = 'flex gap-2 items-start';
                botMsg.innerHTML = `<div class="w-6 h-6 flex-shrink-0"><img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar"></div><div class="bg-white/5 p-3 rounded-lg rounded-tl-none flex-1">${response}</div>`;
                messages.appendChild(botMsg);
                messages.scrollTop = messages.scrollHeight;
            }
        </script>

        <!-- CHAT WIDGET -->
        <div id="chatWidget" class="fixed bottom-12 right-6 z-50 flex flex-col items-end pointer-events-none">
            <div
                id="chatWindow"
                class="mb-4 w-80 bg-[#1a100c]/95 backdrop-blur-xl border border-fennec/30 rounded-2xl shadow-[0_0_50px_rgba(255,107,53,0.15)] overflow-hidden transform origin-bottom-right scale-90 opacity-0 transition-all duration-300 pointer-events-auto hidden"
            >
                <div
                    class="bg-gradient-to-r from-fennec/20 to-transparent p-3 border-b border-white/5 flex justify-between items-center"
                >
                    <div class="flex items-center gap-2">
                        <div class="w-5 h-5 flex-shrink-0">
                            <img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar" />
                        </div>
                        <span class="text-xs font-mono font-bold text-fennec tracking-widest">ASSISTANT</span>
                    </div>
                    <button onclick="window.toggleChat()" class="text-gray-500 hover:text-white">✕</button>
                </div>
                <div class="px-3 py-2 border-b border-white/5 bg-black/10">
                    <div class="flex flex-wrap gap-2 justify-center">
                        <button
                            onclick="oracleQuick('help')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            HELP
                        </button>
                        <button
                            onclick="oracleQuick('prices')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            PRICE
                        </button>
                        <button
                            onclick="oracleQuick('swap')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            SWAP
                        </button>
                        <button
                            onclick="oracleQuick('id')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            FENNEC ID
                        </button>
                        <button
                            onclick="oracleQuick('deposit')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            DEPOSIT
                        </button>
                        <button
                            onclick="oracleQuick('withdraw')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-fennec/40 hover:bg-fennec/10 transition"
                        >
                            WITHDRAW
                        </button>
                        <button
                            onclick="oracleQuick('clear')"
                            class="text-[10px] font-bold px-2 py-1 rounded-full bg-white/5 border border-white/10 text-gray-300 hover:text-white hover:border-red-500/40 hover:bg-red-500/10 transition"
                        >
                            CLEAR
                        </button>
                    </div>
                    <div id="chatLoading" class="hidden mt-2 text-[10px] text-gray-500 font-mono">
                        Scanning the dunes...
                    </div>
                </div>
                <div id="chatMessages" class="h-80 overflow-y-auto p-4 space-y-3 scrollbar-thin text-xs text-gray-300">
                    <div class="flex gap-2 items-start">
                        <div class="w-6 h-6 flex-shrink-0">
                            <img src="img/FENNECAI.png" class="w-full h-full object-contain ai-avatar" />
                        </div>
                        <div class="bg-white/5 p-3 rounded-lg rounded-tl-none flex-1">
                            Ask me anything about Fennec.
                        </div>
                    </div>
                </div>
                <div class="p-3 border-t border-white/10 bg-black/20 relative">
                    <input
                        type="text"
                        id="chatInput"
                        placeholder="Ask..."
                        class="w-full bg-black/50 border border-white/10 rounded-lg pl-3 pr-12 py-3 text-xs text-white outline-none focus:border-fennec/50 transition"
                        onkeypress="if (event.key === 'Enter') sendMessage();"
                    />
                    <button
                        onclick="sendMessage()"
                        id="chatSendBtn"
                        class="absolute right-2 top-1/2 -translate-y-1/2 text-fennec w-9 h-9 flex items-center justify-center rounded-md bg-white/5 border border-white/10 hover:bg-fennec/10 hover:border-fennec/30"
                    >
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            <button
                onclick="window.toggleChat()"
                id="chatTrigger"
                class="pointer-events-auto w-14 h-14 bg-[#2b1d1a] rounded-full border border-fennec/50 shadow-lg flex items-center justify-center hover:scale-110 transition hover:bg-fennec hover:text-black overflow-hidden"
            >
                <img src="img/FENNECAI.png" class="w-10 h-10 object-contain ai-avatar" />
            </button>
        </div>

        <script>
            (function () {
                const canvas = document.getElementById('animatedBackgroundCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const colors = [
                    'rgba(249, 115, 22, ',
                    'rgba(251, 146, 60, ',
                    'rgba(234, 88, 12, ',
                    'rgba(255, 186, 120, '
                ];

                const mouse = { x: 0, y: 0 };
                let cw = 0;
                let ch = 0;
                let dpr = 1;
                let particles = [];
                let raf = 0;

                function resizeCanvas() {
                    dpr = Math.min(2, window.devicePixelRatio || 1);
                    cw = Math.max(1, window.innerWidth || 1);
                    ch = Math.max(1, window.innerHeight || 1);

                    canvas.width = Math.max(1, Math.floor(cw * dpr));
                    canvas.height = Math.max(1, Math.floor(ch * dpr));
                    try {
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    } catch (_) {}
                }

                function createParticles() {
                    const particleCount = Math.min(220, Math.max(60, Math.floor((cw * ch) / 18000)));
                    const out = [];
                    for (let i = 0; i < particleCount; i++) {
                        out.push({
                            x: Math.random() * cw,
                            y: Math.random() * ch,
                            size: Math.random() * 2 + 0.5,
                            speedX: (Math.random() - 0.5) * 0.3,
                            speedY: (Math.random() - 0.5) * 0.3,
                            opacity: Math.random() * 0.5 + 0.2,
                            color: colors[Math.floor(Math.random() * colors.length)]
                        });
                    }
                    return out;
                }

                function drawGradientBackground() {
                    const gradient = ctx.createRadialGradient(cw / 2, ch / 3, 0, cw / 2, ch / 2, cw);
                    gradient.addColorStop(0, 'rgba(40, 25, 15, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 12, 8, 1)');
                    gradient.addColorStop(1, 'rgba(10, 6, 4, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, cw, ch);

                    const glowGradient = ctx.createRadialGradient(cw / 2, 0, 0, cw / 2, 0, ch * 0.8);
                    glowGradient.addColorStop(0, 'rgba(249, 115, 22, 0.15)');
                    glowGradient.addColorStop(0.3, 'rgba(249, 115, 22, 0.05)');
                    glowGradient.addColorStop(1, 'rgba(249, 115, 22, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(0, 0, cw, ch);

                    const mx = mouse.x || 0;
                    const my = mouse.y || 0;
                    const mouseGlow = ctx.createRadialGradient(mx, my, 0, mx, my, 300);
                    mouseGlow.addColorStop(0, 'rgba(249, 115, 22, 0.08)');
                    mouseGlow.addColorStop(0.5, 'rgba(249, 115, 22, 0.02)');
                    mouseGlow.addColorStop(1, 'rgba(249, 115, 22, 0)');
                    ctx.fillStyle = mouseGlow;
                    ctx.fillRect(0, 0, cw, ch);
                }

                function drawParticles() {
                    for (let i = 0; i < particles.length; i++) {
                        const p = particles[i];
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `${p.color}${p.opacity})`;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
                        g.addColorStop(0, `${p.color}${p.opacity * 0.5})`);
                        g.addColorStop(1, `${p.color}0)`);
                        ctx.fillStyle = g;
                        ctx.fill();
                    }
                }

                function connectParticles() {
                    const maxDistance = 150;
                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            const dx = particles[i].x - particles[j].x;
                            const dy = particles[i].y - particles[j].y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < maxDistance) {
                                const opacity = (1 - dist / maxDistance) * 0.15;
                                ctx.beginPath();
                                ctx.strokeStyle = `rgba(249, 115, 22, ${opacity})`;
                                ctx.lineWidth = 0.5;
                                ctx.moveTo(particles[i].x, particles[i].y);
                                ctx.lineTo(particles[j].x, particles[j].y);
                                ctx.stroke();
                            }
                        }
                    }
                }

                function updateParticles() {
                    for (let i = 0; i < particles.length; i++) {
                        const p = particles[i];
                        p.x += p.speedX;
                        p.y += p.speedY;

                        const dx = mouse.x - p.x;
                        const dy = mouse.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0.0001 && dist < 200) {
                            const force = (200 - dist) / 200;
                            p.x -= (dx / dist) * force * 0.5;
                            p.y -= (dy / dist) * force * 0.5;
                        }

                        if (p.x < 0) p.x = cw;
                        if (p.x > cw) p.x = 0;
                        if (p.y < 0) p.y = ch;
                        if (p.y > ch) p.y = 0;

                        p.opacity += (Math.random() - 0.5) * 0.01;
                        p.opacity = Math.max(0.1, Math.min(0.7, p.opacity));
                    }
                }

                function animate() {
                    drawGradientBackground();
                    updateParticles();
                    connectParticles();
                    drawParticles();
                    raf = requestAnimationFrame(animate);
                }

                function handleMouseMove(e) {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                }

                function cleanup() {
                    if (raf) cancelAnimationFrame(raf);
                    raf = 0;
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('resize', onResize);
                }

                const onResize = function () {
                    resizeCanvas();
                    particles = createParticles();
                };

                resizeCanvas();
                particles = createParticles();

                if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    drawGradientBackground();
                } else {
                    animate();
                }

                window.addEventListener('resize', onResize);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('pagehide', cleanup, { once: true });
            })();
        </script>
    </body>
</html>
